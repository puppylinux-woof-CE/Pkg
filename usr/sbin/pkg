#!/bin/ash
#
#  pkg - a command line package manager for Puppy Linux
#
#  By Scott Jarvis (sc0ttman)
#
#  Copyright (c) 2013 Puppy Linux Community
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 1 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

{
#==================  setup script vars  =====================#
APPNAME="Pkg"
APPVER="1.9.23"

# get current locale settings
USER_LANG=$LANG
USER_LC_ALL=$LC_ALL

#run as root only
whoami=$(whoami)

TMPDIR=/tmp/pkg/${whoami}/$$  # set the tmp dir
mkdir -p "$TMPDIR" &>/dev/null

SELF=$(basename "$0")      # this script
QTAG=''                    # gets set to (y/n) if ASK=-true
LANG=C                     # speed up
LC_ALL=C                   # speed up
EDITOR=${EDITOR:-vi}       # just in case
PAGER=${PAGER:-less}       # just in case
CURDIR="${PWD}"            # get current dir, before cd to WORKDIR
REPO_DIR=~/.packages       # where the repo files live
[ -d /var/packages ] && REPO_DIR=/var/packages
export REPO_DIR

# set colours true by default
green="\e[32m"; red="\e[91m"; magenta="\e[95m"; lightblue="\e[36m"; yellow="\e[93m"; bold="\e[1m"; endcolour="\e[0m"

# ENVIRONMENT VARS, which may be overridden later
[ -z "$PKGRC" ] && export PKGRC=${HOME}/.pkg/pkgrc      # config file for this script
[ -z "$ASK"   ] && ASK=false                            # if true, ask user before doing stuff. Overridden by --ask
[ -z "$ASK"   ] && PLUGIN_ASK="${ASK:-false}"           # if true, plugins will respect --ask, will making sure Pkg itself still only "asks once"
[ -z "$QUIET" ] && QUIET=false                          # if true, hide output that doesnt log well in Xdialog, Gtkdialog, etc
[ -z "$FORCE" ] && FORCE=false                          # if true, force (re)install/remove pkgs. Overridden by --force
[ -z "$HIDE_INSTALLED" ] && export HIDE_INSTALLED=false # if true, hide installed pkgs from pkg searches (-n, -na, -ss, -ssa)
[ -z "$HIDE_BUILTINS"  ] && export HIDE_BUILTINS=true   # if true, remove builtins pkgs from dep lists, dont download/install them
[ -z "$HIDE_USER_PKGS" ] && export HIDE_USER_PKGS=true  # if true, hide user installed pkgs from dep lists, dont download/install them
[ -z "$NO_ALIASES"     ] && export NO_ALIASES=false     # if true, skip searching pkg alias names for pkg alternatives
[ -z "$NO_INSTALL"     ] && export NO_INSTALL=false     # if true, skip installing of pkgs
[ -z "$PKG_NO_COLOURS" ] && export PKG_NO_COLOURS=false # if true, disable coloured output or not
[ -z "$PKG_CONFIGURE"  ] && export PKG_CONFIGURE=''     # reset
[ -z "$PKG_CFLAGS"     ] && export PKG_CFLAGS=''        # reset
[ -z "$PKG_BLACKLIST"  ] && export PKG_BLACKLIST=''     # reset
[ -z "$PKG_PPA2PUP_FN" ] && if [ ! -z "$(which gawk)" ]; then PKG_PPA2PUP_FN=ppa2pup_gawk; else PKG_PPA2PUP_FN=ppa2pup; fi

# but disable colours if called as gpkg, or the ENV variable PKG_NO_COLOURS is true
if [ "$SELF" != "pkg" ] || [ "$PKG_NO_COLOURS" = true ];then
  green='' red='' magenta='' lightblue='' yellow='' bold='' endcolour=''
fi

# report errors better than just echo
error(){
  echo -e 1>&2 "${red}Error:${endcolour} $1"
}

# for correct error output, trap commands early
cleanup(){
  # shellcheck disable=SC2086
  rm -f ${TMPDIR}/missing_dep* ${TMPDIR}/installed_pkg* ${TMPDIR}/all_dep* \
    ${TMPDIR}/DEP_DONE /tmp/pkg/list_deps_busy ${TMPDIR}/pkg_file_list \
    ${TMPDIR}/dependents_list ${TMPDIR}/DEP_DONE ${TMPDIR}/ldd_file_list \
    ./build_pkg/ ~/pkg/build_pkg /tmp/pkg/build_pkg/ &>/dev/null

  # prevent double msg output if error=130 (user Ctrl-C)
  if [ -f /tmp/pkg/error130 ] && [ "$2" = '130' ];then
    exit "$2"
  fi
  # make the tmp dir we'll use
  mkdir -p ${TMPDIR:-/tmp/pkg} &>/dev/null
  # only add line numbers if it was given
  [ "$1" != 'none' ] && lineno="line $1, " || lineno=''
  # get the right error msg
  case "$2" in
  130) echo; msg="User cancelled operation!"; touch ${TMPDIR:-/tmp/pkg/}error130;;
  8)   msg="Package URL invalid.";;
  7)   msg="Package extraction failed.";;
  6)   msg="Missing package file.";;
  5)   msg="Missing directory.";;
  4)   msg="Copy failed.";;
  3)   msg="Setup failed.";;
  2)   msg="Code error!";;
  1)   exit 1 ;; # user gave wrong options or pkg name, not serious
  *)   msg="Error code = $2" ;;
  esac
  # print msg
  [ "$2" != "0" ] && echo -e 1>&2 "${red}Error${endcolour} ${2}: ${lineno}$msg"
  exit "$2"
}
trap 'cleanup ${LINENO:-none} $?' EXIT INT TERM

[ "$whoami" != "root" ] && echo "You must be root to run Pkg." && exit 1

#080413 make sure all config files are present, copy from /etc if need be
if [ ! -f "${PKGRC}" ];then
  echo "Restoring default settings from /etc/pkg"
  [ ! -d /etc/pkg/ ] && error "Default config files  in /etc/pkg/ not found." && exit 3
  mkdir -p "$HOME/.pkg"
  [ ! -d "$HOME/.pkg" ] && error "Default user config dir '$HOME/.pkg/' could not be created." && exit 3
  cp --force -a /etc/pkg/* "$HOME/.pkg/" || exit 3
fi

# get puppy distro env vars
[ -f /etc/rc.d/PUPSTATE ]                   && . /etc/rc.d/PUPSTATE                    #this has PUPMODE and SAVE_LAYER.
[ -f /etc/DISTRO_SPECS ]                    && . /etc/DISTRO_SPECS                     #has DISTRO_BINARY_COMPAT, DISTRO_COMPAT_VERSION
[ -f /etc/rc.d/BOOTCONFIG ]                 && . /etc/rc.d/BOOTCONFIG                  #has EXTRASFSLIST PREVUNIONRECORD, LASTUNIONRECORD (sfs stuff)
[ -f /etc/xdg/menus/hierarchy ]             && . /etc/xdg/menus/hierarchy              #w478 has PUPHIERARCHY variable.
[ -f ${REPO_DIR}/DISTRO_PKGS_SPECS ]        && . ${REPO_DIR}/DISTRO_PKGS_SPECS         #has lot sof essential info
[ -f ${REPO_DIR}/PKGS_MANAGEMENT ]          && . ${REPO_DIR}/PKGS_MANAGEMENT           #has PKG_NAME_IGNORE, PKG_PET_THEN_BLACKLIST_COMPAT_KIDS, PKG_REPOS_ENABLED
[ -f ${REPO_DIR}/DISTRO_COMPAT_REPOS ]      && . ${REPO_DIR}/DISTRO_COMPAT_REPOS       #has repo URL related vars

# set the package name suffix appended to combined pkgs (pkg+deps)
CP_SUFFIX="WITHDEPS_${DISTRO_FILE_PREFIX}"

# set correct arch for repo URLs (used by some slack-pup repos)
case "$DISTRO_TARGETARCH" in
  x86)    DBIN_ARCH=i486                ;;
  x86_64) DBIN_ARCH=x86_64 ; DSUFFIX=64 ;;
  arm64)  DBIN_ARCH=arm64  ; DSUFFIX=64 ;;
  armel)  DBIN_ARCH=armel  ; DSUFFIX=64 ;;
  armhf)  DBIN_ARCH=armh   ; DSUFFIX=64 ;;
  *)      DBIN_ARCH=i486                ;;
esac
export DSUFFIX;

# set correct package name/version separator (helps resolve package names)
separator='_'
case $DISTRO_BINARY_COMPAT in
  ubuntu|trisquel|debian|devuan)
    separator='_'
    ;;
  *)
    separator='-'
    ;;
esac
export separator

# needed for some debian based repos
case $DISTRO_COMPAT_VERSION in
  wheezy) DDB_COMP=bz2 ;; # older versions
  *)      DDB_COMP=xz  ;;
esac

# 0setup must be used differently in older and newer Woof-CE versions, so
# check which version of 0setup we're using, then set a flag on how to use it
PKG_REPO_UPDATE_METHOD=${PKG_REPO_UPDATE_METHOD:-standard}
# shellcheck disable=SC2016
if [ "$(grep -m1 'if \[ -d ./support -a -f ./DISTRO_SPECS -a -d ./rootfs-skeleton \] ;then' /usr/local/petget/0setup)" = "" ] && \
   [ "$(grep -m1 'if \[ "$RUNNINGPUP" = "yes" \];then' /usr/local/petget/0setup)" != "" ]
then
  PKG_REPO_UPDATE_METHOD=legacy
fi
export PKG_REPO_UPDATE_METHOD

# now create 'layers-installed': will contain builtins (and devx packages, if devx is loaded)
#130511 need to include devx-only-installed-packages, if loaded...
if which gcc &>/dev/null;then
  [ ! -f /tmp/ppm-layers-installed-packages ] && cp -f ${REPO_DIR}/woof-installed-packages /tmp/ppm-layers-installed-packages &>/dev/null
  cat ${REPO_DIR}/devx-only-installed-packages >> /tmp/ppm-layers-installed-packages &>/dev/null
  sort -u /tmp/ppm-layers-installed-packages > ${REPO_DIR}/layers-installed-packages &>/dev/null
else
  cp -f ${REPO_DIR}/woof-installed-packages ${REPO_DIR}/layers-installed-packages &>/dev/null
fi

# set $DIRECTSAVEPATH (where we want to install pkgs)
if [ $PUPMODE -eq 3 ] || [ $PUPMODE -eq 7 ] || [ $PUPMODE -eq 13 ];then
  DIRECTSAVEPATH="/initrd${SAVE_LAYER}" #SAVE_LAYER is in /etc/rc.d/PUPSTATE.
elif [ "$PUPMODE" = "2" ]; then
  DIRECTSAVEPATH=""
fi

# get repo details, workdir, search settings and so on.. you could
# you can also add any ENVIRONMENT VARS above to PKGRC, to override the defaults
. ${PKGRC}

# set and create workdir if no valid dir set
[ ! -d "$WORKDIR" ] && mkdir -p "$WORKDIR"
if [ ! -d "$WORKDIR" ];then
  error "Can't create $WORKDIR. Please create it."
  exit 3
fi
WORKDIR=~/pkg

# add to tab completion settings to bashrc and print hint
if [ -z "$PKG_TAB_COMPLETION" ];then
  if [ "$(grep 'export PKG_TAB_COMPLETION=true' ~/.bashrc)" = "" ];then
    # add to bashrc
    { echo ""
      echo "# enable $APPNAME $APPVER TAB completion"
      echo "export PKG_TAB_COMPLETION=true"
      echo "source /etc/bash_completion.d/pkg 2>/dev/null"
    } >> ~/.bashrc
  fi
fi

# make tmp dir writable by everyone if needed
if [ ! -d "$TMPDIR" ];then
  mkdir -p "$TMPDIR" 2>/dev/null
  chmod -R 1777 /tmp/pkg/ 2>/dev/null
fi

# if no tmp dir created or accessible, exit
[ ! -d "$TMPDIR" ] && error "Cannot create temp dir ${lightblue}$TMPDIR${endcolour}" && exit 3

# support aliases, create ALIASES tmp file
PKG_NAME_ALIASES='rxvt-unicode,urxvt,urxvt-unicode
gtk+,gtk+2*
gtkdialog,gtkdialog3
dbus*,libdbus*,libdbus-glib*
mesa,mesa_*,libgl1-mesa*,mesa-common*
sane,sane-backends
samba,samba-tng,samba_*,mountcifs
udev,udev_*,libudev*,libgudev*
xdg_puppy,xdg-utils
perl_tiny,perl-base,perl-modules,perlapi*'
[ ! -f "$TMPDIR/pkg_aliases" ] && echo "$PKG_NAME_ALIASES" > $TMPDIR/pkg_aliases

# get blacklisted packages (each on new line) from $PKG_NAME_IGNORE
# and ~/.pkg/blacklisted_packages .. exports $PKG_BLACKLIST
get_blacklist(){

  PKG_BLACKLIST="$(echo "$PKG_BLACKLIST $PKG_NAME_IGNORE $(cat ${HOME}/.pkg/blacklisted_packages 2>/dev/null)" \
    | tr ' ' '\n' \
    | grep -v ^$ \
    | sort -u)"

  export PKG_BLACKLIST
}

get_blacklist
# create a list like "foo|bar|baz", to be used in grep commands
PKG_BLACKLIST_REGEX="$(echo "$PKG_BLACKLIST" | tr '\n' '|' | sed -e 's/^|//' -e 's/|$//' -e 's#|#|^#g')"
export PKG_BLACKLIST_REGEX

# remove error code flag if we got here
rm -f /tmp/pkg/error130 &>/dev/null

# if not first run, and no options given, print the help
[ ! -f ~/.pkg/firstrun ] && [ "$1" = "" ] && $SELF -H && exit 1 #200913 more help by default

run_plugins(){
  [ -z "$1" ] && return 1

  local hook="$1"
  local hooks='init|pre_install|post_install|pre_uninstall|post_uninstall|pre_build|post_build|exit'

	echo "$hook" | grep -qE "$hooks" || return 1

	if [ ! -d /usr/share/pkg/plugins/$hook/ ];then
		return 1
	fi

  # run any post install plugins for this specific package
  for plugin in /usr/share/pkg/plugins/$hook/*.sh /usr/share/pkg/plugins/$hook/${PKGNAME_ONLY}/*.sh /usr/share/pkg/plugins/$hook/${PKGNAME}/*.sh
  do
    # skip plugin if not a file
    [ -f $plugin ] || continue
    # skip plugin if not enabled
    [ -x $plugin ] || continue
    (
      # source the plugin, to get its 'run' function
      source $plugin || return 1

      # plugin have settings, which define when they should run:
      if [ "${PLUGIN_REQUIRES_ASK:-false}" = true ] && [ "$ASK" != true ];then
        continue
      fi
      if [ "${PLUGIN_REQUIRES_FORCE:-false}" = true ] && [ "$FORCE" != true ];then
        continue
      fi

      local plugin_name="$(echo "$plugin" | sed "s#/usr/share/pkg/plugins/##g")"
      echo -e "${yellow}Plugin: ${plugin_name}${endcolour}: "

      # run the plugin
      ASK=$ASK FORCE=$FORCE run | sed 's/^/  /g'
    )
  done

}

}
#==================  setup script vars  =====================#


{
#====================  main functions  ======================#

set -a

# utility funcs

print_usage(){                    # print usage text. Requires $1, a valid Pkg cmd FUNCLIST

  local examples_file=/usr/share/pkg/docs/examples.txt

  [ -f "$examples_file" ] && source "$examples_file"

  # get and print the usage info from its usage file
  if [ -f /usr/share/pkg/docs/usage/$1 ] && [ "$1" ];then
    source /usr/share/pkg/docs/usage/$1
    echo -e "\n$USAGE"
    # show examples, taken from $EXAMPLES, if they exist
    if [ "$(echo "$EXAMPLES" | grep "$SELF" | grep "\-$1")" != '' ];then
      echo -e "\n${bold}Usage Examples${endcolour}:\n"
      echo -e "$EXAMPLES" | grep "$SELF " | grep "$1 "
    fi
  else
    echo -e "Usage: ${bold}$SELF usage CMD${endcolour}"
    echo
    echo "Commands:"
    echo -e "add-repo       get-only         repo-convert
add-source     help             repo-dep-scope
all-pkgs       help-all         repo-file-list
add            remove           repo-info
ask            install          repo-list
autoclean      install-all      repo-pkg-scope
bleeding-edge  list-deps        repo-update
clean          list-downloaded  search
contents       list-installed   search-all
deb2pet        names            sfs2pet
delete         names-all        sfs-combine
delete-all     names-exact      show-config
deps           names-exact-all  split
deps-all       pet2sfs          tgz2pet
deps-check     pet2tgz          uninstall
deps-download  pet2txz          uninstall-all
dir2pet        build            unpack
dir2sfs        build-list       update-sources
dir2tgz        pkg-combine      version
download       installed        which
examples       repack           which-repo
extract        status           rdep-check
force          update           what-needs
func-list      workdir          rm-repo
txz2pet        dir2repo         merge
whitelist      blacklist        manpage

Usage: ${bold}$SELF usage CMD${endcolour}"
    #cd /usr/share/pkg/docs/usage/; echo `ls` | fold -w 70 -s
  fi
  exit 1
}


func_list(){                      # list all functions available in this script FUNCLIST
  [ -f $TMPDIR/func_list ] && sort $TMPDIR/func_list && exit 0
  # shellcheck disable=SC2016
  grep "(){" $0 | grep '#'    \
    | grep FUNCLIST           \
    | sed -e 's|^| |g'        \
          -e 's|{||g'         \
          -e 's|  | |g'       \
          -e 's|# ||g'        \
          -e 's| FUNCLIST||g' \
    | grep -v 'FUNCLIST $0'   \
    | sort > $TMPDIR/func_list

  cat $TMPDIR/func_list
  exit 0
}


update_system_cache() {
  # $1 = PKGFILES [ex: ${REPO_DIR}/abiword.files]
  PKGFILES="${1}"
  GTKVERLIST="2.0 3.0 4.0"

  for usrfld in /usr /usr/local
  do

    if grep -q -m 1 "$usrfld/share/glib-2.0/schemas" $PKGFILES ; then
  	  if [ -e /usr/bin/glib-compile-schemas ] ; then
    	  /usr/bin/glib-compile-schemas $usrfld/share/glib-2.0/schemas 2>/dev/null
    	fi
    fi

    if grep -q -m 1 "$usrfld/share/applications/" $PKGFILES ; then
  	  if [ -e /usr/bin/update-desktop-database ] ; then
  	   rm -f $usrfld/share/applications/mimeinfo.cache 2>/dev/null
    	 /usr/bin/update-desktop-database $usrfld/share/applications 2>/dev/null
    	fi
    fi

    if grep -q -m 1 "$usrfld/share/mime/" $PKGFILES ; then
  	  if [ -e /usr/bin/update-mime-database ] ; then
  	    /usr/bin/update-mime-database $usrfld/share/mime 2>/dev/null
  	  fi

  	  if [ -e "$usrfld/share/mime/packages" ] && [ "$(ls -1 "$usrfld/share/mime/packages")" = "" ]; then
    	 rm -rf $usrfld/share/mime/*
    	fi
    fi

    if grep -q -m 1 "$usrfld/lib/gio/modules" $PKGFILES ; then
  	  if [ -e /usr/bin/gio-querymodules ] ; then
    	  /usr/bin/gio-querymodules $usrfld/lib/gio/modules 2>/dev/null
    	fi
    fi

    if grep -q -m 1 "$usrfld/share/icons/" $PKGFILES ; then
    	if [ -e /usr/bin/gtk-update-icon-cache ] ; then
    	  find "$usrfld/share/icons/" -name "icon-theme.cache" -type f -exec rm -f '{}' \;
    	  find "$usrfld/share/icons" -maxdepth 1 -name "*" -exec gtk-update-icon-cache -f -i '{}' \; 2>/dev/null
    	fi
    fi

  done

  if grep -q -m 1 '/usr/lib/gconv/' $PKGFILES ;then
    iconvconfig
  fi

  if [ "$(grep -q -m 1 '/usr/lib/gdk-pixbuf' $PKGFILES)" != "" ] || [ "$(grep -q -m 1 '/usr/local/lib/gdk-pixbuf' $PKGFILES)" != "" ]; then
  	if [ -e /usr/bin/update-gdk-pixbuf-loaders ] ; then
  	 update-gdk-pixbuf-loaders
  	elif [ -e /usr/bin/gdk-pixbuf-query-loaders ] ; then
  	 gdk-pixbuf-query-loaders --update-cache
  	fi
  fi

  if [ "$(grep -q -m 1 '/usr/lib/pango/' $PKGFILES)" != "" ] || [ "$(grep -q -m 1 '/usr/local/lib/pango/' $PKGFILES)" != "" ]; then
  	if [ -e /usr/bin/update-pango-querymodules ] ; then
  		update-pango-querymodules
  	elif [ -e /usr/bin/pango-querymodules ] ; then
  		pango-querymodules --update-cache
  	fi
  fi

  if [ "$(grep -q -m 1 '/usr/share/fonts/' $PKGFILES)" != "" ] || [ "$(grep -q -m 1 '/usr/local/share/fonts/' $PKGFILES)" != "" ]; then
    fc-cache -f
  fi

  if grep -q -m 1 "/lib/modules/$(uname -r)/" $PKGFILES ; then
    depmod -a
  fi

  for GTKVER in $GTKVERLIST
  do
    if [ "$(grep -m 1 "/usr/lib/gtk-$GTKVER" $PKGFILES | grep -q "/immodules")" != "" ] || [ "$(grep -m 1 "/usr/local/lib/gtk-$GTKVER" $PKGFILES | grep -q "/immodules")" != "" ]; then
  	if [ -e /usr/bin/update-gtk-immodules-$GTKVER ] ; then
  	  update-gtk-immodules-$GTKVER
  	elif [ -e /usr/bin/gtk-query-immodules-$GTKVER ] ; then
  	  gtk-query-immodules-$GTKVER --update-cache
  	fi
    fi
  done

  if [ "$(grep -q -m 1 '/udev/hwdb.d/' $PKGFILES)" != "" ]; then
    [ "$(udevadm --help 2>&1 | grep hwdb)" != "" ] && udevadm hwdb --update
  fi
}


get_pkg_ext(){                    # return file extension of $1 FUNCLIST

  # get valid usage or exit
  [ ! "$1" ] && echo 'Usage: get_pkg_ext PKGNAME' && exit 1

  local pkg_installed=''
  local pkg_filename=''
  local pkg_ext=''
  local pkg_name=''

  # check given file type, see if it matches our supported pkg types
  case "$1" in
    *.bz2)        echo bz2        ;;
    *.pet)        echo pet        ;;
    *.deb)        echo deb        ;;
    *.pkg.tar.gz) echo pkg.tar.gz ;;
    *.pkg.tar.xz) echo pkg.tar.xz ;;
    *.pkg.tar.zst) echo pkg.tar.zst ;;
    *.pkg.tgz)    echo pkg.tgz    ;;
    *.pkg.txz)    echo pkg.txz    ;;
    *.pkg.zst)    echo pkg.zst    ;;
    *.tar.bz2)    echo tar.bz2    ;;
    *.tar.lzma)   echo tar.lzma   ;;
    *.tar.gz)     echo tar.gz     ;;
    *.tar.xz)     echo tar.xz     ;;
    *.tar.zst)    echo tar.zst    ;;
    *.tbz)        echo tbz        ;;
    *.tgz)        echo tgz        ;;
    *.tlz)        echo tlz        ;;
    *.txz)        echo txz        ;;
    *.tzst)       echo tzst       ;;
    *.gz)         echo gz         ;;
    *.xz)         echo xz         ;;
    *.rpm)        echo rpm        ;;
    *.sfs)        echo sfs        ;;
    #*.tcz)        echo tcz       ;;
    #*.tpkg)       echo tpkg      ;;
    #*.apk)        echo apk       ;;
    *)
      # no extension given, or extension not recognised, so..
      # if it's an installed pkg, get the extension from ${REPO_DIR}/*
      pkg_installed=$(list_installed_pkgs "$1" | grep -m1 "^$1")

      # if $pkg_check not empty, then $1 is an installed pkg
      if [ "$pkg_installed" != '' ];then
        pkg_filename=$(cut -f8 -d'|' ${REPO_DIR}/user-installed-packages |grep -m1 "^$1")
        [ "$pkg_filename"  = '' ] && pkg_filename=$(cut -f8 -d'|' ${REPO_DIR}/*-installed-packages |grep -m1 "^$1")
        [ "$pkg_filename" != '' ] && pkg_ext=$(get_pkg_ext "$pkg_filename")
      else
        # if it's a repo package, get it's extension from ${REPO_DIR}/*
        # shellcheck disable=SC2086
        pkg_filename=$(grep -m1 "^$1" ${REPO_DIR}/Packages-* |cut -f8 -d'|')
       [ "$pkg_filename" != '' ] && pkg_ext=$(get_pkg_ext "$pkg_filename")
      fi
      [ "$pkg_ext" != '' ] && echo $pkg_ext
      ;;
  esac
}


get_pkg_version(){                # returns version of PKGNAME ($1) FUNCLIST

  # exit if no pkg given
  [ ! "$1" ] && exit 1

  local PKGNAME PKGNAME_ONLY PKG_VERSION

  PKGNAME=$(get_pkg_name "$1")
  PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")

  PKG_VERSION="$(grep -m1 "^$PKGNAME|" ${REPO_DIR}/user-installed-packages | cut -f3 -d'|')"
  # cut pkg name only off start (field 3 of user-installed-packges might have full nanes, not versions)
  PKG_VERSION="${PKG_VERSION/${PKGNAME_ONLY}${separator}/}"


  if [ -z "$PKG_VERSION" ];then
    PKG_VERSION="$(grep -m1 "^$PKGNAME|" $REPO_DIR/Packages-* | cut -f3 -d'|')"
  fi

  if [ -z "$PKG_VERSION" ];then
    PKG_VERSION="$(grep -m1 "|$PKGNAME_ONLY|" $REPO_DIR/Packages-* | cut -f3 -d'|')"
  fi

  if [ -z "$PKG_VERSION" ];then
    PKG_VERSION="$(grep -m1 "^$PKGNAME" $REPO_DIR/Packages-* | cut -f3 -d'|')"
  fi

  if [ -z "$PKG_VERSION" ];then
    PKG_VERSION="${PKGNAME/${PKGNAME_ONLY}${separator}/}"
    # shellcheck disable=SC2006
    PKG_VERSION=`echo  "$PKG_VERSION" \
      | sed \
        -e "s/^-//g" \
        -e "s/^_//g" \
        -e "s/^DEV-//g" \
        -e "s/^DOC-//g" \
        -e "s/^NLS-//g" \
        -e "s/^dev-//g" \
        -e "s/^doc-//g" \
        -e "s/^nls-//g" \
        -e "s/+deb.*//g" \
        -e "s/+ubuntu.*//g" \
        -e "s/_amd64.*//g"  \
        -e "s/_arm64.*//g"  \
        -e "s/_armel.*//g"  \
        -e "s/_armhf.*//g"  \
        -e "s/-i[346].*//g" \
        -e "s/-x[86].*//g" \
        -e "s/-pup.*//g" \
        -e "s/-q[0-9].*//g" \
        -e "s/${CP_SUFFIX}.*//g" \
        -e "s/-WITHDEPS.*//g" \
        -e "s/-PLUSDEPS.*//g" \
        -e "s/_all//g" \
        -e 's@\\\@@g'`
  fi

  [ ! -z "$PKG_VERSION" ] && echo "$PKG_VERSION" && return 0
  return 1
}


get_pkg_name_only_from_ext(){     # return package name from $1 (must include file extension)

  # get valid usage or exit
  [ ! "$1" ] && echo 'Usage: get_pkg_name_only_from_ext <PKG_FILENAME>' && exit 1

  # get the extension of the given package name, if any
  local pkg_ext=$(get_pkg_ext "$1")
  # get the name without path and extension
  local pkg_name=$(basename "$1" ".$pkg_ext")
  local PKGNAME=''
  local PKGNAME_ONLY=''
  local DB_pkgrelease=''
  local prPATTERN=''
  local DB_version=''
  local xDB_version=''
  local xPATTERN=''

  #split PKGMAIN, ex: FULLPKGNAME=xvidtune-1.0.1-i486-1.tgz has PKGNAME=xvidtune-1.0.1
  case $pkg_ext in
    deb)
     #deb ex: xsltproc_1.1.24-1ubuntu2_i386.deb  xserver-common_1.5.2-2ubuntu3_all.deb
     PKGNAME_ONLY="$(echo -n "$pkg_name" | cut -f 1 -d '_')"
     DB_pkgrelease="$(echo -n "$pkg_name" | rev | cut -f 2 -d '_' | cut -f 1 -d '-' | rev)"
     prPATTERN="s%\\-${DB_pkgrelease}.*%%"
     PKGNAME="$(echo -n "$pkg_name" | sed -e "$prPATTERN" 2>/dev/null)"
    ;;
    pet)
     PKGNAME="$pkg_name"
     DB_version="$(echo -n "$PKGNAME" | grep -o '\\-[0-9].*' | sed -e 's%^\-%%')"
     xDB_version="$(echo -n "$DB_version" | sed -e 's%\\-%\\\\-%g' -e 's%\\.%\\\\.%g')"
     xPATTERN="s%${xDB_version}%%"
     PKGNAME_ONLY="$(echo -n "$PKGNAME" | sed -e "$xPATTERN" -e 's%\\-$%%' 2>/dev/null)"
    ;;
    tgz|txz)
     #slack ex: xvidtune-1.0.1-i486-1.tgz  printproto-1.0.4-noarch-1.tgz
     PKGNAME="$(echo -n "$pkg_name" | sed -e 's%\\-i[3456]86.*%%' -e 's%\\-noarch.*%%')"
     DB_version="$(echo -n "$PKGNAME" | grep -o '\\-[0-9].*' | sed -e 's%^\\-%%')"
     xDB_version="$(echo -n "$DB_version" | sed -e 's%\\-%\\\\-%g' -e 's%\\.%\\\\.%g')"
     xPATTERN="s%${xDB_version}%%"
     PKGNAME_ONLY="$(echo -n "$PKGNAME" | sed -e "$xPATTERN" -e 's%\-$%%' 2>/dev/null)"
    ;;
    tar.gz)
     #arch ex: xproto-7.0.14-1-i686.pkg.tar.gz  trapproto-3.4.3-1.pkg.tar.gz
     PKGNAME="$(echo -n "$pkg_name" | sed -e 's%\\-i[3456]86.*%%' -e 's%\\.pkg$%%' | rev | cut -f 2-9 -d '-' | rev)"
     DB_version="$(echo -n "$PKGNAME" | grep -o '\\-[0-9].*' | sed -e 's%^\\-%%')"
     xDB_version="$(echo -n "$DB_version" | sed -e 's%\\-%\\\\-%g' -e 's%\\.%\\\\.%g')"
     xPATTERN="s%${xDB_version}%%"
     PKGNAME_ONLY="$(echo -n "$PKGNAME" | sed -e "$xPATTERN" -e 's%\\-$%%' 2>/dev/null)"
    ;;
    rpm) #110523
     #exs: hunspell-fr-3.4-1.1.el6.noarch.rpm
     PKGNAME="$pkg_name"
     DB_version="$(echo -n "$PKGNAME" | grep -o '\\-[0-9].*' | sed -e 's%^\-%%')"
     xDB_version="$(echo -n "$DB_version" | sed -e 's%\\-%\\\\-%g' -e 's%\\.%\\\\.%g')"
     xPATTERN="s%${xDB_version}%%"
     PKGNAME_ONLY="$(echo -n "$PKGNAME" | sed -e "$xPATTERN" -e 's%\\-$%%' 2>/dev/null)"
    ;;
  esac

  PKGNAME_ONLY="$(strip_package_filename $PKGNAME_ONLY)"

  # remove the +20080738 from packages with dates in the version
  PKGNAME_ONLY="$(echo "$PKGNAME_ONLY" | sed -e 's/+19.*//g' -e 's/+20.*//g')"

  [ "$PKGNAME_ONLY" != '' ] && echo "$PKGNAME_ONLY" || echo "$1"
}


get_pkg_name_only(){              # return pkg name only from $1, with no version or suffix FUNCLIST

  # exit if no valid options
  [ ! "$1" ] && exit 1

  # get config settings, inc current repo file
  #. ${PKGRC}

  local pkg_name=''
  local pkg_name_only=''
  local name_only=''
  local pkg_ext=$(get_pkg_ext "$1")
  local repo_of_pkg=''
  local repo_ext="$EX"      # from $PKGRC
  # check the repos
  local pkg_name_only="$(grep -m1 "|${1}|" ${REPO_DIR}/Packages-* 2>/dev/null | cut -f2 -d'|')"
  [ "$pkg_name_only" = '' ] && pkg_name_only="$(grep -m1 "^${1}|" ${REPO_DIR}/Packages-* 2>/dev/null | cut -f2 -d'|' | head -1)"
  [ "$pkg_name_only" = '' ] && pkg_name_only="$(grep -m1 "|${1}|" ${REPO_DIR}/Packages-* 2>/dev/null | cut -f2 -d'|' | head -1)"
  [ "$pkg_name_only" = '' ] && pkg_name_only="$(grep -m1 "|${1}.${pkg_ext:-$EX}|" ${REPO_DIR}/Packages-* 2>/dev/null | cut -f2 -d'|' | head -1)"

  pkg_name_only="${pkg_name_only// */}"

  # if we found it, print it and exit
  if [ "$pkg_name_only" != '' ];then
      echo "${pkg_name_only}"
      return 0
  fi

  # if not, but we have an extension, try  get_pkg_name_only_from_ext()
  if [ ! -z "$pkg_ext" ] || [ ! -z "$EX" ];then
    case $DISTRO_BINARY_COMPAT in
      ubuntu|trisquel|debian|devuan)
        name_only=$(get_pkg_name_only_from_ext "$(basename "${1}.${pkg_ext:-$EX}")"| head -1)

        name_only="${name_only// */}"
        name_only="$(strip_package_filename $name_only)"

        [ "$name_only" != '' ] && [ "$name_only" != "$1" ] && echo "$name_only" && return 0
        ;;
    esac
  fi

  ## ...if we didn't find the name using the above, do the horrible checks below

  # replace the dash before the version number with an @ symbol.
  # INFO: sed /-[^-][^+][^a-zA-Z][0-9.]*/ (hopefully?) replaces '-$VER' with '@'
  # not including when $VER starts with a number/letter
  pkg_name_only="$(basename "${1/-[^-][^+][^a-zA-Z][0-9.]*/@}")"

  # do 'ioquake3+u20130504' => 'oquake3'
  pkg_name_only="${pkg_name_only/+[Aa-Zz]/@}"

  # note, we haven't cut away version numbers preceeded with underscores (_) yet

  # if the version number was preceeded by an underscore, the version
  # will still be in the $pkg_name_only - pkgname_2.3.4 - so cut it out
  if [ "$(echo "$pkg_name_only" | grep -o "_[0-9]\.")" != '' ];then
    pkg_name_only="${pkg_name_only/_[^a-z][^A-Z][0-9.]*/@}"

  # maybe the underscore preceeds a version that starts with a letter
  elif [ "$(echo "$pkg_name_only" | grep -o "_[a-zA-Z][0-9]\.")" != '' ];then
    pkg_name_only="${pkg_name_only/_[a-zA-Z][0-9.]*/@}"
  fi

  # now cut away everything after the @, that will leave only the package name
  pkg_name_only1="${pkg_name_only/@*/}"
  pkg_name_only="$pkg_name_only1"

  # we might still have foo_bar_v1.2.3, so lets chop off * after the last _
  if [ "$(echo "$pkg_name_only" | grep -o "_[a-zA-Z][0-9]\.")" != '' ];then
    pkg_name_only="${pkg_name_only/_[a-zA-Z][0-9]*/}"
  fi

  # another chop, we might have foo_bar_vv1.2.3, so lets chop off
  # everything after the last underscore, if we still have version numbers
  if [ "$(echo "$pkg_name_only" | grep -o "_[a-zA-Z][a-zA-Z][0-9]\.")" != '' ];then
    pkg_name_only="${pkg_name_only/_[a-zA-Z][a-zA-Z][0-9]*/}"
  fi

  # we might still have foo_bar_vvv1.2.3, so lets chop off
  # everything after the last underscore, if we still have version numbers
  if [ "$(echo "$pkg_name_only" | grep -o "_[a-zA-Z*][0-9]\.")" != '' ];then
    pkg_name_only="${pkg_name_only/_[a-zA-Z*][0-9]*/}"
  fi

  # chop again, we might have abc_xwy-zzz1.2.3-blah-etc, so lets chop off
  # everything after the last dash-before-number
  if [ "$(echo "$pkg_name_only" | grep -o "\-[a-zA-Z*]*[0-9]\.")" != '' ];then
    pkg_name_only="${pkg_name_only/-[a-zA-Z*]*[0-9]*/}"
  fi

  # another fix, if we still have PKGNAME-1.2, remove the '-1.2'
  if [ "$(echo "$pkg_name_only" | grep -o "\-[0-9]")" != '' ];then
    pkg_name_only="${pkg_name_only/-[0-9]*/}"
  fi

  # remove the +20080738 from packages with dates in the version
  pkg_name_only="$(echo "$pkg_name_only" | sed -e 's/\+19.*//g' -e 's/\+20.*//g')"

  pkg_name_only_stripped="$(strip_package_filename $pkg_name_only)"
  pkg_name_only="${pkg_name_only_stripped:-$pkg_name_only}"

  # the sed bit changes 'liblzma5+20120614' to 'liblzma5'
  # shellcheck disable=SC2001
  [ "$pkg_name_only" != '' ] && echo "${pkg_name_only:-$1}" | sed -e 's/\+[a-z0-9].*//g' || return 1
}


get_pkg_name(){                   # return full pkg name (with version) from $1 FUNCLIST

  # get config settings, inc current repo file
  . ${PKGRC}

  local pkg_ext=''
  local pkg_name=''
  local full_name=''
  local supported_repo_files=''

  # get the extension of the given package name, if any
  local pkg_ext=$(get_pkg_ext "$1")
  # get the name without path and extension
  local pkg_name="$(basename "$1" .${pkg_ext:-$EX})"

  # get the repos files in the correct (fall back) order, then add file paths
  supported_repo_files="$(repo_file_list | sed -e "s#^#${REPO_DIR}/#g")"

  # get the relevant repo contents (fields 1,2,8) from all repos,
  # then add pipes to line start/end for easier parsing later, then do
  # a basic search, for $pkg* (we'll refine it later), to avoid 'Argument list too long'..
  if [ ! -f ${TMPDIR}/repo_contents ];then
    cut -f1,2,8 $supported_repo_files ${REPO_DIR}/woof-installed-packages \
      | sed \
        -e "s/^/|/g" \
        -e "s/$/|/g" 2>/dev/null \
      | grep -i "|$pkg_name" > ${TMPDIR}/repo_contents
  fi

  # get fields 1,2 and 8 (the 3 name fields) from all supported repo files, then
  # add '|' to start and end of lines, then find exact match of $pkg_name..
  # if no exact match, look for $pkg_name-*, then $pkg_name_*
  if [ -f ${TMPDIR}/repo_contents ];then

    full_name=$(grep -m1 "|${pkg_name}|"           "${TMPDIR}/repo_contents" 2>/dev/null) \
      || full_name=$(grep -m1 "|${pkg_name//-*/}|" "${TMPDIR}/repo_contents" 2>/dev/null) \
      || full_name=$(grep -m1 "|${pkg_name//_*/}|" "${TMPDIR}/repo_contents" 2>/dev/null) \
      || full_name=$(grep -m1 "|${pkg_name}-"      "${TMPDIR}/repo_contents" 2>/dev/null) \
      || full_name=$(grep -m1 "|${pkg_name}_"      "${TMPDIR}/repo_contents" 2>/dev/null) \
      || full_name=$(grep -m1 "|${pkg_name}"       "${TMPDIR}/repo_contents" 2>/dev/null) \
      || full_name=$(grep -m1 "^${pkg_name}|"      "${TMPDIR}/repo_contents" 2>/dev/null) \
      || full_name=$(grep -m1 "^${pkg_name}-"      "${TMPDIR}/repo_contents" 2>/dev/null) \
      || full_name=$(grep -m1 "^${pkg_name}_"      "${TMPDIR}/repo_contents" 2>/dev/null)
  fi

  rm ${TMPDIR}/repo_contents &>/dev/null
  # if we found pkg in repo, keep only the package name ('|pkg-123|pkg|blah|' -> 'pkg-123')
  if [ "$full_name" != '' ];then
    full_name=$(echo $full_name | cut -f2 -d '|' | tr -d '|')
  else
    full_name="$pkg_name"
  fi

  # if we have a package name, return it here and leave the func
  [ "$full_name" != '' ] && echo $full_name && return 0

  # if dealing with local files, .deb packages have the arch appended at
  # the end, before the extension, so we'll need to remove that (if there)
  pkg_name="$(strip_package_filename $pkg_name)"

  # if no pkg found in repos, we cant translate/lookup its longer name,
  # so just return what we got, without path, without pkg extension
  [ "$full_name" = '' ] && basename "$pkg_name" .${pkg_ext:-${EX:-noextension}}
}


get_pkg_filename(){              # return filename of $1, if its a local file or repo package FUNCLIST
  # exit if no valid options
  [ ! "$1" ] || [ "$1" = "-" ] && exit 1

  if [ -f "$1" ];then
    basename "$1"
    return 0
  fi

  # strip away extension and path
  local PKGNAME="$(basename "$1" .$EX)"
  local PKGNAME=$(get_pkg_name "$PKGNAME")
  local PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")

  # check repos in fallback order
  all_supported_repofiles=$(repo_file_list | sed "s#^#${REPO_DIR}/#" | tr '\n' ' ')

  local pkgname

  for repofile in ${REPO_DIR}/${REPOFILE} $REPO_DIR/*-installed-packages $all_supported_repofiles
  do
    pkgname="$(grep -m1 "^$PKGNAME|" "$repofile" | cut -f8 -d'|')"
    [ ! -z "$pkgname" ] && break
  done

  if [ -z "$pkgname" ];then
    for repofile in ${REPO_DIR}/${REPOFILE} $REPO_DIR/*-installed-packages $all_supported_repofiles
    do
      pkgname="$(grep -m1 "|$PKGNAME_ONLY|" "$repofile" | cut -f8 -d'|')"
      [ ! -z "$pkgname" ] && break
    done
  fi

  [ ! -z "$pkgname" ] && echo "$pkgname" | grep -v ^$ | head -1
}

strip_package_filename() {
  [ -z "$1" ] && return 1
  local p="${1//_all/}"
  p="${p//.pet/}"
  p="${p//.${EX:-noextension}/}"
  p="${p//.${pkg_ext:-noextension}/}"
  p="${p//_amd64/}"
  p="${p//_arm64/}"
  p="${p//_armel/}"
  p="${p//_armhf/}"
  p="${p//_i[3-6]86/}"
  p="${p//_x64/}"
  p="${p//_x84_64/}"
  p="${p//~dfsg-[0-9]/}"
  p="${p//~dsfg-[0-9]/}"
  p="${p//~[a-z]*[0-9]/}"
  echo "$pkgdir"
}

get_pkg_category(){
  # $1 must be PKGNAME_ONLY ('gimp', 'vlc', etc)
  [ -z "$1" ] && return 1

  local category=''
  category="$(grep -i -m1 " ${1} " /usr/local/petget/categories.dat \
    | cut -f1 -d'='  \
    | cut -f2- -d'_' \
    | tr '_' ';')"

  # do this in a sub shell
  (
    \cd $REPO_DIR/ &>/dev/null || exit 1

    if [ -z "$category" ];then
      # search the repo files
      category="$(cut -f1,2,5 -d'|' $(repo_file_list) \
        | grep -i -m1 "^${1}.*|${1}|" \
        | cut -f3 -d'|')"
    fi
    [ ! -z "$category" ] && echo "$category" | grep -v ^$
  )
}

is_blacklisted_pkg(){             # return true if PKGNAME ($1) is blacklisted FUNCLIST
  # exit if no valid options
  [ ! "$1" ] || [ "$1" = "-" ] && exit 1

  # if we find an exact match of PKGNAME_ONLY in $PKG_BLACKLIST
  if [ "$(echo "$PKG_BLACKLIST" | grep -E "^$(get_pkg_name_only "$1")\$")" != '' ];then
    echo true
    return 0
  fi
  echo false
  return 1
}


is_installed_pkg(){               # return true if PKGNAME ($1) is installed, else false FUNCLIST

  # exit if no valid options
  [ ! "$1" ] || [ "$1" = "-" ] && print_usage pkg-installed && exit 1

  local EX=''
  local PKGNAME=''
  local PKGNAME_ONLY=''
  local PKGFILENAME=''
  local PKGFILENAME_NO_EX=''
  local check=''
  local repo_files="${REPO_DIR}/woof-installed-packages ${REPO_DIR}/user-installed-packages"

  # get pkg extension
  EX=$(get_pkg_ext "$1")

  # strip away extension and path
  PKGNAME="$(basename "$1" .$EX)"
  PKGNAME=$(get_pkg_name "$PKGNAME")

  # we cant rely on the strings the user passes us, so...
  [ -z "$check" ] && check="$(find ${REPO_DIR}/ -name "${PKGNAME}.files")"

  PKGFILENAME="$(get_pkg_filename ${PKGNAME})"
  PKGFILENAME_NO_EX="${PKGFILENAME//.$EX/}"
  [ -z "$check" ] && check="$(find ${REPO_DIR}/ -name "${PKGFILENAME_NO_EX}.files" -print -quit)"
  [ -z "$check" ] && check="$(cut -f1,2 -d'|' $repo_files | grep -m1 "^$PKGNAME|")"
  [ -z "$check" ] && check="$(cut -f8   -d'|' $repo_files | grep -m1 "^${PKGNAME}.$EX")"
  [ -z "$check" ] && check="$(cut -f8   -d'|' $repo_files | grep -m1 "^${PKGFILENAME}.deb)")"

  PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")
  [ -z "$check" ] && check="$(cut -f1,2 -d'|' $repo_files | grep -m1 "^$PKGNAME" | grep -m1 "|$PKGNAME_ONLY\$")"

  # if any checks above returned a result, $check will not be empty (ash didn't like grep -q, not sure why?)
  [ ! -z "$check" ] && echo true || echo false
}


is_builtin_pkg (){                # return true if $1 is a builtin pkg, else false FUNCLIST

  # if $1 is an exact match of a pkg short name,
  # long name or file name in woof-installed-packages,
  # we will return true, else we return false

  # exit if no valid input
  [ ! "$1"  ] && exit 1

  local pkg_builtin=''
  local pkg_name_only=''

  pkg_builtin="$(cut -f1,2,8 -d '|' ${REPO_DIR}/woof-installed-packages 2>/dev/null \
    | sed -e 's@^@|@' -e 's@$@|@' \
    | grep -m1 "|$1|")"

  # try again.. if user gave only partial name (geany-1.27), the above would fail
  if [ "$pkg_builtin" = '' ];then
    pkg_name_only=$(get_pkg_name_only "$1")

    # so search for pkg_name* AND pkg_name_only (exact match, should be in field 2)
    if [ "$pkg_name_only" != '' ];then
      pkg_builtin="$(cut -f1,2,8 -d '|' ${REPO_DIR}/woof-installed-packages 2>/dev/null \
        | sed -e 's@^@|@' -e 's@$@|@' \
        | grep "|$1" \
        | grep -m1 "|$pkg_name_only|")"
    fi
  fi

  # print result
  [ "$pkg_builtin" != '' ] && echo true || echo false
}


is_devx_pkg (){                   # return true if $1 is a pkg in the devx, else false FUNCLIST

  # if $1 is an exact match of a pkg short name,
  # long name or file name in devx-only-installed-packages,
  # we will return true, else we return false

  # exit if no valid input
  [ ! "$1"  ] && exit 1

  local devx_pkg=''
  local pkg_name_only=''

  devx_pkg="$(cut -f1,2,8 -d '|' ${REPO_DIR}/devx-only-installed-packages 2>/dev/null\
    | sed -e 's@^@|@' -e 's@$@|@' \
    | grep -m1 "|$1|")"

  # try again.. if user gave only partial name (geany-1.27), the above would fail
  if [ "$devx_pkg" = '' ];then
    pkg_name_only=$(get_pkg_name_only "$1")

    # so search for pkg_name* AND |pkg_name_only| (exact match, should be in field 2)
    if [ "$pkg_name_only" != '' ];then
      devx_pkg="$(cut -f1,2,8 -d '|' ${REPO_DIR}/devx-only-installed-packages 2>/dev/null\
        | sed -e 's@^@|@' -e 's@$@|@' \
        | grep "|$1" \
        | grep -m1 "|$pkg_name_only|")"
    fi
  fi

  # print result
  [ "$devx_pkg" != '' ] && echo true || echo false
}


is_usr_pkg (){                    # return true if $1 is a user installed pkg, else false FUNCLIST

  # if $1 is an exact match of a pkg short name,
  # long name or file name in user-installed-packages,
  # we will return true, else we return false

  # exit if no valid input
  [ ! "$1"  ] && exit 1

  local usr_pkg=''
  local pkg_name_only=''

  usr_pkg="$(cut -f1,2,8 -d '|' ${REPO_DIR}/user-installed-packages 2>/dev/null \
    | sed -e 's@^@|@' -e 's@$@|@' \
    | grep -m1 "|$1|")"

  # try again.. if user gave only partial name (geany-1.27), the above would fail
  if [ "$usr_pkg" = '' ];then
    pkg_name_only=$(get_pkg_name_only "$1")

    # so search for pkg_name* AND |pkg_name_only| (exact match, should be in field 2)
    if [ "$pkg_name_only" != '' ];then
      usr_pkg="$(cut -f1,2,8 -d '|' ${REPO_DIR}/user-installed-packages 2>/dev/null \
        | sed -e 's@^@|@' -e 's@$@|@' \
        | grep "|$1" \
        | grep -m1 "|$pkg_name_only|")"
    fi
  fi

  # print result
  [ "$usr_pkg" != '' ] && echo true || echo false
}


is_repo_pkg (){                   # return true if $1 is a pkg in a supported repo, else false FUNCLIST

  # if $1 is an exact match of a pkg short name,
  # long name or file name in Packages-*-
  # we will return true, else we return false

  # exit if no valid input
  [ ! "$1"  ] && exit 1

  local repo_pkg=''
  local pkg_name_only=''
  local all_supported_repofiles

  # all repo files, full paths
  all_supported_repofiles=$(repo_file_list | sed "s#^#${REPO_DIR}/#" | tr '\n' ' ')

  # search all repo files for the $1
  repo_pkg="$(cut -f1,2,8 -d '|' $all_supported_repofiles 2>/dev/null\
    | sed -e 's/ //g' -e 's@^@|@' -e 's@$@|@' \
    | grep -m1 "|${1}|")"

  # search all repo files for the $1*
  [ "$repo_pkg" = '' ] \
    && repo_pkg="$(cut -f1,2,8 -d '|' $all_supported_repofiles 2>/dev/null\
    | sed -e 's/ //g' -e 's@^@|@' -e 's@$@|@' \
    | grep -m1 "|${1}-\?_\?[0-9.a-zA-Z]*|")"

  # try again.. if user gave only partial name (geany-1.27), the above would fail
  if [ "$repo_pkg" = '' ];then
    pkg_name_only=$(get_pkg_name_only "$1")

    # so search for pkg_name* AND |pkg_name_only| (exact match, should be in field 2)
    if [ "$pkg_name_only" != '' ];then
      repo_pkg="$(cut -f1,2,8 -d '|' $all_supported_repofiles 2>/dev/null\
        | sed -e 's@^@|@' -e 's@$@|@' \
        | grep "|$1" \
        | grep -m1 "|$pkg_name_only|")"
    fi
  fi

  # print result
  [ "$repo_pkg" != '' ] && echo true || echo false
}


is_current_repo_pkg(){            # takes $PKGNAME ($1), returns true or false FUNCLIST

  # exit if no valid input
  [ ! "$1"  ] && exit 1

  # get current repo ($REPOFILE)
  . "${PKGRC}"

  local pkg_in_repo

  # check if given pkg ($1) is in the current repo
  pkg_in_repo="$(LANG=C cut -f1,2,7,8 -d'|' ${REPO_DIR}/$REPOFILE 2>/dev/null \
    | sed -e "s/^/|/" \
          -e "s/$/|/" \
    | grep -m1 "|$1|")"

  # print msg
  [ "$pkg_in_repo" != '' ] && echo true || echo false
}


is_local_pkg(){                   # returns true if $1 is local package file FUNCLIST

  # exit if no valid input
  [ ! "$1"  ] && exit 1

  . "${PKGRC}"

  # if $1 is a local file with a supported package extension
  # then we return true, else, we return false
  local is_local_pkg=false

  # first, check we have a local file
  if [ -f "$1" ];then

    # file *probably* has an extension, lets try to get it..
    # the func get_pkg_ext() will return empty if not a valid package extension
    file_ext=$(get_pkg_ext "$1")

    # if not empty, it must be a local file, with valid pkg ext (a local pkg)
    [ "$file_ext" != '' ] && is_local_pkg=true

  elif [ -f "$CURDIR/$1" ];then

    file_ext=$(get_pkg_ext "$CURDIR/$1")
    [ "$file_ext" != '' ] && is_local_pkg=true

  elif [ -f "$WORKDIR/$1" ];then

    file_ext=$(get_pkg_ext "$CURDIR/$1")
    [ "$file_ext" != '' ] && is_local_pkg=true

  fi

  # print output
  echo $is_local_pkg
}


# RC file funcs

set_workdir(){                    # set new WORKDIR in rc file location FUNCLIST

  # get latest rc file values
  . ${PKGRC}

  # make sure $1 was given and doesn't already exist
  [ ! "$1"  ] && print_usage workdir && exit 1
  [ -e "$1" ] && echo "Error: directory already exists. Choose a new one." && exit 1

  # create the dir
  mkdir -p "$1" 2>/dev/null

  # if dir not created, exit with error
  [ $? -eq 1  ] && echo "Error: Could not create $1" && exit 1
  [ ! -d "$1" ] && echo "Error: Could not create directory:  $1" && exit 1

  # dir was created, so lets copy our pkgs in there
  list_downloaded_pkgs | while read pkg_file
  do
    cp -v "$WORKDIR/$pkg_file" "$1/"
  done

  # if copying everything to new dir failed
  if [ $? -eq 1 ];then
    # print msg
    echo -e "${yellow}Warning:${endcolour}Could not copy packages from $WORKDIR to $1.."
    echo "You should copy all packages in $WORKDIR into $1."
  fi

  # update the RC file
  WORKDIR="$1"
  set_config
  echo "Success. Work directory updated."
  exit 0
}


set_pkg_scope(){                  # one|all set search for pkgs in current repo or all FUNCLIST

  # get old values, any we dont set here are not overwritten
  . "${PKGRC}"

  [ "$1" != "" ] && PKGSCOPE="$1" || PKGSCOPE="$PKGSCOPE"

  case "$1" in
    all)
    # set pkg search to all
    PKGSEARCH="list_all_pkg_names"
    PKGSEARCHEXACT="$SELF -nea"
    echo -e "${green}Success:${endcolour} Find packages in all repos."
    ;;
    one)
    # set pkg search to current only
    PKGSEARCH="list_pkg_names"
    PKGSEARCHEXACT="$SELF -ne"
    echo -e "${green}Success:${endcolour} Find packages in current repo ($REPONAME) only."
    ;;
    *)
    PKGSCOPE="one"
    # set pkg search to current only
    PKGSEARCH="list_pkg_names"
    PKGSEARCHEXACT="$SELF -ne"
    echo "Find packages in current repo ($REPONAME) only."
    ;;
  esac

  set_config #170213
}


set_dep_scope(){                  # all|one set search for deps in current repo or all FUNCLIST

   # get RC file values, so any we dont set here are not overwritten
   . ${PKGRC}

  # make sure we have a valid value
  [ "$1" != "" ] && DEPSCOPE="$1" || DEPSCOPE="$DEPSCOPE"

  case "$1" in
    all)
    # set pkg search to all
    DEPSEARCH="list_all_pkg_names"
    DEPSEARCHEXACT="$SELF -nea"
    echo -e "${green}Success:${endcolour} Find dependencies in all repos."
    ;;
    one)
    # set pkg search to one
    DEPSEARCH="list_pkg_names"
    DEPSEARCHEXACT="$SELF -ne"
    echo -e "${green}Success:${endcolour} Find dependencies in current repo ($REPONAME) only."
    ;;
  esac

  set_config
}


set_recursive_deps(){             # yes|no search for deps of deps or not FUNCLIST
  [ "$(echo $1 | grep -E "^yes\$|^no\$")" = "" ] && print_usage recursive-dep-check && exit 1

  # get old values, any we dont set here are not overwritten
  . "${PKGRC}"

  # make sure we have a valid value
  RDCHECK="$1"
  if [ "$RDCHECK" != "yes" ] && [ "$RDCHECK" != "no" ]
  then
    RDCHECK=no
  fi

  set_config

  # print final msg
  if [ "$1" = "yes" ];then
    echo -e "${green}Success:${endcolour} 'Recursive dependency checking' enabled."
  else
    echo -e "${green}Success:${endcolour} 'Recursive dependency checking' disabled"
  fi
}


set_bleeding_edge(){              # yes|no get latest pkgs, ignore fall backs FUNCLIST
  [ "$(echo $1 | grep -E "^yes\$|^no\$")" = "" ] && echo usage bleeding-edge && exit 1

  #get old values, any we dont set here are not overwritten
  . "${PKGRC}"

  # make sure we have a valid value
  BLEDGE="$1"
  if [ "$BLEDGE" != "yes" ] && [ "$BLEDGE" != "no" ]
  then
    BLEDGE=no
  fi

  set_config

  # print final msg
  if [ "$1" = "yes" ];then
    echo -e "${green}Success:${endcolour} 'Bleeding edge' package search enabled."
  else
    echo -e "${green}Success:${endcolour} 'Bleeding edge' package search disabled."
  fi
}


set_autoclean(){                  # yes|no auto delete installed packages from WORKDIR FUNCLIST
  [ "$(echo $1 | grep -E "^yes\$|^no\$")" = "" ] && print_usage autoclean && exit 1

  #get old values, any we dont set here are not overwritten
  . ${PKGRC}

  # make sure we have a valid value
  AUTOCLEAN="$1"
  if [ "$AUTOCLEAN" != "yes" ] && [ "$AUTOCLEAN" != "no" ]
  then
    AUTOCLEAN=no
  fi

  set_config

  # print final msg
  if [ "$1" = "yes" ];then
    echo -e "${green}Success:${endcolour} Auto-remove installed packages ENABLED."
  else
    echo -e "${green}Success:${endcolour} Auto-remove installed packages DISABLED."
  fi
}


set_config(){                     # update all options in config file FUNCLIST
  (
  echo "WORKDIR=$WORKDIR"
  echo "REPONAME=$REPONAME"
  echo "EX=$EX"
  echo "REPOFILE=$REPOFILE"
  echo "REPOURL1=$REPOURL1"
  echo "REPOURL2=$REPOURL2"
  #140213 add all urls
  echo "REPOURL3=$REPOURL3"
  echo "REPOURL4=$REPOURL4"
  # seach settings
  echo "PKGSEARCH=\"$PKGSEARCH\""
  echo "PKGSEARCHEXACT=\"$PKGSEARCHEXACT\""
  echo "DEPSEARCH=\"$DEPSEARCH\""
  echo "DEPSEARCHEXACT=\"$DEPSEARCHEXACT\""
  # multiple repo settings
  echo "REPOFALLBACKS=\"$REPOFALLBACKS\""
  echo "PKGSCOPE=\"$PKGSCOPE\""
  echo "DEPSCOPE=\"$DEPSCOPE\""
  echo "BLEDGE=\"$BLEDGE\""
  echo "RDCHECK=\"$RDCHECK\""
  echo "AUTOCLEAN=\"$AUTOCLEAN\""
  echo "BUILDTOOL=$BUILDTOOL"
  ) > ${PKGRC}
}


show_config(){                    # show config settings from ~/.pkg/pkgrc FUNCLIST
  . "${PKGRC}"

  # set default values
  PKGSCOPETXT="Search for packages in all repos."
  DEPSCOPETXT="Search for dependencies in all repos."
  FALLBACKTXT="Accessing other repos in this order:"
  FALLBACKTXT="$FALLBACKTXT\n$(repo_list | grep -v "^$REPONAME" | tr '\n' ' ' | sed -e "s/ /, /g" -e "s/, $//" | fold -w 54 -s)"
  RDCHECKTXT="Recursive dependency search is NOT enabled."

  # update with values from PKGRC file
  [ "$PKGSCOPE" = "one" ] && PKGSCOPETXT="Search for packages in current repo only."
  [ "$DEPSCOPE" = "one" ] && DEPSCOPETXT="Search for dependencies in current repo only."
  [ "$BLEDGE"   = "yes" ] && FALLBACKTXT="Bleeding-edge enabled - searching all repos, for the latest packages versions.."
  [ "$RDCHECK"  = "yes" ] && RDCHECKTXT="Recursive dependency search is enabled."

  # print current Pkg config
  echo "==========================="
  echo "$APPNAME $APPVER"
  echo "==========================="
  echo "Config file:  $PKGRC"
  echo "Packages dir: ${WORKDIR}/"
  echo "Autoclean:    $AUTOCLEAN"
  echo
  echo "Search settings:"
  #echo "- $HIDEINSTALLEDTXT"
  echo "- $PKGSCOPETXT"
  echo "- $DEPSCOPETXT"
  echo "- $RDCHECKTXT"
  echo
  echo "Package Compiling backend:"
  echo "- $BUILDTOOL"
  echo
  echo "Repo details:"
  echo "- Current Repo: $REPONAME"
  echo "- Package type: $EX"
  # shellcheck disable=SC2002
  echo "- Packages:    $(cat ${REPO_DIR}/${REPOFILE} | wc -l)"
  echo "- Mirror 1:     $(echo "$REPOURL1" | cut -f1-3 -d'/')"
  [ "$REPOURL2" != "" ] && echo "- Mirror 2:     $(echo "$REPOURL2" | cut -f1-3 -d'/' )"
  [ "$REPOURL3" != "" ] && echo "- Mirror 3:     $(echo "$REPOURL3" | cut -f1-3 -d'/' )"
  [ "$REPOURL4" != "" ] && echo "- Mirror 4:     $(echo "$REPOURL4" | cut -f1-3 -d'/' )"
  echo
  echo -e "$FALLBACKTXT"
}


# repo and source funcs

get_repo_info(){                  # return details of given repo name ($1) FUNCLIST
  if [ ! "$1" ] || [ "$1" = "-" ];then
    print_usage repo-info
    exit 1
  fi

  REPOLINE="$(list_all_sources "$1" | sort -u)" #170214 always get latest info, not info from rcfile

  # on first run, this might be needed to set the repo correctly
  [ "$REPOLINE" = '' ] && REPOLINE="$(list_all_sources noarch)"
  #               1      2     3       4        5       6         7          8
  IFS="|" read REPONAME EX REPOFILE REPOURL1 REPOURL2 REPOURL3 REPOURL4 REPOFALLBACKS \
	ETC <<EOF
$REPOLINE
EOF
}


set_current_repo(){               # set the current repo to use, give repo name as $1 FUNCLIST

  # print usage if no valid options
  [ ! "$1" ] || [ "$1" = "-" ] || [ "$1" = "-h" ] || [ "$1" = "--help" ] && print_usage repo && exit 1

  # get repo details from rc file
  . "${PKGRC}"

  # remove the default mirror tmp file, we're changing repo and mirrors
  rm $TMPDIR/CURREPOURL 2>/dev/null

  # remove old repo files list (used in list_source_files)
  rm -f ${TMPDIR}/source_files 2>/dev/null

  # if not updating the scopes or bleeding-edge,leave them as set in rcfile
  [ "$PKGSCOPE" = "" ] && PKGSCOPE="$PKGSCOPE"
  [ "$DEPSCOPE" = "" ] && DEPSCOPE="$DEPSCOPE"
  [ "$BLEDGE" = "" ]   && BLEDGE="$BLEDGE"

  # if nothing was found in rcfile, we need to set to default
  [ "$(echo $PKGSCOPE | grep -E "^one\$|^all\$")" = "" ] && PKGSCOPE="one"
  [ "$(echo $DEPSCOPE | grep -E "^one\$|^all\$")" = "" ] && DEPSCOPE="one"
  [ "$BLEDGE" = "" ] && BLEDGE="no"

  # check if $1 is valid repo
  if [ "$(LANG=C list_sources "$1")" != "" ];then
    # set repo details
    LANG=C get_repo_info "$1"
    LANG=C set_config #170213
    LANG=C update_sources 1>/dev/null #update the order of sources to match new fallback list of new current repo
    LANG=C print_repo_info "$1" #output msg, repo info
  else
    # not a valid repo, print message
    echo "The name '$1' is not a valid repo name. These are:"
    LANG=C repo_list #250613
  fi
}


repo_list(){                      # list names of all avail repos [optionally matching $1] FUNCLIST

  # we need to list these repos in the order defined in the RC file
  # so Pkg can 'fall back' to other repos in that order

  # get current config
  . "${PKGRC}"

  # set vars for this func
  local list=''
  local repo_file=''
  local repo_names=$(cut -f1 -d'|' ${HOME}/.pkg/sources)
  local current_fallback_list=$(grep "^$REPONAME|" ${HOME}/.pkg/sources | cut -f8 -d'|' | grep -v "^\$")

  # get current repo fallback list order.. note if repo not listed in fallback list, it will be appended after
  for line in $current_fallback_list
  do
    # get the repo file
    repo_file="$(grep "^$line|" ${HOME}/.pkg/sources | cut -f3 -d'|')"
    # add it to the list
    [ "$repo_file" != "" ] && list="$list$line "
  done

  # now add all other avail repos to the end of fallback list
  for repo_name in $repo_names
  do
    #if not blank, not already in the repo list and not the current repo ($REPONAME from rc file) then add to list
    [ "$repo_name" != "" ] \
      && [ "$(echo "$list" | grep -m1 "$repo_name ")" = ""  ] \
      && [ "$repo_name" != "$REPONAME" ] \
      && list="${list}${repo_name} "
  done

  # list the current repo first
  echo "$REPONAME"
  # then the other repos
  echo "$list" | tr ' ' '\n' | grep -v "^\$"
}


repo_file_list(){                 # list available repo files, $1 optional FUNCLIST

  # we need to list these repos in the order defined in the RC file
  # so Pkg can 'fall back' to other repos in that order

  # get current config
  . "${PKGRC}"

  # set vars for this func
  local list=''
  local repo_file=''
  local repo_files=""
  local repo_files_init=$(cut -f3 -d'|' ${HOME}/.pkg/sources)
  local current_fallback_list=$(grep "^$REPONAME|" ${HOME}/.pkg/sources | cut -f8 -d'|' | grep -v "^\$")

  # filter out repo files not available on this system.
  for repo in $repo_files_init
  do
  if [ -f "${REPODIR}/${repo}" ]; then
  	if [ -z "$repo_files" ]; then
  		repo_files="${repo}"
  	else
  		repo_files="${repo_files}"$'\n'"${repo}"
  	fi
  fi
  done

  # get current repo fallback list order.. note if repo not listed in fallback list, it will be appended after
  for line in $current_fallback_list
  do
    # get the repo file
    repo_file="$(grep "^$line|" ${HOME}/.pkg/sources | cut -f3 -d'|')"
    # add it to the list
    [ "$repo_file" != "" ] && list="$list$repo_file "
  done

  # now add all other avail repos to the end of fallback list
  for repo_file in $repo_files
  do
    #if not blank, not already in the repo list and not the current repo ($REPONAME from rc file) then add to list
    [ "$repo_file" != "" ] \
      && [ "$(echo "$list" | grep "$repo_file ")" = ""  ] \
      && [ "$repo_file" != "$REPOFILE" ] \
      && list="$list$repo_file "
  done

  # list the current repo first
  echo "$REPOFILE"
  # then the other repos
  echo "$list" | tr ' ' '\n' | grep -v "^\$"
}


dir2repo(){                       # create a native-Puppy repo from a dir of packages FUNCLIST

  # exit if not a valid directory
  if [ ! -d "$1" ];then
    print_usage dir2repo && exit 1
  fi

  local filename=''
  local filepath=''
  local fileext=''
  local prevext=''
  local repo_name

  # get the repo directory
  local repo_dir="$(realpath "$1")"

  # create a temp repo_file name
  local repo_file="${repo_dir}/Packages-$DISTRO_BINARY_COMPAT-$DISTRO_COMPAT_VERSION"

  # remove any old files
  rm "${repo_dir}/install" "${repo_dir}/Packages-"* "$repo_file" &>/dev/null

  echo
  echo "Creating repo from contents of: $repo_dir"
  echo

  local list
  list="$(find "$repo_dir" -maxdepth 5 -type f)"
  # exit if we encounter multiple file extensions
  for file in $list
  do
    filename=$(basename $file)
    fileext="$(get_pkg_ext "$filename")"
    if [ "$fileext" != "$prevext" ] && [ "$prevext" != "" ];then
      echo "All packages must have the same extension."
      echo "Extensions '$fileext' and '$prevext' don't match."
      echo "Package '$filename' needs to be converted to $prevext or removed."
      exit 1
    fi
    prevext="$fileext"
  done


  # get the packages in $repo_dir
  local package_list="$(find "$repo_dir" -maxdepth 5 -type f | grep -v ^Packages | grep -v "^install$")"

  if [ "$package_list" = "" ];then
    echo "No packages found in ${repo_dir}!"
    exit 1
  fi

  # for each file in the repo dir
  for file in $package_list
  do
    # skip if not a recognised package type
    [ "$(is_local_pkg "$file")" != true ] && continue

    # get the package info
    filename=$(basename $file)
    fileext="$(get_pkg_ext $filename)"
    filepath="$(realpath "$(dirname "$file")")"
    repopath="$(echo "$filepath" | sed -e "s#${repo_dir}##" -e "s/^\///")"
    pkgname=$(basename "$filename" ".$fileext")
    pkgnameonly="$(get_pkg_name_only "$pkgname")"
    pkgversion="$(get_pkg_version "$pkgname")"
    pkgcat="$(grep -m1 "|$pkgnameonly|" $REPO_DIR/Packages-* | cut -f5 -d'|')"
    pkgsize="$(du "$file" 2>/dev/null | cut -f1)K"
    [ "$pkgsize" = "" ] && pkgsize="$(grep -m1 "|$pkgnameonly|" $REPO_DIR/Packages-* | cut -f6 -d'|')"
    pkgdeps="$(grep -m1 "|$pkgnameonly|" $REPO_DIR/Packages-* | cut -f9 -d'|')"
    # dont include deps if we're adding a combined package + plus deps (they have $CP_SUFFIX in the name)
    [ "$(echo "$filename" | grep "$CP_SUFFIX")" != "" ] && pkgdeps=''
    pkgdesc="$(grep -m1 "|$pkgnameonly|" $REPO_DIR/Packages-* | cut -f10 -d'|')"
    pkgdistro="$DISTRO_BINARY_COMPAT"
    pkgdistroversion="$DISTRO_COMPAT_VERSION"

    # if we don't have the required package info, dont add it to the repo file
    [ "$pkgname" = "" ] || [ "$pkgnameonly" = "" ] || [ "$filename" = "" ] && continue

    # add this package to the repo file
    echo "$pkgname|$pkgnameonly|$pkgversion||${pkgcat:-BuildingBlock}|$pkgsize|$repopath|$filename|$pkgdeps|${pkgdesc:-No description}|$pkgdistro|$pkgdistroversion|" >> "$repo_file"
  done

  if [ ! -f "$repo_file" ];then
    echo "Error: file '$repo_file' not created."
    exit 1
  fi

  echo "Step 1 of 3: CHOOSE A REPO NAME"
  echo "(something like 'distroversion-username-repo', such as 'bionic-bob-main' or 'stretch-sc0ttman-games')"
  echo
  bash -c 'read -e -r -p "Type a repo name and hit ENTER: " repo_name; echo "$repo_name" > /tmp/pkg/repo_name'
  repo_name="$(cat /tmp/pkg/repo_name)"

  # rename the repo file to the new name
  mv "$repo_file"   "${repo_dir}/Packages-${DISTRO_BINARY_COMPAT:-puppy}-$repo_name"
  repo_file="${repo_dir}/Packages-${DISTRO_BINARY_COMPAT:-puppy}-$repo_name"

  # build repo entry
  # shellcheck disable=SC2154
  local repo_entry="$repo_name|$fileext|$repo_file|$repo_url||||noarch $repo_fallbacks"

  # get the URL where the repo file and packages will live
  echo
  echo "Step 2 of 3: ADD THE REPO URL"
  echo "(the full URL where you will upload your repo file and packages)"
  echo
  bash -c 'read -e -r -i "http://" -p "Type a repo URL and hit ENTER: " mirror1; echo "$mirror1" > /tmp/pkg/mirror1'
  mirror1="$(cat /tmp/pkg/mirror1)"

  # get fallback repos list
  echo
  echo "Step 3 of 3: ADD FALLBACK REPOS"
  echo "(the other repos to fall back to when looking for dependencies)"
  echo
  bash -c 'read  -e -r -i "noarch common32" -p "List fallback repos (separated by a space) and hit ENTER: " fallback_repos; echo "$fallback_repos" > /tmp/pkg/fallback_repos'
  fallback_repos="$(cat /tmp/pkg/fallback_repos)"

  # remove the tmp files which store user input, they're no longer needed
  rm /tmp/pkg/repo_name /tmp/pkg/mirror1 /tmp/pkg/fallback_repos

  # add a trailing slash to the URL
  if [ "$(echo "${mirror1}" | grep "/$")" = "" ];then
    mirror1="${mirror1}/"
  fi

  # create repo installer file in $repo_dir
  echo "REPONAME=$repo_name
EX=$fileext
REPOFILE=$(basename $repo_file)
URL1=${mirror1}
URL2=''
URL3=''
URL4=''
FALLBACKS='$fallback_repos'" > "${repo_dir}/install"

  # print final message
  echo
  echo -e "${green}Success${endcolour}: Repo ${yellow}$repo_name${endcolour} created."
  echo
  echo -e "You should upload everything in ${lightblue}$repo_dir${endcolour} to:"
  echo
  echo "  $mirror1"
  echo
  echo "You (and anyone else) can then install the repo using:"
  echo
  echo "  pkg add-repo ${mirror1}"
  echo
  echo -e "NOTE: You can edit the ${yellow}install${endcolour} and ${yellow}$(basename $repo_file)${endcolour}"
  echo "files in a text editor, before you upload your new repo."
  echo
}


add_pkg_repo() {                  # add a Pkg-created repo, called by add_repo() FUNCLIST
  [ ! "$1" ] && return 1
  mkdir -p /tmp/pkg/
  # this is probably a Pkg created Puppy repo, get info from 'install' file
  rm /tmp/pkg/repo_info &>/dev/null

  # check if the 'install' file we need exists
  wget --no-check-certificate -O "/tmp/pkg/repo_info" -4 "$1" &>/dev/null
  if [ ! -f /tmp/pkg/repo_info ];then
    echo "Error: Repo installer file not downloaded!"
    return 1
  elif [ "$(grep -m1 "^REPONAME" /tmp/pkg/repo_info 2>/dev/null)" = "" ];then
    echo "Error: invalid repo installer file"
    return 1
  fi

  # build a valid repo entry for the ~/.pkg/sources* files
  # (must have some fallbacks, strip quotes, newlines, no trailing pipes)
  local repo_entry="$(sed \
      -e "s/FALLBACKS=''/FALLBACKS='noarch common32'/" \
      -e 's/.*=//g' /tmp/pkg/repo_info \
    | tr -d '"' \
    | tr -d "'" \
    | tr '\n' '|' \
    | head -c -1)"

  if [ "$repo_entry" = "" ];then
    echo "Error: repo entry not created."
    return 1
  fi

  # get repo info
  local repo_name="$(echo "$repo_entry" | cut -f1 -d'|')"
  local repo_filename="$(echo "$repo_entry" | cut -f3 -d'|')"
  local repo_file_url="${1/\/install/\/$repo_filename}"

  # download the repo file
  wget --no-check-certificate -O "/tmp/pkg/$repo_filename" -4 "$repo_file_url" &>/dev/null
  if [ -z "$repo_filename" ] || [ ! -f /tmp/pkg/$repo_filename ];then
    echo "Error: Repo file $repo_filename not downloaded!"
    return 1
  fi

  # install the repo file
  mv /tmp/pkg/$repo_filename $REPO_DIR/$repo_filename
  RETVAL=$?

  # add repo entry to ~/.pkg/sources
  echo
  add_source "${repo_entry}"
  echo

  # refresh list of available repos
  update_sources
  echo
  echo "Repo info:"
  print_repo_info $repo_name
  echo

  if grep -q -m1 "^$repo_name|"  ~/.pkg/sources 2>/dev/null ;then
    echo "Success! Repo added and available to use."
    echo
    echo "To use this repo, simply type the following and hit ENTER:"
    echo "  pkg repo $repo_name"
    echo

    # register as a user installed repo, so we can remove it later (using rm_repo)
    touch ~/.pkg/sources-user
    echo "$repo_entry" >> ~/.pkg/sources-user
    local user_repos="$(sort -u ~/.pkg/sources-user)"
    echo "$user_repos" > ~/.pkg/sources-user

  fi

  return $RETVAL
}


add_repo(){                       # add Pkg/Ubuntu/Debian/Slackware third-party repos FUNCLIST

  local slack_repo_url

  if [ ! "$1" ] || [ "$1" = "-" ] || [ "$1" = "-h" ] || [ "$1" = "--help" ];then
    print_usage add_repo && exit 1
  fi

  # work out which kind of repo we are processing
  case "$1" in
    'http'*'/PACKAGES.TXT.gz'|'http'*'/PACKAGES.TXT')
      # strip trailing /PACKAGES.TXT[.gz]
      slack_repo_url="${1//PACKAGES.TXT.gz/}"
      slack_repo_url="${slack_repo_url//\/.gz/}"
      slack_repo_url="${slack_repo_url//.gz\//}"
      slack_repo_url="${slack_repo_url//PACKAGES.TXT/}"
      # add trailing slash, if needed
      if [ "$(echo $slack_repo_url | grep '/$')" = '' ];then
        slack_repo_url="${slack_repo_url}/"
      fi
      slack2pup "$@"
      retval=$?
      if [ $retval -eq 0 ];then
        # register repo, so we know to update it in update_sources()
        touch ~/.pkg/sources-user
        echo "$repo_entry" >> ~/.pkg/sources-user
        local user_repos="$(sort -u ~/.pkg/sources-user)"
        echo "$user_repos" > ~/.pkg/sources-user

        # register in a slack supported file too
        mkdir -p /etc/slackpkg/
        touch /etc/slackpkg/mirrors
        echo "$slack_repo_url" >> /etc/slackpkg/mirrors
        local slack_repos="$(sort -u /etc/slackpkg/mirrors)"
        echo "$slack_repos" > /etc/slackpkg/mirrors
      fi
      ;;

    'http'*'/install')
      add_pkg_repo "$1"
      ;;

    'ppa:'*|'http://'*|'https://'*|'ftp://'*)
      wget --quiet --timeout=2 --no-parent --spider "${1}install" 2>/dev/null && \
      {
        add_pkg_repo "${1}install"
        exit 0
      }

      # if we got here, it's not a Pkg repo we're installing,
      # so it's probably a PPA, Ubuntu or Debian repo.

      ppa2pup "$@"
      retval=$?
      if [ $retval -eq 0 ];then
        # register repo, so we know to update it in update_sources()
        touch ~/.pkg/sources-user
        echo "$repo_entry" >> ~/.pkg/sources-user
        local user_repos="$(sort -u ~/.pkg/sources-user)"
        echo "$user_repos" > ~/.pkg/sources-user

        # register in an apt-supported file too
        mkdir -p /etc/apt/
        touch /etc/apt/sources.list
        echo "deb $*" >> /etc/apt/sources.list
        local deb_repos="$(sort -u /etc/apt/sources.list)"
        echo "$deb_repos" > /etc/apt/sources.list
      fi
      ;;

    *)
      print_usage add_repo && exit 1
      ;;

  esac

}


rm_repo(){                        # remove an installed repo by name ($1) FUNCLIST
  if [ ! "$1"  ] || [ "$1" = "-" ] || [ "$1" = "-h" ] || [ "$1" = "--help" ];then
    print_usage rm_repo
    exit 1
  fi

  # $1 must be a valid, installed repo name
  if [ "$(repo_list | grep -m1 "^${1}$")" = "" ];then
    print_usage rm-repo
    exit 1
  fi

  # get the repo file and URL of the given repo
  local repo_file="$(grep "^$1" ~/.pkg/sources-all | cut -f3 -d'|' )"
  local repo_url="$(grep "^$1" ~/.pkg/sources-all | cut -f4 -d'|')"

  # dont allow removal of 'built in' repos, only user-added repos
  local matching_user_added_repos="$(grep -m1 -E "\|$repo_name\||$repo_url|${repo_name//*-/}" ~/.pkg/sources-user /etc/apt/sources.list /etc/slackpkg/mirrors 2>/dev/null)"
  if [ "${matching_user_added_repos}" = "" ];then
    echo "You can only remove the repositories that you installed yourself."
    echo -e "Use the command  ${bold}pkg repo-list${endcolour}  to see which repos are installed."
    exit 1
  fi

  # dont allow removal of current repo
  if [ "$REPONAME" = "$1" ];then
    echo "Can't remove current repo."
    echo -e "Switch to another repo first using:  ${bold}pkg repo REPONAME${endcolour}"
    exit 1
  fi

  # remove the repo file
  echo "Removing '$1'.. Please wait.."
  [ -f "${REPO_DIR}/$repo_file" ] && rm "${REPO_DIR}/$repo_file"

  # remove from sources
  grep -v "^$1|" ~/.pkg/sources > /tmp/pkg/sources
  grep -v "^$1|" ~/.pkg/sources-all > /tmp/pkg/sources-all
  [ -f /tmp/pkg/sources-all ] && mv /tmp/pkg/sources-all ~/.pkg/sources-all
  [ -f /tmp/pkg/sources     ] && mv /tmp/pkg/sources ~/.pkg/sources

  # remove from third-party lists
  touch ~/.pkg/sources-user
  grep -v  "|${repo_url}|"  ~/.pkg/sources-user > /tmp/pkg/sources-user
  grep -vE "$repo_url|${repo_name//*-/}" /etc/apt/sources.list > /tmp/pkg/sources.list
  grep -v  "$repo_url" /etc/slackpkg/mirrors > /tmp/pkg/mirrors
  [ -f /tmp/pkg/sources-user ] && mv /tmp/pkg/sources-user ~/.pkg/sources-user
  [ -f /tmp/pkg/sources.list ] && mv /tmp/pkg/sources.list /etc/apt/sources.list
  [ -f /tmp/pkg/mirrors ] && mv /tmp/pkg/mirrors /etc/slackpkg/mirrors

  if [ "$(repo_list | grep -m1 "^${1}$")" = "" ];then
    update_sources &>/dev/null
    echo -e "${green}Success${endcolour}: Repo removed."
  fi

}


add_source(){                     # add a new repo to your repo 'sources' list FUNCLIST
  [ ! "$1" ] \
  || [ "$1" = "-" ] \
  || [ "$1" = "-h" ] \
  || [ "$1" = "--help" ] \
  || [ "$(echo "$1" |  grep '|')" = "" ] \
  || [ "$(echo "$1" | cut -f2 -d'|')" = "" ] \
  || [ "$(echo "$1" | cut -f4 -d'|')" = "" ] \
  || [ "$(echo "$1" | cut -f8 -d'|')" = "" ] && \
    print_usage add_source && exit 1

  # get repo file to add to sources
  REPOTOADD="$(echo "$1" | cut -f1 -d'|')"

  # do checks before adding repo (dont add duplicate, make sure file exists, etc)

  # add the repo to sources-all, if not already there
  if [ "$(grep -m1 "^$REPOTOADD|" ${HOME}/.pkg/sources-all)" = "" ];then
    # all good, so add repo entry to sources-all
    echo "$1" >> ${HOME}/.pkg/sources-all
  fi

  # update users repo sources to get the new repo
  update_sources 1>/dev/null || { echo "Could not update repo sources."; exit 2; }

  # print msg
  echo "Repo '$REPOTOADD' added successfully."
}


update_sources(){                 # create the list of available repos FUNCLIST

  # get current repo values and Pkg settings
  . "${PKGRC}"

  #list current repo first in sources
  get_repo_info "${REPONAME:-noarch}"


  # only add the current repo to the list of available sources if it exists
  if [ "$(find ${REPO_DIR}/ -iname "$REPOFILE")" != '' ]
  then
    echo "$REPONAME|$EX|$REPOFILE|$REPOURL1|$REPOURL2|$REPOURL3|$REPOURL4|$REPOFALLBACKS" > ${HOME}/.pkg/sources
  elif [ "$(find /var/packages/ -iname "$REPOFILE")" != '' ]
  then
    echo "$REPONAME|$EX|$REPOFILE|$REPOURL1|$REPOURL2|$REPOURL3|$REPOURL4|$REPOFALLBACKS" > ${HOME}/.pkg/sources
  fi


  # get repos in order of fallbacks, pkg will then 'fall back' to each repo in that order
  local REPOFALLBACKS="$(grep -m1 "^${REPONAME}|" ${HOME}/.pkg/sources-all 2>/dev/null \
    | grep -v ^'#' \
    | cut -f8 -d'|')"

  # for each repo in fallback list
  for FBACK in $REPOFALLBACKS; do
    # dont add current repo, its already added
    [ "$FBACK" = "$REPONAME" ] && continue

    # check if repo is supported (has entries in sources-all)
    LINE="$(grep -m1 "^$FBACK|" ${HOME}/.pkg/sources-all 2>/dev/null | grep -v ^'#' | grep -v "^${REPONAME}|")"
    [ "$LINE" = "" ] && continue

    # if repo is valid, add to users list of in-use repos (only valid repos from sources-all => sources)
    if [ -f "${REPO_DIR}/$(echo "$LINE" | cut -f3 -d'|')" ];then

      if [ "$(grep -m1 "^$FBACK|" ${HOME}/.pkg/sources)" = "" ];then
        echo "Adding repo: ${LINE//|*/}.."
        echo "$LINE" >> ${HOME}/.pkg/sources
      fi
    fi
  done

  cleaned_repo_list="$(grep -v ^'#' ${HOME}/.pkg/sources-all 2>/dev/null | grep -v ^$)"

  # now add any other repos to the list (repos that are installed, but not added from fallback list)
  echo "$cleaned_repo_list" | uniq | while read repo_entry
  do
    # dont add current repo, its already added
    [ "${repo_entry//|*/}" = "$REPONAME" ] && echo "Adding repo: $REPONAME.." && continue

    # get the repo name
    repo_name="${repo_entry//|*/}"

    # build the repo file (full path)
    repo_file=${REPO_DIR}/$(echo "$repo_entry" | cut -f3 -d'|')

    # set a flag true if repo already in repo, false if not
    already_in_repo=false
    grep -q -m1 "^$repo_entry" ${HOME}/.pkg/sources 2>/dev/null && already_in_repo=true

    if [ -f "$repo_file" ] && [ "$already_in_repo" = false ];then
      echo "Adding repo: $repo_name.."
      echo "$repo_entry" >> ${HOME}/.pkg/sources
    fi
  done

  # finished, print message
  [ -f ${HOME}/.pkg/sources ] && echo "Sources updated." && . "${PKGRC}"
}


set_ppa2pup_fn(){
  #Paranoid precaution, so that one can't do code injection
  case "$PKG_PPA2PUP_FN" in
  ppa2pup_gawk) ppa2pup_fn=ppa2pup_gawk; ;;
  ppa2pup) ppa2pup_fn=ppa2pup ;;
  *)
    echo "Invalid value: PKG_PPA2PUP_FN=${PKG_PPA2PUP_FN}"
    echo "Valid values: ppa2pup or ppa2pup_gawk"
    exit 1 ;;
  esac
}


update_repo(){                    # update the current repo from a file stored online FUNCLIST

  # check internet, net connection required
  NET="$(check_net)"; [ $NET -eq 1 ] && echo "You need an internet connection" && exit 1

  # remove the repo update tmp file
  rm -f $TMPDIR/update_repo_results 2>/dev/null

  echo "Updating system repositories, please wait.."
  echo

  # use petget for now .. not ideal, petget wont accept $1 and only do that repo,
  # also petget uses loads of other files pkg doesnt have/need (in ${REPO_DIR})
  # also, we're limited to updating only the repos that petget supports, not all the ones Pkg supports..
  # .. on the plus side petget code is way faster than mine
  mkdir -p /var/local/petget/
  chmod 777 /var/local/petget/
  echo 'false' > /var/local/petget/db_verbose

  # if using the newer version of 0setup (with no popup dialogs)
  if [ "$PKG_REPO_UPDATE_METHOD" = standard ];then
    /usr/local/petget/0setup x &>$TMPDIR/update_repo_results
  # else, if we're using an older version  of 0setup
  else
    # call 0setup.. the ENV options prevent popup windows, and need for user input
    DISPLAY='' SETUPCALLEDFROM=ppm /usr/local/petget/0setup &>$TMPDIR/update_repo_results
  fi

  # if the repos updated ok
  if [ $? -eq 0 ];then
    [ "$(which logger)" != '' ] && logger "$0 Repo files updated by $APP $APPVER"
    # print list of system repos that were updated
    echo -e "Repo files updated:\n"
    if [ "$PKG_REPO_UPDATE_METHOD" = standard ];then
      grep " PKG DB " $TMPDIR/update_repo_results | cut -f2 -d ':'
    else
      grep "^Processing Packages" $TMPDIR/update_repo_results | cut -f1,2 -d' ' | sed 's#Processing #Updated:     #'
    fi
    # remove the repo update tmp file
    rm -f $TMPDIR/update_repo_results 2>/dev/null
  else
    # repo did not update ok
    error "Repos NOT updated."
    tail -20 $TMPDIR/update_repo_results
    exit 2
  fi

  # update Pkg created, user-added (third-party) repos
  if [ -f ~/.pkg/sources-user ] || [ -f /etc/apt/sources.list ] || [ -f /etc/slackpkg/mirrors ];then
    echo
    echo "Updating third-party repos.. This may take a while.."
    echo
  fi

  # update Pkg created repos
  if [ -f ~/.pkg/sources-user ];then
    pkg_repos="$(sort -u ~/.pkg/sources-user | grep -v ^$ | cut -f1 -d'|')"
    for pkg_repo in $pkg_repos
    do
      local pkg_repo_url="$(grep -m1 "^$pkg_repo|" ~/.pkg/sources-user | cut -f4 -d'|')"
      echo "Processing:  $pkg_repo_url"

      ANSWER=y
      if [ "$ASK" = true ];then
        bash -c 'read -r -N 1 -p "Update repo $pkg_repo? [y/n] " ANSWER; echo $ANSWER > /tmp/pkg/ANSWER'
        echo
        ANSWER="$(cat /tmp/pkg/ANSWER)"
      fi

      if [ "$ANSWER" = 'y' ] || [ "$ANSWER" = 'Y' ];then
        add_pkg_repo ${pkg_repo_url}install 1>/dev/null && echo -e "${green}Updated${endcolour}:     $pkg_repo"
      fi
    done
  fi

  # update third-party non-native repos.. These repos comes 'from source',
  # and are not in native Puppy format - they need to be downloaded, converted
  # into the Puppy format, then installed... so this will be slow..
  if [ -f /etc/apt/sources.list ] || [ -f /etc/slackpkg/mirrors ];then

    # update third-party Ubuntu/Debian repos
    # search inside /etc/apt/sources.list /etc/apt/sources.list.d/*.list
    # ...look for lines starting with 'deb ', ignore others
    # ...(use grep -h, to remove the preppended filenames if grepping multiple files)
    # ...remove any arch stuff from the entries, ppa2pup will handle that,
    # ...convert spaces to | chars, so we can process each line as a whole later
    local apt_sources_list="$(grep -h '^deb ' /etc/apt/sources.list /etc/apt/sources.list.d/*.list 2>/dev/null \
      | sed \
        -e "s/^deb //g" \
        -e "s/^tor+//g" \
        -e 's/\[arch=[a-z,0-9].*\] //g' \
        -e 's/ /|/g')"

    # for each repo in $apt_sources_list, use `ppa2pup` to update the repo
    for line in $apt_sources_list
    do
      [ "$line" = "" ] && continue
      [ "$line" = "\n" ] && continue

      local ppa_repo_url="$(echo ${line//|/ } | cut -f1 -d" ")"
      local ppa_repo_name=$(grep -m1 "$ppa_repo_url" ~/.pkg/sources-all | cut -f1 -d'|')

      # if a PPA repo, get a user-friendly repo name from the /etc/sources.list entry
      if [ "$ppa_repo_name" = "" ];then
        ppa_repo_name="$(echo ${line} | cut -f3 -d'|')-$(echo $line | cut -f2 -d':' | cut -f1 -d '/' | tr -d '-' | tr -d '_')"
      fi

      echo
      echo "Processing:  ${line//|/ }"

      ANSWER=y
      if [ "$ASK" = true ];then
        # ask user to update repo
        bash -c 'read -r -N 1 -p "Update repo $ppa_repo_name? [y/n] " ANSWER; echo $ANSWER > /tmp/pkg/ANSWER'
        echo
        ANSWER="$(cat /tmp/pkg/ANSWER)"
      fi

      if [ "$ANSWER" = 'y' ] || [ "$ANSWER" = 'Y' ];then
        set_ppa2pup_fn
        $ppa2pup_fn ${line//|/ } 1>/dev/null && echo -e "${green}Updated${endcolour}:     $ppa_repo_name"
        retval=$?
      fi
    done

    # update third-party Slackware repos
    if [ -f /etc/slackpkg/mirrors ];then
      local slack_repos="$(sort -u /etc/slackpkg/mirrors)"
      local slack_repo_url=""

      for slack_repo in $slack_repos
      do
        slack_repo_url="${slack_repo//PACKAGES.TXT.gz/}"
        slack_repo_url="${slack_repo_url//\/.gz/}"
        slack_repo_url="${slack_repo_url//.gz\//}"
        slack_repo_url="${slack_repo_url//PACKAGES.TXT/}"

        # add trailing slash, if needed
        if [ "$(echo $slack_repo_url | grep '/$')" = '' ];then
          slack_repo_url="${slack_repo_url}/"
        fi

        local slack_repo_name=$(grep -m1 $slack_repo_url ~/.pkg/sources-all | cut -f1 -d'|')

        echo
        echo "Processing:  $slack_repo_url"

        ANSWER=y
        if [ "$ASK" = true ];then
          # ask user to update repo
          bash -c 'read -r -N 1 -p "Update repo '"$slack_repo_name"'? [y/n] " ANSWER; echo $ANSWER > /tmp/pkg/ANSWER'
          echo
          ANSWER="$(cat /tmp/pkg/ANSWER)"
        fi

        if [ "$ANSWER" = 'y' ] || [ "$ANSWER" = 'Y' ];then
          slack2pup "${slack_repo_url}/PACKAGES.TXT" $slack_repo_name 1>/dev/null && echo -e "${green}Updated${endcolour}:     $slack_repo_name"
        fi
      done
    fi
  fi

  echo
  exit 0

}


list_sources(){                   # return available (matching) repos (~/.pkg/sources) FUNCLIST
  grep -m1 "^$1" ${HOME}/.pkg/sources ${HOME}/.pkg/sources-user | cut -f2-99 -d':' | uniq
}


list_all_sources(){               # return all (or matching) repos (~/.pkg/sources-all) FUNCLIST
  grep -m1 "^$1" ${HOME}/.pkg/sources-all ${HOME}/.pkg/sources-user | cut -f2-99 -d':' | uniq
}


convert_repofile(){               # convert repo files formats (pre-woof/post-woof) FUNCLIST

  # get the file name (FILENAME) and full path (FILE)
  FILENAME="$(basename "$1")"
  FILE="${CURDIR}/${FILENAME}"

  # check for valid options
  [ ! -f "$FILE" ] && print_usage repo-convert && exit 1

  # dont replace repo unless -f was given
  if [ "$FORCE" != true ] && [ -f "${REPO_DIR}/${FILENAME}" ];then
    echo "File '${REPO_DIR}/$FILENAME' already exists."
    exit 1
  fi

  # remove tmp files
  rm $TMPDIR/$FILENAME &>/dev/null
  rm $TMPDIR/${FILENAME}_subdirs &>/dev/null

  # check repo file format (woof or pre-woof)
  if [ -f "$FILE" ] && [ "$(head -1 "$FILE" | grep -m1 '^"')" = "" ];then #if is a new format  #'

    # convert woof repo file to pre-woof repo file.. takes ages..
    echo "Converting '${FILE}' to pre-woof format.. This might take a while.."

    # shellcheck disable=SC2002
    cat "$FILE" | while read LINE
    do
      PKGNAME="$(echo $LINE| cut -f1 -d'|')"
      # we need to get the package name, try lots of different extensions
      [ "$(echo $PKGNAME | grep ".$EX\$")" != "" ]  && PKGNAME="$(echo "$LINE" | cut -f8 -d'|')"
      [ "$(echo $PKGNAME | grep ".deb\$")" != "" ]  && PKGNAME="$(basename $PKGNAME .deb)"
      [ "$(echo $PKGNAME | grep ".rpm\$")" != "" ]  && PKGNAME="$(basename $PKGNAME .rpm)"
      [ "$(echo $PKGNAME | grep ".tgz\$")" != "" ]  && PKGNAME="$(basename $PKGNAME .tgz)"
      [ "$(echo $PKGNAME | grep ".txz\$")" != "" ]  && PKGNAME="$(basename $PKGNAME .txz)"
      [ "$(echo $PKGNAME | grep ".tar.gz\$")" != "" ] && PKGNAME="$(basename $PKGNAME .tar.gz)"
      [ "$(echo $PKGNAME | grep ".tar.xz\$")" != "" ] && PKGNAME="$(basename $PKGNAME .tar.xz)"
      [ "$(echo $PKGNAME | grep ".tar.zst\$")" != "" ] && PKGNAME="$(basename $PKGNAME .tar.zst)"
      # get size
      SIZE=" $(echo $LINE| cut -f6 -d'|')"
      # get category
      CAT="$(echo $LINE| cut -f5 -d'|')"
      #150813 remove extra categories .. example 'Setup;Installation' .. remove 'Installation'
      [ "(echo $CAT | grep ';')" != "" ] && CAT="$(echo $CAT | cut -f1 -d';')"
      # get sub dir in repo
      SUBDIR="$(echo $LINE| cut -f7 -d'|')"
      # get deps
      DEPS=" $(echo $LINE| cut -f9 -d'|'| grep '+')"
      # get desc
      DESC="$(echo $LINE| cut -f10 -d'|')"
      # add repo entry to tmp file
      [ "$PKGNAME" != "" ] && echo "\"$PKGNAME\" \"$PKGNAME: ${DESC//:/,}\" off \"$CAT$DEPS$SIZE\" /" | sed -e 's/  / /g' -e 's/,,/,/g' -e 's/, ,/,/g' | sort --field-separator='-' -k1,1d -k2gr -k3gr -k4gr | uniq >> $TMPDIR/$FILENAME
      #150213 now do subdirs... slow..
      if [ "$(echo $SUBDIR | grep "/")" != "" ] && [ "$(echo $SUBDIR | grep -i pet_packages)" = "" ]
      then
        echo "$PKGNAME|/$SUBDIR" >> $TMPDIR/${FILENAME}_subdirs
      fi
    done
    # done making a pre-woof repo file, print message
    [ -f $TMPDIR/$FILENAME ] && echo "Finished converting $FILENAME to pre-woof format." || exit 1

  else

    # convert pre-woof repo file to woof repo file.. takes ages..
    echo "Converting '$FILENAME' to a 'woof' compatible repo file. This could take a while..."

    # parse a pre-woof repo file
    # shellcheck disable=SC2002
    cat "$FILE" | while read LINE
    do
      PKGNAME='' PKGNAMEONLY='' PKGVER='' SIZE='' CAT='' DEPS='' BUILD='' SUBDIR='' PKGEXT='.pet' DESC=''

      PKGNAME="$(echo "$LINE" | cut -d'"' -f2)" #'micro
      [ "$(echo $PKGNAME | grep ".deb\$")" != "" ]    && PKGEXT='.deb'     && PKGNAME="$(basename $PKGNAME .deb)"
      [ "$(echo $PKGNAME | grep ".pet\$")" != "" ]    && PKGEXT='.pet'     && PKGNAME="$(basename $PKGNAME .pet)"
      [ "$(echo $PKGNAME | grep ".rpm\$")" != "" ]    && PKGEXT='.rpm'     && PKGNAME="$(basename $PKGNAME .rpm)"
      [ "$(echo $PKGNAME | grep ".tcz\$")" != "" ]    && PKGEXT='.tcz'     && PKGNAME="$(basename $PKGNAME .tcz)"
      [ "$(echo $PKGNAME | grep ".tgz\$")" != "" ]    && PKGEXT='.tgz'     && PKGNAME="$(basename $PKGNAME .tgz)"
      [ "$(echo $PKGNAME | grep ".txz\$")" != "" ]    && PKGEXT='.txz'     && PKGNAME="$(basename $PKGNAME .txz)"
      [ "$(echo $PKGNAME | grep ".tar.gz\$")" != "" ] && PKGEXT='.tar.gz'  && PKGNAME="$(basename $PKGNAME .tar.gz)"
      [ "$(echo $PKGNAME | grep ".tar.xz\$")" != "" ] && PKGEXT='.tar.xz'  && PKGNAME="$(basename $PKGNAME .tar.xz)"
      [ "$(echo $PKGNAME | grep ".tar.zst\$")" != "" ] && PKGEXT='.tar.zst'  && PKGNAME="$(basename $PKGNAME .tar.zst)"
      [ "$(echo $PKGNAME | grep ".pkg.tar.gz\$")" != "" ] && PKGEXT='.pkg.tar.gz' && PKGNAME="$(basename $PKGNAME .pkg.tar.gz)"
      [ "$(echo $PKGNAME | grep ".pkg.tar.xz\$")" != "" ] && PKGEXT='.pkg.tar.xz' && PKGNAME="$(basename $PKGNAME .pkg.tar.xz)"
      [ "$(echo $PKGNAME | grep ".pkg.tar.zst\$")" != "" ] && PKGEXT='.pkg.tar.zst' && PKGNAME="$(basename $PKGNAME .pkg.tar.zst)"

      # get pkg name only .. without versions or suffix
      PKGNAME_ONLY="$(echo "${PKGNAME}" | sed -e 's/-[0-9.]*/-/g' -e 's/-$//')"
      # if that didnt work, use the old method
      if [ "$PKGNAME_ONLY" = '' ] || [ "$PKGNAME_ONLY" = "$PKGNAME" ];then
        # get pkg name without version
        PKGNAME_ONLY="${PKGNAME//-*/}"
      fi
      PKGNAME_ONLY="${PKGNAME_ONLY//-*/}"

      # get pkg version
      PKGVER="$(LANG=C echo "$LINE" | sed -e 's/^[^0-9]*-//g' | cut -f1 -d'_' | cut -f1 -d'-')"
      # get pkg size
      SIZE="$(echo $LINE| cut -d'"' -f6 | cut -d' ' -f3)" #'micro
      SIZE=${SIZE## }
      SIZE=${SIZE%% }
      # must check again if pkg had no deps
      [ "$SIZE" = "" ] && SIZE=" $(echo $LINE| cut -d'"' -f6|cut -d' ' -f2)"
      # get pkg category
      CAT="$(echo $LINE | cut -d'"' -f6 | cut -d' ' -f1)"
      # remove extra categories
      [ "$(echo "$CAT" | grep ';')" != "" ] && CAT="$(echo "$CAT" | cut -f1 -d';')"
      # get pkg deps
      DEPS="$(echo "$LINE" | cut -d'"' -f6 | cut -d' ' -f2 | grep ^'+')"
      DESC="$(echo "$LINE" | cut -f10 -d'|')" #'micro
      # build the woof compatible repo file
      [ "$PKGNAME" != "" ] && echo "$PKGNAME|$PKGNAMEONLY|$VER|$BUILD|$CAT|$SIZE|$SUBDIR|${PKGNAME}${PKGEXT}|$DEPS|$DESC|$DISTRO_BINARY_COMPAT|$DISTRO_COMPAT_VERSION||" >> $TMPDIR/$FILENAME
    done
    #done making a woof repo file, print message
    [ -f $TMPDIR/$FILENAME ] && echo "Finished converting $FILENAME to woof format." || exit 1
  fi

  # if we are updating the repo, we dont wanna install the converted file straight over
  # the actual repo file, we wanna parse it for new pkgs and add only those
  if [ "$2" != "for_repo_update" ];then
    # we converted a repo that we actually wanna install, so install it
    mv $TMPDIR/$FILENAME ${REPO_DIR}/$FILENAME
    mv $TMPDIR/${FILENAME}_subdirs ${REPO_DIR}/${FILENAME}_subdirs 2>/dev/null
    echo "Repo file '${REPO_DIR}/$FILENAME' created."
    update_sources #210613 update the list of sources after adding the newly converted repo
    #exit 0
  else
    mv $TMPDIR/$FILENAME ${HOME}/$FILENAME
  fi
}


print_repo_info(){                # get repo settings, return current repo name FUNCLIST

  # get latest repo info (from sources file), or from PKGRC if that fails
  if [ "$1" ];then
    get_repo_info "$1"
  else
    . ${PKGRC}
  fi

  local pkg_count=$(wc -l < ${REPO_DIR}/${REPOFILE})

  # output the repo info
  echo "- Repo:          $REPONAME"
  echo "- Repo file:     $REPOFILE"
  echo "- Package Type:  $EX"
  echo "- Packages:      $pkg_count"
  echo "- URL Mirror 1:  $(echo $REPOURL1 | cut -f1-3 -d'/')"
  [ "$REPOURL2" != "" ] && echo "- URL Mirror 2:  $(echo $REPOURL2  | cut -f1-3 -d'/')"
  [ "$REPOURL3" != "" ] && echo "- URL Mirror 3:  $(echo $REPOURL3  | cut -f1-3 -d'/')"
  [ "$REPOURL4" != "" ] && echo "- URL Mirror 4:  $(echo $REPOURL4  | cut -f1-3 -d'/')"
  echo
  echo "- Fall back to:$(echo $REPOFALLBACKS | fold -w 50 -s | sed -e "s/ /, /g" -e "s/^/  /g")"
}



# pkg search funcs

hide_blacklisted_pkgs_from_search_results(){ # hide BUILTIN and installed pkgs from searches NOLIST

  # dont hide package if using --force (the user may want to force a re-install of already installed pkg, for example)
  [ "$FORCE" = true ] && return 0

  # remove blacklisted packages from search list
  grep -vE "'$PKG_BLACKLIST_REGEX'" $TMPDIR/pkglist > $TMPDIR/pkglist_without_blacklisted
  mv $TMPDIR/pkglist_without_blacklisted $TMPDIR/pkglist

  # clean up tmp files
  rm $TMPDIR/pkglist_* &>/dev/null
}


hide_installed_pkgs_from_search_results(){  # hide BUILTIN and installed pkgs from searches NOLIST

  # dont hide package if using --force (the user may want to force a re-install of already installed pkg, for example)
  [ "$FORCE" = true ] && return 0

  # reset tmp file
  rm $TMPDIR/pkglist_inst &>/dev/null

  # get pkg names (generic names, no versions) of all installed pkgs (builtins, devx and user installed)
  inst_pkg_list="$(cut -f1 -d'|' ${REPO_DIR}/user-installed-packages \
    ${REPO_DIR}/devx-only-installed-packages \
    ${REPO_DIR}/woof-installed-packages 2>/dev/null \
    | grep -v ^$ \
    | tr '\n' '|' \
    | sed -e "s/||/|/g" \
          -e "s/|\$//g")"

  # remove woof and user installed packages from search list
  grep -v -E "'$inst_pkg_list'" $TMPDIR/pkglist  > $TMPDIR/pkglist_without_inst
  mv $TMPDIR/pkglist_without_inst $TMPDIR/pkglist

  # clean up tmp files
  rm $TMPDIR/pkglist_* &>/dev/null
}


list_pkg_names(){                 # list pkg names in current repo only ($1 is optional filter) FUNCLIST

  # remove any previous searches
  rm $TMPDIR/pkglist* 2>/dev/null

  # get current repo ($REPOFILE)
  . ${PKGRC}

  # create the search results
  cut -f1 -d'|' ${REPO_DIR}/${REPOFILE} 2>/dev/null | grep "^${1}" > $TMPDIR/pkglist

  # filter out builtin and user installed packages
  if [ $HIDE_INSTALLED = true ];then
    hide_installed_pkgs_from_search_results
  fi
  hide_blacklisted_pkgs_from_search_results

  # support pkg name aliases in finding packages
  if [ $NO_ALIASES = false ];then
    local ALIAS_LIST
    local ALIAS
    local ALIAS_RES
    # if we have some results to parse
    if [ "$1" != "" ] && [ -f $TMPDIR/pkg_aliases ];then
      # get the list of aliases
      ALIAS_LIST="$(grep -m1 "$1" $TMPDIR/pkg_aliases  2>/dev/null | tr ',' ' ')";
      # for each alias
      echo $ALIAS_LIST | while read ALIAS
      do
        [ "$ALIAS" = '' ] && continue
        # get the match from the current repo (if any)
        ALIAS_RES="$(LANG=C cut -f1 -d'|' ${REPO_DIR}/${REPOFILE} 2>/dev/null | grep "^$ALIAS")" #'
        [ -z "$ALIAS_RES" ] && ALIAS_RES="$(LANG=C cut -f2 -d'|' ${REPO_DIR}/${REPOFILE} 2>/dev/null | grep "^$ALIAS")" #'
        # if the repo match was found in the search results
        if [ ! -z "$ALIAS_RES" ];then
          # add the alias results to the search results
          echo "$ALIAS_RES" >> $TMPDIR/pkglist
        fi
      done # for each alias
      # sort and clean the search results
      LANG=C sort -u -t "$separator" -k1,1df -k2n -k3gr -k4gr $TMPDIR/pkglist > $TMPDIR/pkglist1
      # replace the original search results
      mv $TMPDIR/pkglist1 $TMPDIR/pkglist
    fi
  fi

  # return the search results
  [ -s $TMPDIR/pkglist ] && cat $TMPDIR/pkglist 2>/dev/null

  # clean up
  [ ! -f $TMPDIR/pkglist ] && return 1
  rm $TMPDIR/pkglist* 2>/dev/null

}


list_all_pkg_names(){             # list pkg names in any repo  ($1 is optional filter)FUNCLIST

  # remove any previous search results
  rm $TMPDIR/pkglist &>/dev/null

  # if bleeding edge disabled, output the list repo by repo, in the fallback order, current repo first (that order is set in update_sources)
  repo_file_list | while read repo_file
  do
    cut -f1 -d'|' ${REPO_DIR}/${repo_file} 2>/dev/null | grep "^$1" | sort -u -t "$separator" -k1,1df -k2n -k3gr -k4gr >> $TMPDIR/pkglist
  done

  # if bleeding edge enabled, re-order the whole list, so Pkg returns the most recent pgk versions from ANY repos
  if [ "$BLEDGE" = "yes" ];then
    LANG=C sort -u -t "$separator" -k1,1df -k2n -k3gr -k4gr $TMPDIR/pkglist 2>/dev/null > $TMPDIR/pkglist_sorted
    mv $TMPDIR/pkglist_sorted $TMPDIR/pkglist
  fi

  # filter out built-in and user installed packages
  if [ $HIDE_INSTALLED = true ];then
    hide_installed_pkgs_from_search_results
  fi

  hide_blacklisted_pkgs_from_search_results

  # support pkg name aliases in finding packages
  if [ $NO_ALIASES = false ];then
    local ALIAS_LIST
    local ALIAS
    local ALIAS_RES
    # if we have some results to parse
    if [ "$1" != "" ] && [ -f $TMPDIR/pkg_aliases ];then
      # get the list of aliases
      ALIAS_LIST="$(grep -m1 "$1" $TMPDIR/pkg_aliases  2>/dev/null | tr ',' ' ')";
      # for each repo
      LANG=C repo_file_list | while read RF
      do
        # and for each alias
        for ALIAS in $ALIAS_LIST; do
          # get the match from the current repo (if any)
          ALIAS_RES="$(LANG=C cut -f1 -d'|' ${REPO_DIR}/${RF} 2>/dev/null | grep -m1 "^$ALIAS")"
          [ -z "$ALIAS_RES" ] && ALIAS_RES="$(LANG=C cut -f2 -d'|' ${REPO_DIR}/${RF} 2>/dev/null | grep -m1 "^$ALIAS")"
          # if the repo match was found in the search results
          if [ ! -z "$ALIAS_RES" ];then
            # add the alias results to the search results
            echo "$ALIAS_RES" >> $TMPDIR/pkglist
          fi
        done # for each alias
      done # for each repo
    fi
  fi

  # return the search results
  [ -s $TMPDIR/pkglist ] && LANG=C sort -t "$separator" -k1,1df -k2n -k3gr -k4gr $TMPDIR/pkglist | uniq

  # clean up
  [ ! -f $TMPDIR/pkglist ] && return 1
  rm $TMPDIR/pkglist &>/dev/null
}


list_build_scripts(){             # list available build scripts  ($1 is optional filter)FUNCLIST

  # get settings from RC file
  . ${PKGRC}

  # make sure PetBuild is ready
  [ "$BUILDTOOL" = "petbuild" ] && prepare_petbuild

  # if no option given, just sort the results
  [ "$1" != "" ] && FILTER="grep -i $1" || FILTER="sort"

  # different build tools have their build scripts in different places.
  # check which BUILDTOOL we are using and list its build scripts
  case $BUILDTOOL in
    petbuild)
      find /usr/share/petbuild/ -type f -name "*.petbuild" \
        | grep -vE '^/$|^$'                                \
        | sed                                              \
          -e 's#.*/##g'                                    \
          -e "s/.petbuild$//g"                             \
        | sort -u                                          \
        | $FILTER
    ;;
    buildpet)
      find /usr/share/buildpet/ -type f -name "*.petbuild" \
        | grep -vE '^/$|^$|buildpet.profile'               \
        | sed                                              \
          -e 's#.*/##g'                                    \
          -e "s/.bp$//g"                                   \
        | sort -u                                          \
        | $FILTER
    ;;
    src2pkg)
      echo "Use: src2pkg FILE|URL or src2pkg -h"
    ;;
    sbopkg)
      sbopkg
    ;;
    *)
      echo "No build system configured. Set BUILDTOOL in $PKGRC."
      echo "Supported build tools: petbuild, buildpet, src2pkg, sbopkg"
    ;;
  esac
}


list_downloaded_pkgs(){           # list packages downloaded in WORKDIR ($1 is optional filter) FUNCLIST

  . ${PKGRC}

  (
  cd "$WORKDIR" || { error "Cant cd into $WORKDIR"; exit 3; }

  local pkg

  # if no pkg given, list all
  if [ ! "$1" ];then

    # get all pkgs in WORKDIR
    find "${WORKDIR}" -maxdepth 1 -type f | sed -e "s#${WORKDIR}##g" -e "s#^/##g" | grep -v ^'.pkg' | sort \
      | while read pkg # but go through each and only print it if a valid pkg
      do
        [ "$(is_local_pkg "$pkg")" = true ] && echo "$pkg"
      done

    return 0

  else

    # $1 might be a pkg, or list of pkgs, loop through them
    for x in $1; do
      if [ "$x" != "-" ];then

        # print the list of packages matching $x
        find "${WORKDIR}" -maxdepth 1 -type f | sed -e "s#${WORKDIR}##g" -e "s#^/##g" | grep -v ^'.pkg'|grep ^"$x" | sort \
          | while read pkg # but go through each and only print it if a valid pkg
          do
            [ "$(is_local_pkg "$pkg")" = true ] && echo "$pkg"
          done

        return 0
      fi
    done
  fi

  cd - || exit 1
  )
}


list_installed_pkgs(){            # list user installed packages ($1 is optional filter) FUNCLIST

  local user_pkgs_list=''
  local builtins_list=''
  local devx_pkgs_list=''

  user_pkgs_list=${REPO_DIR}/user-installed-packages

  if [ "$HIDE_BUILTINS" != true ] && [ -f ${REPO_DIR}/devx-only-installed-packages ];then
    devx_pkgs_list=${REPO_DIR}/devx-only-installed-packages
  fi

  [ "$HIDE_BUILTINS" != true ] && builtins_list=${REPO_DIR}/woof-installed-packages

  # search current repo file only .. $1 is the optional pkg filter.. take field1, remove empty lines, remove dashes, remove Pkg from pkg list too
  if [ ! "$1" ];then
    cut -f1 -d'|' $user_pkgs_list $devx_pkgs_list $builtins_list | grep -vE '^\$|^pkg\-'
    return 0
  else
    cut -f1 -d'|' $user_pkgs_list $devx_pkgs_list $builtins_list | grep "^$1" | grep -vE '^\$|^pkg\-'
    return 0
  fi
}


list_builtin_pkgs(){              # lists builtin packages FUNCLIST

  local builtins_repo

  builtins_repo=${REPO_DIR}/woof-installed-packages

  # search builtins (woof-installed) repo file only .. $1 is the optional pkg filter.. take field1, remove empty lines, remove dashes, remove Pkg from pkg list too
  cut -f1 -d'|' $builtins_repo | grep "^$1" | grep -v ^\$  | grep -v "\-$" | grep -v "^pkg-" | sort -u
}


search_pkgs(){                    # given $1, searches current repo, shows name and desc columns FUNCLIST

  local name
  local desc
  local descfull
  local search
  local cols
  local name_width
  local desc_width

  # get terminal width
  cols=$(tput cols 2>/dev/null)
  cols=${cols:-${COLS:-80}}
  # allow wider names if terminal is larger than 90
  name_width=$([ $cols -ge 90 ] && echo 35 || echo 20)
  desc_width=$(($cols - $name_width - 3))

  # convert "foo[ -_]bar" into "foo.*bar"
  search=$(echo "$1" | sed -e 's| |.*|g' -e 's|-|.*|g' -e 's|_|.*|g')

  # convert repo file to nice columnised output, use cat|grep so empty searches return all results
  grep -i "$search" ${REPO_DIR}/${REPOFILE} 2>/dev/null | while read repo_line;
  do
    name=$(echo  "$repo_line"|cut -f2  -d'|')
    descfull="$(echo "$repo_line"|cut -f10 -d'|')"
    desc="$(echo "$descfull"| head -c $(($desc_width)))"
    [ "$desc" != "$descfull" ] && desc="${desc}.."
    printf "%-"${name_width}"s" "$name" " ${desc:-No description}"
    echo
  done
}


search_fast(){                    # given $1, searches current repo, show pkg names only, case sensitive FUNCLIST
  local search

  # convert "foo[ -_]bar" into "foo.*bar"
  search=$(echo "$1" | sed -e 's| |.*|g' -e 's|-|.*|g' -e 's|_|.*|g')

  # get matching pkgs
  LANG=C grep -i "$search" ${REPO_DIR}/${REPOFILE} 2>/dev/null \
    | cut -f1 -d'|' \
    | sort -u -t "$separator" -k1,1df -k2n -k3gr -k4gr > $TMPDIR/pkglist

  # error if no result
  [ ! -s "$TMPDIR/pkglist" ] && return 1

  # hide built-in, devx and user installed packages
  if [ $HIDE_INSTALLED = true ];then
    hide_installed_pkgs_from_search_results
  fi

  hide_blacklisted_pkgs_from_search_results

  # error if no result
  [ ! -s "$TMPDIR/pkglist" ] && return 1

  # now show the search results
  grep -v ^$ $TMPDIR/pkglist

  # clean up
  rm $TMPDIR/pkglist 2>/dev/null
}


search_all_pkgs(){                # given $1, search all repos, show name and desc columns FUNCLIST
  local name
  local desc
  local descfull
  local search
  local cols
  local name_width
  local desc_width

  # get terminal width
  cols=$(tput cols 2>/dev/null)
  cols=${cols:-${COLS:-80}}
  # allow wider names if terminal is larger than 90
  name_width=$([ $cols -ge 90 ] && echo 35 || echo 20)
  desc_width=$(($cols - $name_width - 3))

  # convert "foo[ -_]bar" into "foo.*bar"
  search=$(echo "$1" | sed -e 's| |.*|g' -e 's|-|.*|g' -e 's|_|.*|g')

  for repo_file in $(repo_file_list)
  do #090817
    # convert repo file to nice columnised output
    grep -i "$search" ${REPO_DIR}/${repo_file} 2>/dev/null | while read repo_line;
    do
      # get details from repo
      name=$(echo  "$repo_line"|cut -f2  -d'|')
      descfull="$(echo "$repo_line"|cut -f10 -d'|')"
      desc="$(echo "$descfull" | head -c $desc_width)"
      [ "$desc" != "$descfull" ] && desc="${desc}.."
      # remove spaces and comments (slackware-extra repo has some dodgy entries.. dogy names, descriptions with comments, etc)
      name="${name// /}"
      name="${name//#/}"
      [ "$name" = '' ] && continue
      # print columnised output
      printf "%-"$name_width"s" "$name" " ${desc:-No description}"
      echo
    done
  done
}


search_all_fast(){                # given $1, search all repos, show pkg names only, case sensitive FUNCLIST
  local search

  # convert "foo[ -_]bar" into "foo.*bar"
  search=$(echo "$1" | sed -e 's| |.*|g' -e 's|-|.*|g' -e 's|_|.*|g')

  #if bleeding edge enabled, combine into 1 list, so
  # that `pkg -g` etc return most recent from ALL repos
  rm $TMPDIR/pkglist &>/dev/null

  # output the list repo by repo, in the fallback order,
  # current repo first (that order is set in update_sources)
  for RF in $(repo_file_list)
  do
    grep -i "$search" ${REPO_DIR}/${RF} 2>/dev/null | cut -f1 -d'|' | sort -u -t "$separator" -k1,1df -k2n -k3gr -k4gr | sed -e '/^$/d' >> $TMPDIR/pkglist
  done

  # error if no result
  [ ! -s "$TMPDIR/pkglist" ] && return 1

  #100817 hide built-in, devx and user installed packages
  if [ $HIDE_INSTALLED = true ];then
    hide_installed_pkgs_from_search_results
  fi

  hide_blacklisted_pkgs_from_search_results

  # error if no result
  [ ! -s "$TMPDIR/pkglist" ] && return 1

  # if bleeding edge, re-order the whole list, so output no longer
  # repo by repo, but newest packages at the top
  if [ "$BLEDGE" = "yes" ];then
    sort -u -t "$separator" -k1,1df -k2n -k3gr -k4gr "$TMPDIR/pkglist" > "$TMPDIR/pkglist_sorted"
    mv "$TMPDIR/pkglist_sorted" "$TMPDIR/pkglist"
  fi

  # now print the search results
  grep -v "^\$" $TMPDIR/pkglist 2>/dev/null

  # clean up
  rm $TMPDIR/pkglist &>/dev/null
}


which_repo(){                     # list repo of given package ($1) FUNCLIST

  # if no valid options, quit
  [ ! "$1" ] || [ "$1" = "-" ] || [ "$1" = " " ] && print_usage which-repo && exit 1

  . "${PKGRC}"

  local PKGNAME=''
  local PKGNAME_ONLY=''
  local repo_file=''
  local repo_name=''
  local pkg_list=''

  PKGNAME=$(get_pkg_name "$1")
  repo_file="$(grep -l "^$PKGNAME|" ${REPO_DIR}/Packages-* | head -1)"

  if [ -z "$repo_file" ];then
    repo_file="$(grep -l "^$PKGNAME|" ${REPO_DIR}/user-installed* | head -1)"
    [ ! -z "$repo_file" ] && return 1
  fi

  if [ ! -z "$repo_file" ];then
    # get the repo name
    repo_name="$(grep -m1 "|$(basename $repo_file)|" ${HOME}/.pkg/sources-all | cut -f1 -d'|')"
    pkg_list="$PKGNAME $repo_name"
    # show results
    echo -e "$pkg_list" | sed -e '/^ $/d' | sort -u
    return 0
  fi

  return 1
}


which_pkg(){                      # find out which pkg FILE ($1) comes from FUNCLIST

  # exit if no valid opts
  [ ! "$1" ] || [ "$1" = '-' ] || [ "$1" = '' ] && print_usage which && exit 1

  local PKGNAME=''
  local FILENAME=''
  local cmd=''

  # get user input
  FILENAME="$1"

  # if we don't have a file, the user probably gave a command,
  # so lets check see
  if [ ! -f "$FILENAME" ];then
    # if we get a command, then that is our FILENAME
    cmd=$(which "$FILENAME")
    # if $cmd found, set FILENAME to $cmd (FILENAME now includes full path)
    [ "$cmd" != '' ] && FILENAME=$cmd
  fi

  # check if the given file or cmd is from a built in package
  pkgfile="$(grep -l "^$FILENAME\$" $REPO_DIR/builtin_files/* | head -1)"
  [ -f "$pkgfile" ] && PKGNAME="$(get_pkg_name "$(basename $pkgfile 2>/dev/null)")"

  # check if the given file or cmd is from a user installed in package
  if [ -z "$PKGNAME" ];then
    pkgfile="$(grep -l "^$FILENAME\$" $REPO_DIR/*.files | head -1)"
    [ -f "$pkgfile" ] && PKGNAME="$(get_pkg_name "$(basename $pkgfile 2>/dev/null | sed 's/\.files//g')")"
  fi

  [ ! -z "$PKGNAME" ] && echo "$PKGNAME" && return 0

  echo "File '$FILENAME' not found in any installed or built-in pkgs."
  return 1
}


# pkg info funcs

pkg_contents(){                   # list package ($1) contents FUNCLIST

  # if no valid options, quit
  [ ! "$1" ] || [ "$1" = "-" ] || [ "$1" = " " ] && print_usage contents && exit 1

  # get settings
  . "${PKGRC}"

  local PKGFILE
  local ext
  local PKGNAME
  local PKGNAME_ONLY
  local pkg_is_local_file
  local pkg_is_builtin
  local pkg_is_installed

  # get pkg extension
  PKGNAME="$(basename "$1" .$ext)"
  PKGNAME=$(get_pkg_name "$PKGNAME")
  PKGFILE="$(get_pkg_filename "$1")"
  ext=$(get_pkg_ext "${PKGFILE}")

  pkg_is_installed=$(HIDE_BUILTINS=true is_installed_pkg "$PKGNAME")

  if [ "$pkg_is_installed" = true ] && [ -f "${REPO_DIR}/${PKGFILE//.$ext/}.files" ];then
    cat "${REPO_DIR}/${PKGFILE//.$ext/}.files"
    return 0
  fi

  if [ "$pkg_is_installed" = true ] && [ -f "${REPO_DIR}/${PKGNAME}.files" ];then
    cat "${REPO_DIR}/${PKGNAME}.files"
    return 0
  fi

  # get pkg name without version
  PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")
  PKGNAME_ONLY="${PKGNAME_ONLY:-$PKGNAME}"

  local file_list=$(find ${REPO_DIR}/ -maxdepth 1 -type f -wholename "*/$PKGNAME_ONLY[\-_]*.files")

  if [ -f "$file_list" ] && [ -s "$file_list" ];then
    cat "$file_list"
    return 0
  fi

  if [ -f "$1" ];then
    PKGPATH="$1"
  fi

  # try a file in the current dir if needed
  [ ! -f "${PKGPATH}" ] && PKGPATH="$(find "$WORKDIR" -type f -name "${PKGFILE}")"
  [ ! -f "${PKGPATH}" ] && PKGPATH="$(find "$CURDIR" -type f -name "${PKGFILE}")"
  [ ! -f "${PKGPATH}" ] && PKGPATH="$(find ~/pkg/ -type f -name "${PKGFILE}")"

  # if the pkg is a local file
  if [ -f "$PKGPATH" ];then
    #list contents based on extension
    case "$ext" in
    sfs)
      unsquashfs -l "$PKGPATH"  | cut -f2-99 -d'/'| sed -e 's#^#/#g' 2>/dev/null | grep -v -E 'unsquashfs:|/squashfs-root|) to write' | grep -v "^/$"
    ;;
    deb)
      dpkg-deb -c "$PKGPATH" 2>/dev/null | grep -v "^/$"
    ;;
    pet|tar|tar**tcz|*txz|*tgz|*xz|*gz|*tzst|*zst)
      # remove leading pkg name from each line of file list
      # (shown if listing *some* pkg file contents)
      tar --force-local -tvf "$PKGPATH" 2>/dev/null \
        | sed -e "s#.*\./${PKGNAME}/#/#g" -e "s#^${PKGNAME}/#/#g" -e "s#^./##g" 2>/dev/null \
        | grep -v ^$ 2>/dev/null \
        | grep -v "^/$" \
        | sort -u
    ;;
    rpm)
      busybox rpm -qlp "$PKGPATH" 2>/dev/null | grep -v "^/$"
    ;;
    esac
    exit $?
  fi

  # if we are here, the pkg is not a user installed or downloaded pkg..
  # but it might be a "builtin" package..

  # if the pkg is a builtin, we will re-format the output of LIST to match the others (full paths on each line)
  if [ -f "${REPO_DIR}/builtin_files/$PKGNAME_ONLY" ];then

    # reset the list of pkg files, we will re-build it
    rm $TMPDIR/pkg_file_list 2>/dev/null

    # builtin files may not list full paths, parse it if needed
    cat "${REPO_DIR}/builtin_files/$PKGNAME_ONLY" 2>/dev/null | while read line
    do
      if [ "$(echo "$line" | grep ' ')" != '' ];then
        # parse it, so we get a full path to file on each line
        dir="$dir"
        line_to_add="$dir/$(echo "$line" | cut -f2 -d' ')"
      else
        dir="$line"
        line_to_add="$line"
      fi

      # if only a dir, skip it
      [ -d "$line_to_add" ] && continue

      # if its already added, skip it
      grep -q -m1 "$line_to_add" ${TMPDIR}/pkg_file_list 2>/dev/null && continue

      # if its not a file on the system (it should be), skip it
      [ ! -e "$line_to_add" ] && continue

      # all should be ok, add the line to our list
      echo "$line_to_add" >> $TMPDIR/pkg_file_list
    done

    # print formatted contents
    cat ${TMPDIR}/pkg_file_list 2>/dev/null

    # and clean up the tmp files
    rm ${TMPDIR}/pkg_file_list 2>/dev/null
    exit 0
  fi

  # if no files found
  INST_CHECK="$(is_installed_pkg $PKGNAME 2>/dev/null)"
  if [ "$INST_CHECK" != true ] || [ "$pkg_is_local_file" = false ];then
    error "Package must be installed, downloaded or built-in."
  else
    error "Could not get package contents, unable to get file list."
  fi
}


pkg_entry(){                      # show pkg ($1) repo entry, each field on a new line FUNCLIST

  # exit if no valid opts
  [ ! "$1" ] || [ "$1" = '-' ] && print_usage pkg-entry && exit 1

  local EX
  local PKGNAME
  local PKGNAME_ONLY

  # get pkg extension
  EX=$(get_pkg_ext "$1")

  # get pkg name with version, but no extension or path
  PKGNAME="$(basename "$1" .$EX)"

  # dont rely on the string the user gave us, try to get the exact match
  PKGNAME=$(get_pkg_name "$PKGNAME")
  PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")

  PKG_ENTRY="$(cat ${REPO_DIR}/Packages-* | grep -m1 "|$PKGNAME|")"
  [ "$PKG_ENTRY" = '' ] && PKG_ENTRY="$(cat ${REPO_DIR}/Packages-* | grep -m1 "^$PKGNAME|")"
  [ "$PKG_ENTRY" = '' ] && PKG_ENTRY="$(cat ${REPO_DIR}/Packages-* | grep -m1 "|$PKGNAME_ONLY|")"
  if [ "$PKG_ENTRY" = '' ];then
    echo "'$1' not found in $REPOFILE"
    return 1
  else
    echo "$PKG_ENTRY"
  fi
  return 0
}


pkg_status(){                     # print package ($1) name, status, deps, etc FUNCLIST

  # exit if no valid options
  [ ! "$1" ] || [ "$1" = "-" ] && print_usage pkg-status && exit 1

  # get current repo name
  . "${PKGRC}"

  local EX
  local PKGNAME=''
  local PKGNAME_ONLY=''
  local PKGFILE=''
  local MSG=''
  local install_status=''
  local pkg_found=false
  local pkg_repo=''
  local pkg_repo_file=''
  local prev_repo="${REPONAME}"

  # get pkg extension
  EX=$(get_pkg_ext "${1:-$EX}")

  # dont rely on the string the user gave us, try to get the exact match
  PKGNAME=$(get_pkg_name "$1")

  # get pkg name without version
  PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")

  [ "$PKGNAME" = '' ] && error "Can't find $1" && exit 1

  # get install status of pkg (installed or not)
  [ "$(is_installed_pkg $PKGNAME)" = true ] && install_status="installed" || install_status="not installed"

  # if pkg is installed, find out from where
  if [ "$install_status" = "installed" ];then

    # check builtins for PKGNAME_ONLY, if it exists, its a builtin pkg
    if [ -d ${REPO_DIR}/builtin_files/ ] && [ "$pkg_found" = false ];then
      pkg_found=$(LANG=C is_builtin_pkg "${PKGNAME_ONLY}")
      [ "$pkg_found" = true ] && install_status="installed (builtin)"
    fi

    # check user installed pkgs for $PKGNAME
    pkg_found=$(LANG=C is_usr_pkg "${PKGNAME}")
    [ "$pkg_found" = true ] && install_status="installed (user)"

    # if pkg not found yet, check if pkg is from the devx
    if [ -f ${REPO_DIR}/devx-only-installed-packages ] && [ "$pkg_found" = false ];then
      pkg_found=$(LANG=C is_devx_pkg "${PKGNAME}")
      [ "$pkg_found" = true ] && install_status="installed (in devx)"
    fi

  fi

  # if we have a repo to search for pkg info
  if [ "$(is_repo_pkg "$PKGNAME")" = true ];then

    pkg_repo="$(which_repo "$PKGNAME")"
    pkg_repo="${pkg_repo//* /}"

    pkg_repo_file="$(grep -m1 "^$pkg_repo|" $HOME/.pkg/sources-all | cut -f3 -d'|')"

    # get package description from its repo entry
    pkg_desc="$(LANG=C grep -m1 "|${PKGNAME_ONLY}|" ${REPO_DIR}/$pkg_repo_file 2>/dev/null \
      | grep -m1 "$PKGNAME" \
      | cut -f10 -d'|' \
      | head -1)"

    if [ "$pkg_desc" = '' ];then
      pkg_desc="$(LANG=C grep -m1 "|${PKGNAME_ONLY}|" ${REPO_DIR}/Packages-* 2>/dev/null \
        | grep -m1 "${PKGNAME}|" \
        | cut -f10 -d'|' \
        | head -1)"
    fi

    # get size of pkg
    pkg_size=$(LANG=C grep -m1 "|${PKGNAME_ONLY}|" ${REPO_DIR}/$pkg_repo_file 2>/dev/null | cut -f6 -d'|' | head -1)

    # add K to end of pkg_size, if not there already
    [ "$pkg_size" != '' ] && pkg_size="${pkg_size}K" && pkg_size="${pkg_size//KK/K}"

    # if called with -PS, we get the full info (where we sort deps missing or installed)
    if [ "$FULL_PKG_STATUS" != true ];then

      DEPS_ENTRY="Dependencies:   $(list_deps "$PKGNAME" 2>/dev/null)"

    else
      # if pkg has many deps, checking the deps might take a while, print a 'please wait' msg
      please_wait=false
      # count deps of pkg
      [ "$(has_deps "$PKGNAME")" = true ] && please_wait=true
      [ "$please_wait" = true ] && echo -ne "Please wait.. Gathering dependency information.\n"

      # sort deps into 2 lists: missing deps and installed deps
      find_deps "$PKGNAME"
      set_current_repo $prev_repo 1>/dev/null

      # create a nicely formatted, coloured list of deps, green for installed, yellow for missing
      INSTALLED_DEPS_MSG="${green}$(echo "${DEPS_INSTALLED}" \
        | grep -v "^\$" \
        | tr '\n' ','   \
        | sed           \
          -e 's#,$##'   \
          -e 's#,#, #g' \
        | fold -w 50 -s \
        | sed '2,20 s/^/                /g' 2>/dev/null)${endcolour}"

      MISSING_DEPS_MSG="${yellow}$(echo "${DEPS_MISSING}" \
        | grep -v "^\$" \
        | tr '\n' ','   \
        | sed           \
          -e 's#,$##'   \
          -e 's#,#, #g' \
        | fold -w 50 -s \
        | sed '2,80 s/^/                /g')${endcolour}"

      DEPS_ENTRY="Installed deps: ${INSTALLED_DEPS_MSG:-None}
Missing deps:   ${MISSING_DEPS_MSG:-None}"

    fi

    #250613 added desc
    MSG="
Name:           ${PKGNAME}
Description:    $(echo ${pkg_desc:-No description} | fold -w 50 -s | sed '2,10 s/^/                /g')
Size:           ${pkg_size:-Unknown}
Status:         ${install_status:-Unknown}
In Repo:        ${pkg_repo:-Not in any repos}
Repo file:      $(basename ${pkg_repo_file:-Not in any repositories} 2>/dev/null)
$DEPS_ENTRY"

  fi

  # if not found in any repo, maybe a woof or alien (user-installed) package...
  if [ "$MSG" = "" ];then #if nothing found in any repo

    PKGFILE="$(get_pkg_filename "$PKGNAME")"
    if [ -z "$PKGFILE" ] || [ ! -f "$PKGFILE" ];then
      PKGFILE="$(list_downloaded_pkgs | grep -m1 "^$PKGNAME").$EX"
    fi

    # if the pkg is a downloaded file (in WORKDIR)
    if [ -f "$WORKDIR/$PKGFILE" ];then
      # get the file, and get its file size
      PKGFILE="$WORKDIR/${PKGFILE}"

      [ "$pkg_size" = '' ] && pkg_size="$(du -s -k "$PKGFILE" | cut -f1)K"
      [ "$pkg_size" = '' ] && pkg_size="$(grep -m1 "|${PKGNAME_ONLY}|" ${REPO_DIR}/*-installed-packages | cut -f6 -d'|' | head -1)"

      # create msg for downloaded pkgs
      MSG="Name:           ${PKGNAME}
Size:           ${pkg_size:-Unknown}
Status:         Downloaded
Note:           Downloaded package, not in any repo.
$DEPS_ENTRY"

    elif [ "$(is_usr_pkg "$PKGNAME")" = true ];then

      # get deps and size from its entry in user-installed-packages
      DEPS_ENTRY="$(grep -m1 "^$PKGNAME|" ${REPO_DIR}/user-installed-packages \
        | cut -f9 -d'|' \
        | sed \
          -e 's/,+/,/g' \
          -e 's/^+//g' \
          -e 's/,$//g' \
        2>/dev/null)"

      [ "$DEPS_ENTRY" = '' ] && DEPS_ENTRY="$(grep -m1 "^$PKGNAME" ${REPO_DIR}/*-installed-packages \
        | cut -f9 -d'|' \
        | sed \
          -e 's/,+/,/' \
          -e 's/^+//' \
          -e 's/,$//' 2>/dev/null)"

      pkg_size=$(LANG=C grep -m1 "|$PKGNAME_ONLY|" ${REPO_DIR}/*-installed-packages | cut -f6 -d'|' | head -1)

      # add K to end of pkg_size, if not there already
      [ "$pkg_size" != '' ] && pkg_size="${pkg_size}K" && pkg_size="${pkg_size//KK/K}"

      # create msg for user installed pkgs
      MSG="Name:      ${PKGNAME}
Size:           ${pkg_size:-Unknown}
Status:         ${install_status}
Repo:           Alien package, not in any repo.
Dependencies:   $DEPS_ENTRY"

    else # pkg wasn't found, it's unknown to Pkg

      MSG="$PKGNAME not found.

Here are some packages in other repos:"
      PLIST="$(which_repo ${PKGNAME})"
      [ "$PLIST" != "" ] && MSG="$MSG
$PLIST"
      # create msg for alien pkgs
      MSG="$MSG

Name:           ${PKGNAME}
Status:         ${install_status:-Unknown}
Repo:           Alien package, not in $REPONAME repo.
Dependencies:   $DEPS_ENTRY"

    fi

  fi

  # print message
  if [ "$MSG" != "" ];then
    # now output the final msg
    echo -e "$MSG" | grep -v ^$
    menu_entry_msg "$PKGNAME" | grep -v '^$'
    echo
  else
    not_found "${PKGNAME}"
    exit 1
  fi
}


# pkg creation funcs

prepare_petbuild(){               # get 01mickos petbuild system from Git, if needed FUNCLIST

  # exit if no devx
  command gcc --version &>/dev/null || \
    {
      echo "You need the devx SFS installed to compile packages."
      rm /tmp/pkg/petbuild_prepared 2>/dev/null
      exit 3
    }

  # exit if no git
  command git --version &>/dev/null || \
    {
      echo "You need git installed to auto-install petbuild."
      rm /tmp/pkg/petbuild_prepared 2>/dev/null
      exit 3
    }

  if [ ! -d /usr/share/petbuild ];then
    rm /tmp/pkg/petbuild_prepared 2>/dev/null && exit 1
  fi

  # if petbuild prepared flag not yet set
  if [ ! -f /tmp/pkg/petbuild_prepared ];then

    # backup old petbuild if installed
    [ -d /usr/share/petbuild/ ] && mv /usr/share/petbuild/ /usr/share/petbuild.backup/ 2>/dev/null

    # remove the original petbuild dir (we have a backup)
    if [ -d /usr/share/petbuild.backup/ ];then
      rm -rf /usr/share/petbuild 2>/dev/null
    fi

    # clone petbuild into /usr/share/petbuild
    git clone https://github.com/puppylinux-woof-CE/petbuilds.git /usr/share/petbuild &>/dev/null

    # if still no petbuild dir in /usr/share, tell user to install themselves
    if [ ! -d /usr/share/petbuild ];then
      echo >&2
      echo "Run this command to download PetBuild:" >&2
      echo >&2
      echo -e " ${green}git clone https://github.com/puppylinux-woof-CE/petbuilds /usr/share/petbuild${endcolour}" >&2
      echo >&2
      echo "Alternatively, use a different build tool backend by changing BUILDTOOL= " >&2
      echo "to one of the options below, in the $PKGRC file:" >&2
      echo "petbuild, buildpet, sbopkg or src2pkg" >&2
      echo >&2

      exit 1
    fi

    # go into buildpet dir, check which Pup we have ($DISTRO_DB_SUBNAME)
    # and checkout the right branch for the running system
    cd /usr/share/petbuild || exit

    git checkout generic

#    # check the puppy running and checkout the relevant branch
#    if [ "${DISTRO_DB_SUBNAME//slacko/}" != "${DISTRO_DB_SUBNAME" ];then
#      if [ "${DISTRO_DB_SUBNAME//14.2}" != "$DISTRO_DB_SUBNAME" ];then
#        git checkout slacko_142
#      else
#        git checkout slacko_141
#      fi
#    elif [ "`echo $DISTRO_DB_SUBNAME | grep tahrpup`" ];then
#      git checkout tahrpup
#    elif [ "`echo $DISTRO_DB_SUBNAME | grep stretch`" ];then
#      git checkout stretch || git checkout tahrpup
#    elif [ "`echo $DISTRO_DB_SUBNAME | grep xenialpup`" ];then
#      git checkout xenialpup || git checkout tahrpup
#    elif [ "$DISTRO_DB_SUBNAME" != '' ];then
#      git checkout tahrpup
#    else
#      echo "No pet builds available for your system ($DISTRO_DB_SUBNAME),"
#      echo "using buildpet instead.."
#      rm -rf /usr/share/petbuild 2>/dev/null
#    fi

    # buildpet setup finished, create flag
    echo 'true' > /tmp/pkg/petbuild_prepared

    cd "$CURDIR" || exit
  fi
}


pkg_build(){                      # build package ($1) from source (see BUILDTOOL in pkgrc) FUNCLIST

  # exit if devx not installed
  command gcc --version &>/dev/null \
    || {
      echo "You need the devx SFS installed to compile."
      exit 1
    }

  # get the settins from RC file
  . "${PKGRC}"

  # get pkg extension
  EX=$(get_pkg_ext "${1:=$EX}")

  # run any relevant plugins
  ASK=$PLUGIN_ASK FORCE=$FORCE run_plugins 'pre_build'

  # we do a different build method for each supported build tool
  case $BUILDTOOL in

    petbuild) # by 01micko

      # use git to install the latest petbuild
      if [ ! -f  /tmp/pkg/petbuild_prepared ] && [ ! -d /usr/share/petbuild ];then
        prepare_petbuild
      fi

      # if petbuild not installed, quit
      [ ! -d /usr/share/petbuild ] && error "PetBuild not installed at /usr/share/petbuild." && exit 3

      # petbuild needs a package name, or exit
      [ ! "$1" ] || [ "$1" = "-" ] && print_usage pkg-build && exit 1 #220613 #250613

      # get pkg name only, no extension or path
      PKGNAME="$(basename "$1" .$EX)"

      # get petbuild PKGNAME, then build using 01mickos petbuild
      BUILDSCRIPT="$(find /usr/share/petbuild -iname "${PKGNAME}*.petbuild"| grep -m1 "$PKGNAME")"

      # if we got a build script
      if [ -f "$BUILDSCRIPT" ];then
        (
        cd "$(dirname "$BUILDSCRIPT")" || exit
        # compile the pkg
        PKG_CONFIGURE="$PKG_CONFIGURE" PKG_CFLAGS="$PKG_CFLAGS" bash ./*.petbuild
        # after build, move any pets created to WORKDIR
        mv /usr/share/petbuild/0pets_out/*.pet "$WORKDIR" 2>/dev/null
        # back to prev dir (WORKDIR)
        cd - || exit
        )
      fi

      # if build script not found, exit
      [ ! -f "$BUILDSCRIPT" ] && echo "Build script for '$PKGNAME' not found in /usr/share/petbuild/" && exit 1

      # get the packages we just moved to WORKDIR
      PKGFILES="$(find "$WORKDIR" -iname "$PKGNAME*.pet")"

      # list any packages we just built
      [ "$PKGFILES" != '' ] && echo -e "${green}Success:${endcolour} Packages in $WORKDIR:" && echo "$PKGFILES"
    ;;

    buildpet) # by Tman/iguleder

      # exit if buildpet dir not found
      [ ! -d /usr/share/buildpet ] && error "buildpet not installed." && exit 1

      # buildpet expects a PKGNAME, or exit
      [ ! "$1" ] || [ "$1" = "-" ] && print_usage pkg-build && exit 1

      # get pkg name (with version), no extension or path
      PKGNAME="$(basename "$1" .$EX)"

      # get the buildpet script of PKGNAME
      BUILDSCRIPT="$(find /usr/share/buildpet/ -name "$PKGNAME*")"

      # if build script not found, exit
      [ ! -f "$BUILDSCRIPT" ] && echo "Build script for '$PKGNAME' not found in /usr/share/buildpet/" && exit 1

      # now compile the package
      PKG_CONFIGURE="$PKG_CONFIGURE" PKG_CFLAGS="$PKG_CFLAGS" buildpet $BUILDSCRIPT

    ;;

    src2pkg)  # by amigo

      ### This code is a horribly simple wrapper to a great tool..
      ### Implement all src2pkg options here at some point..
      ##
      ### We should pass all options to src2pkg, and make it build a
      ### (petbuild|buildpet) buildscipt on successful compile

      # exit if src2pkg not installed
      [ "$(which src2pkg)" = '' ] && error "src2pkg not installed." && error "Get it from http://distro.ibiblio.org/amigolinux/download/src2pkg/src2pkg-3.0-noarch-2.txz" && exit 3

      # exit if $1 not given or valid
      [ ! "$1"  ] || [ "$1" = "-" ]   && print_usage pkg-build && exit 1

      # show src2pkg help if user supplied any of the help options
      if [ "$1" = '-h'  ] || [ "$1" = '-hh'  ] || [ "$1" = '--help' ] || [ "$1" = '--more-help' ] || [ "$1" = '--list' ];then
        src2pkg $1 | sed -e "s/  src2pkg /  $SELF -pb /g"
        echo -e "\n   See 'src2pkg' by amigo"
        exit 0
      fi

      # use amigos src2pkg
      src2pkg $1

      # if src2pkg exited without error, copy any pets it made to WORKDIR
      [ $? -eq 0 ] && mv /tmp/*.pet "$WORKDIR" 2>/dev/null

    ;;

    sbopkg)   # slackware peeps

      # exit if not installed
      [ "$(which sbopkg)" = '' ] && error "Sbopkg not installed." && exit 3

      # exit if no valid options
      [ ! "$1" ] || [ "$1" = "-" ]  && print_usage pkg-build && exit 1

      sbopkg -b "$1"

      # move any built pkgs to WORKDIR.. need a better way to do this
      if [ "$(find /tmp/* -iname "$1*.t*")" != '' ];then
        mv /tmp/*.tgz "$WORKDIR" 2>/dev/null
        mv /tmp/*.txz "$WORKDIR" 2>/dev/null
        mv /tmp/*.tar.xz "$WORKDIR" 2>/dev/null
        mv /tmp/*.tar.zst "$WORKDIR" 2>/dev/null
        echo -e "DONE... The package should be in $WORKDIR."
      fi

    ;;

  *)
    # get pkg name only, no extension or path
    PKGNAME="$(basename "$1" .$EX)"

    echo "Cannot compile '$PKGNAME', no build system installed."
    echo
    echo "Please install one of the following:"
    echo " * petbuild by 01micko: http://murga-linux.com/puppy/viewtopic.php?t=96027"
    echo " * buildpet by Tman:    http://murga-linux.com/puppy/viewtopic.php?t=81056"
    echo " * src2pkg  by amigo:   http://distro.ibiblio.org/amigolinux/download/src2pkg/"
    echo " * sbopkg   by various: https://www.sbopkg.org/downloads.php"
    echo
    echo "Then set BUILDTOOL to either petbuild, buildpet, src2pkg or sbopkg "
    echo "in $PKGRC to enable building packages from source."
    echo
    echo "NOTE:"
    echo "01mickos petbuild should be installed to /usr/share/petbuild"
    echo "And Tmans buildpet should be installed to /usr/share/buildpet"
  ;;
  esac

  # run any relevant plugins
  ASK=$PLUGIN_ASK FORCE=$FORCE run_plugins 'post_build'

}


pkg_repack(){                     # create package ($1) from its *.files list FUNCLIST

  # exit if no valid options
  [ ! "$1" ] || [ "$1" = "-" ] && print_usage pkg-repack && exit 1

  local list=''
  local pkg_ext=''
  local PKGNAME=''
  local PKGNAME_ONLY=''
  local dir=''
  local build_number=''

  # get pkg extension
  pkg_ext=$(get_pkg_ext "$1")

  #get pkg name only, no extension or path
  PKGNAME="$(LANG=C basename "$1" .$pkg_ext)"

  # don't rely on the given pkg name string, get the full name from repo if poss
  PKGNAME=$(get_pkg_name "$PKGNAME")

  # if the list is empty, pkg is not user installed or built in, cant show contents
  [ "$(is_installed_pkg "$PKGNAME")" = false ] && echo "$PKGNAME needs to be installed." && exit 1

  # assume the file name from $1
  PKGFILE="${CURDIR}/${PKGNAME}.$pkg_ext"

  [ ! -f "${PKGFILE}" ] && PKGFILE="${CURDIR}/$(get_pkg_filename "$PKGNAME")"

  # get pkg name without version
  PKGNAME_ONLY="$(get_pkg_name_only "${PKGNAME}")"

  # if the package to built already exists, ask user to delete it
  [ -f "${PKGFILE}" ] && echo "$PKGNAME.$pkg_ext already exists in $CURDIR" && rm -f "${PKGFILE}" 2>/dev/null

  # if pkg exists, user didn't delete it
  [ -f "${PKGFILE}" ] && exit 0

  # get the build number, and increment by one
  build_number="$(grep -m1 "^$PKGNAME|$PKGNAME_ONLY|" ${REPO_DIR}/user-installed-packages ${REPO_DIR}/woof-installed-packages ${REPO_DIR}/devx-only-installed-packages ${REPO_DIR}/Packages-* | cut -f4 -d'|')"
  build_number=${build_number:-0}
  build_number="-$(($build_number + 1))"

  # process the file list, copy each file to our pkg folder
  pkg_contents "$PKGNAME" | while read line
  do
    if [ -f "$line" ]; then
      linedir="$(dirname "${line}")"
      [ ! -d "${CURDIR}/$PKGNAME/${linedir}" ] && mkdir -p "${CURDIR}/$PKGNAME/${linedir}"
      cp -p -P "$line" "${CURDIR}/${PKGNAME}/${linedir}"
    fi
  done

  sync

  # make sure we populated a pkg folder, ready to package up
  [ ! -d "${CURDIR}/${PKGNAME}/" ] && error "No '$PKGNAME' directory in $CURDIR" && exit 5

  # pkg folder should be populated, now package it up and print final msg
  dir2pet "${CURDIR}/${PKGNAME}/" "$build_number"
  rm -rf "${CURDIR:-?}/${PKGNAME}/" 2>/dev/null
  rm -rf "${CURDIR:-?}/${PKGNAME}$build_number/" 2>/dev/null
  sync
}


pkg_unpack(){                     # extract/unpack $1 to current dir FUNCLIST

  # exit if not valid usage
  [ ! -f "$1" ] && print_usage unpack && exit 1

  local PKGNAME
  local PKGFILE
  local PKGEXT
  local comp

  # get pkg details
  PKGFILE="$1"
  PKGNAME=$(get_pkg_name "$PKGFILE")
  PKGEXT=$(get_pkg_ext "$PKGFILE")

  # exit if we dont have enough info
  [ "$PKGEXT" = '' ]  && error "Cant get package extension" && exit 1
  [ ! -f "$PKGFILE" ] && error "Cant find $1" && exit 6
  [ "$PKGNAME" = '' ] && error "Cant get PKGNAME" && exit 3

  # support overriding the output dir with $2
  if [ "$2" != "" ];then
    PKGNAME="$2"
  fi

  # determine compression utility
  case $PKGEXT in

    deb)
      mkdir "$PKGNAME" 2>/dev/null
      rm -rf "${PKGNAME:-?}"/* 2>/dev/null
      dpkg-deb -x "$PKGFILE" "$PKGNAME"    # extracts main pkg contents
      result=$?
      dpkg-deb -e "$PKGFILE" "$PKGNAME"/DEBIAN # extracts deb control files
      if [ $result -eq 0 ];then
        echo -e "${green}Extracted${endcolour}: ${magenta}$(basename $PKGFILE)${endcolour}"
      else
        error -e "${red}Error${endcolour}: Cannot extract $PKGFILE"
      fi
      return $result
      ;;

    rpm)
      mkdir "${PKGNAME}" 2>/dev/null
      rm -rf "${PKGNAME:-?}"/* 2>/dev/null
      # create dir called $PKGNAME, cd into it, extract the rpm in there
      cp "$PKGFILE" "$PKGNAME/"
      cd "$PKGNAME" 1>/dev/null || exit 1
      # now extract the rpm contents into current dir
      rpm2cpio "$PKGFILE" | cpio -idmu &>/dev/null
      result=$?
      # clean up and leave
      rm -f ./*.rpm 2>/dev/null
      cd - 1>/dev/null || exit 1
      # final msg
      if [ $result -eq 0 ];then
        echo -e "${green}Success${endcolour}: File ${magenta}$(basename $PKGFILE)${endcolour} extracted."
      else
        error "Cannot extract $PKGFILE"
      fi
      return $result
      ;;

    sfs)

      mkdir "/${PKGNAME}" 2>/dev/null
      rm -rf "${PKGNAME:-?}"/* 2>/dev/null
      # make mnt dir, mount sfs
      mkdir "/mnt/${PKGNAME}" 2>/dev/null
      mount -t squashfs "$PKGFILE" /mnt/"$PKGNAME" -o loop 1>/dev/null || \
      {
        error "Could not mount $PKGFILE"
        exit 3
      }
      # copy sfs contents into ./$PKGNAME
      cp -a -Rf --remove-destination /mnt/"$PKGNAME" "$PKGNAME" || \
      {
        error "Failed copying files from /mnt/$PKGNAME to ./$PKGNAME"
        exit 4
      }
      result=$?
      # clean up
      umount "/mnt/${PKGNAME}"
      rmdir "/mnt/${PKGNAME}"
      # final msg
      if [ $result -eq 0 ];then
        echo -e "${green}Success${endcolour}: File ${magenta}$(basename $PKGFILE)${endcolour} extracted."
      else
        error "Cannot extract $PKGFILE"
        exit 7
      fi
      return $result
      ;;
    pet)  file -b "$PKGFILE" | grep -i -q "^xz" && comp=xz || comp=gzip ;;
    bz2)  comp=bzip2 ;;
    gz)   comp=gzip ;;
    lzma) comp=lzma ;;
    tbz)  comp=bzip2 ;;
    tgz)  comp=gzip ;;
    tlz)  comp=lzma ;;
    txz)  comp=xz ;;
    tzst) comp=zstd ;;
    xz)   comp=xz ;;
    zst) comp=zstd ;;
  esac
  sync

  # if pkg is extractable with tar, then unpack
  case $PKGEXT in
  pet|gz|tbz|bz2|lzma|tlz|tgz|txz|tzst|xz|zst)
    (
      umask 000
      # shellcheck disable=SC2002
      cat "$PKGFILE"            \
        | $comp -dc 2>/dev/null \
        | tar -xf - 2>/dev/null \
      && echo -e "${green}Success${endcolour}: File ${magenta}$(basename $PKGFILE)${endcolour} extracted." \
      || error "Cannot extract $PKGFILE"
    )
    ;;
  esac

  # return
  return ${result:-0}

}


pkg_combine(){                    # combine a pkg ($1) and deps into one single pkg FUNCLIST

  # exit if no valid options
  [ ! "$1" ] || [ "$1" = "-" ] && print_usage pkg-combine && exit 1

  . ${PKGRC}

  local EX=''
  local PKGNAME=''
  local PKGNAME_ONLY=''
  local PKG_FILENAME=''
  local PKG_FILE=''
  local ALL_DEPS=''
  local PKG_DEPLIST=''
  local SUFFIX="${CP_SUFFIX}"
  local BUILD_DIR=$TMPDIR/build_pkg
  local SFS_FILE
  local please_wait=false
  local PREVDIR="$CURDIR"
  local ask_opt=$ASK
  local force_opt=$FORCE

  # get pkg extension
  EX=$(get_pkg_ext "$1")

  # get reliable package names
  PKGNAME="$(basename "$1" .$EX)"
  PKGNAME=$(get_pkg_name "$PKGNAME")
  PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")

  PKG_FILE="${WORKDIR}/${PKGNAME}.$EX"

  # we want to include all deps, except builtins, by default
  # we dont set HIDE_BUILTINS here, we leave that up to user
  # when user gives -F, HIDE_BUILTINS= false, and builtin
  # pkgs will be included in the package created
  FORCE=true
  HIDE_USER_PKGS=false

  # get full pkg filename (inc name-ver.ext).. try repos first
  PKG_FILENAME="$(get_pkg_filename "$PKGNAME")"
  # then WORKDIR if needed (dont include the combined pkgs)
  if [ "$PKG_FILENAME" = "" ];then
    PKG_FILENAME="$(find "$WORKDIR" -type f -name "$PKGNAME*" \
      | grep -v "${SUFFIX}"     \
      | grep -v ".sfs\$"        \
      | grep -m1 "^$PKGNAME")"
    PKG_FILENAME="$(basename "$PKG_FILENAME")"
  fi
  # just in case its empty, revert back to the earlier PKGNAME value
  [ "$PKG_FILENAME" = "" ] && PKG_FILENAME="$PKGNAME"

  [ "$PKG_FILENAME" = "" ] && error "Cant find $1" && exit 1

  # update PKGFILE with new pkg filename (PKG)
  PKG_FILE="${WORKDIR}/${PKG_FILENAME}"

  # check if the desired file has already been built
  [ "$COMBINE2SFS" = true ] && final_ext=sfs || final_ext=pet
  if [ -f "${WORKDIR}/${PKGNAME}-${SUFFIX}.$final_ext" ];then
    echo -e "File ${magenta}${WORKDIR}/${PKGNAME}-${SUFFIX}.${final_ext}${endcolour} already exists."
    return
  fi

  # get list of deps for PKGNAME, if no deps, exit
  PKG_DEPLIST="$(FORCE=$force_opt list_deps $PKGNAME_ONLY)"
  [ "$PKG_DEPLIST" = "" ] && echo "No need to combine, $PKGNAME has no dependencies." && exit 1

  # if exact match of pkgname is found in a repo list
  if [ "$(is_repo_pkg "$PKGNAME")" = true ];then

    echo "Please wait.. Gathering dependency information."

    # get the deps of the pkg, but dont install
    FORCE=$force_opt find_deps "$PKGNAME"
    ALL_DEPS="$(cat $TMPDIR/deps_installed $TMPDIR/deps_missing 2>/dev/null | sort -u)"

    # download the needed package
    if [ ! -f "$PKG_FILE" ] || [ "$FORCE" = true ];then
      ASK=false pkg_download "$PKGNAME"
    fi

    # make work dirs
    cd "$WORKDIR" || exit 1
    mkdir -p "$BUILD_DIR/"
    mkdir -p "$BUILD_DIR/${PKGNAME}-${SUFFIX}"

    if [ -f "$PKG_FILE" ];then
      # copy the main pkg to the tmp dir
      # and remove the downloade file, we no longer need it
      cp "$PKG_FILE" "$BUILD_DIR/" 2>/dev/null && rm "$PKG_FILE"
    else
       error "Could not add the main package '$PKGNAME_ONLY'"
    fi


    # make a cleaned list to go over (sanity check)
    ALL_DEPS_LIST="$(echo "$ALL_DEPS" | tr ',' '\n' | grep -v "^\$" | sort -u)"

    # go through each dep listed
    echo "$ALL_DEPS_LIST" | while read LINE
    do

      [ "$LINE" = "" ] || [ "$LINE" = "-" ] || [ "$LINE" = " " ] && continue

      [ "$(is_blacklisted_pkg "$LINE")" = true ] && continue

      # only include builtins if HIDE_BUILTINS=true
      [ "$(is_builtin_pkg "$LINE")" = true ] && [ "$HIDE_BUILTINS" = true ] && continue

      # only include devx pkgs if user gave the -f option
      [ "$(is_devx_pkg "$LINE")" = true ] && [ "$force_opt" = false ] && continue

      # download the matching package(s)
      [ "$(list_downloaded_pkgs "$LINE")" = "" ] && ASK=false pkg_download "$LINE"

      # get the downloaded file
      PKGDEP="$(find "$WORKDIR" -maxdepth 1 -type f -name "${LINE}*" | grep -v ".sfs\$" | grep -v "${SUFFIX}" | head -1)"

      # re-try download in other repos if needed
      if [ ! -f "$PKGDEP" ];then
        OLDPKGREPO=$PKGREPO
        PKGREPO="$(LANG=C which_repo $LINE | cut -f2 -d' ' | head -1)"
        [ "$PKGREPO" != "" ] && ASK=false pkg_download "$LINE"
        PKGREPO=$OLDPKGREPO
      fi

      #if downloaded
      if [ -f "$PKGDEP" ] || [ "$FORCE" = true ];then

        # copy dep to the tmp dir, with the main pkg
        if [ ! -f "$BUILD_DIR/$PKGDEP" ];then
          cp "$PKGDEP" "$BUILD_DIR/$(basename $PKGDEP)" && rm "$PKGDEP"
        else
          error "Cannot copy $PKGDEP to $BUILD_DIR/$(basename $PKGDEP)"
        fi

      else # dep not found, may be missing, or in another repo
        echo -e "${yellow}Warning:${endcolour} $LINE not downloaded to $WORKDIR.. Cannot add $LINE.."
        continue
      fi
    done

    # we should now be ready to make our combined pkg
    cd "$BUILD_DIR" || exit 1

    PARENTPKG=${PKGNAME}

    # for all pkgs in the tmp dir (not including any 'combined' pkgs)
    TMP_PKGS="$(find "$BUILD_DIR/" -maxdepth 1 -type f -name "*" | grep -v $SUFFIX | grep -v ^$ | grep -v ' ' | sort -u)"

    local count=1

    for i in $TMP_PKGS
    do
      # skip if not a valid pkg file
      [ -z "$i" ] || [ "$i" = ' ' ] || [ ! -f "$i" ] && continue

      # dont include the combined pkgs
      [ "$(echo "$i" | grep -m1 "${SUFFIX}")" != "" ] && continue

      # get the extensions of each file .. they might be from different repos, so cant use $EX
      base="$(basename "$i" 2>/dev/null)"
      FILE_EXT=$(get_pkg_ext "$base")
      if [ ! "$FILE_EXT" ] || [ "$FILE_EXT" = ' ' ] || [ "$FILE_EXT" = '' ];then
        error "Skipping $i: could not get extension"
        continue
      fi

      # get name without version for this pkg ($base is name without extension)
      name_only=$(get_pkg_name_only "$base")
      if [ ! "$name_only" ] || [ "$name_only" = ' ' ] || [ "$name_only" = '' ];then
        error "Skipping $i: could not get package name"
        continue
      fi

      if [ "$(is_blacklisted_pkg "$name_only")" = true ];then
        continue
      fi

      # ask to add package if --ask was given
      CONFIRM=y
      if [ "$ask_opt" = true ];then
        echo -n "Add package: $name_only  ($FILE_EXT)  (y/N):  "
        read -n 1 CONFIRM </dev/tty
        echo
      else
        echo "Adding package: $name_only  ($FILE_EXT)"
      fi

      # skip pkg if user wants to skip it
      if [ "$CONFIRM" != 'y' ];then
        rm "${i:-?}" &>/dev/null
        continue
      fi

      # add each file
      case $FILE_EXT in
      pet)

        # convert and extract
        pkg_unpack "${i}" 1>/dev/null
        sync

        # copy extracted contents (only the stuff inside the extracted folders)
        if [ ! -d "${i/.pet/}/" ];then
          error "Dir '${i/.pet/}/' does not exist"
        fi
        cp -a --preserve=all -fr -L "${i/.pet/}/"* "${PARENTPKG}-${SUFFIX}/"

        if [ -f "${i/.pet/}/pinstall.sh" ];then
          mv "${i/.pet/}/pinstall.sh" "${PARENTPKG}-${SUFFIX}/pinstall_${count}.sh"
        fi

        # now remove the pet and extract folder
        rm "${i:-?}"
        # shellcheck disable=SC2115
        rm -rf "${i/.pet/}/"
        sync
        ;;

      deb)

        pkg_unpack "$i" 2>$TMPDIR/$SELF-cp-errlog
        sync

        dpkg-deb -e "$i" "$BUILD_DIR/${PARENTPKG}-${SUFFIX}/DEBIAN"

        local pkg_dir="${i/.deb/}/"

        if [ ! -d "$pkg_dir" ];then
          needle="$(get_pkg_name "$i")"
          pkg_dir="$(find "${BUILD_DIR}" -type d -iname "$needle" | head -1)"
        fi

        # .deb package names often have extra stuff at the end of the file name
        # that does not exist in the root folder name, inside the package.. so
        # we need to strip off that extra stuff to get the correct unpacked
        # package dir
        if [ ! -d "$pkg_dir" ];then
          pkg_dir=$(strip_package_filename "$pkg_dir")
        fi

        if [ ! -d "$pkg_dir" ];then
          # the folders unpacked do not always match $PKGNAME, so look for it
          pkg_dir_FIRST5CHARS=$(echo "${pkg_dir:0:5}")
          pkg_dir=$(find "$BUILD_DIR" -maxdepth 1 -type d -name "$pkg_dir_FIRST5CHARS*" | sed 's#.*/##g')
        fi

        if [ ! -d "$pkg_dir" ];then
          error "Dir '$pkg_dir' does not exist!"
        fi

        # copy extracted contents (only the stuff inside the extracted folders)
        cp -a --preserve=all -fr -L "${pkg_dir}/"* "${PARENTPKG}-${SUFFIX}/"

        # move the post install of this package into dir of new combined package
        if [ -f "${pkg_dir}DEBIAN/postinst" ];then
          mv "${pkg_dir}DEBIAN/postinst" "${PARENTPKG}-${SUFFIX}/DEBIAN/postinst_${count}"
        fi

        # move the pre install of this package into dir of new combined package
        if [ -f "${pkg_dir}DEBIAN/preinst" ];then
          mv "${pkg_dir}DEBIAN/preinst" "${PARENTPKG}-${SUFFIX}/DEBIAN/preinst_${count}"
        fi

        # now remove the deb and extracted folder
        rm "${i:-?}"
        # shellcheck disable=SC2115
        rm -rf "$pkg_dir"
        sync
        ;;

      *tgz|*txz|*tar.gz|*tar.xz|*tar.zst|*tzst|*xz|*gz)

        pkg_unpack "$i" 1>/dev/null
        sync

        # now copy $BUILD_DIR/$PKGNAME/* into our output (combined pkg) dir
        cp -a --preserve=all -fr -L "${name_only}/"* "${PARENTPKG}-${SUFFIX}/" || error "Dir '${name_only}/' does not exist!"

        # move the pre install of this package into dir of new combined package
        if [ -f "${PARENTPKG}-${SUFFIX}/install/doinst.sh" ];then
          mv "${PARENTPKG}-${SUFFIX}/install/doinst.sh" "${PARENTPKG}-${SUFFIX}/install/doinst_${count}.sh"
        fi

        # remove the package and folder we just extracted
        rm "${i:-?}"
        # shellcheck disable=SC2115
        rm -rf "${i/.*/}/"
        sync
        ;;

      rpm)
        pkg_unpack "$i" 1>/dev/null
        sync

        # now copy $BUILD_DIR/$PKGNAME/* into our output (combined pkg) dir
        cp -a --preserve=all -fr -L "${name_only}/"* "${PARENTPKG}-${SUFFIX}/"

        # move the pre install of this package into dir of new combined package
        if [ -f "${PARENTPKG}-${SUFFIX}/install/doinst.sh" ];then
          mv "${PARENTPKG}-${SUFFIX}/install/doinst.sh" "${PARENTPKG}-${SUFFIX}/install/doinst_${count}.sh"
        fi

        # remove the package and folder we just extracted
        rm "${i:-?}"
        # shellcheck disable=SC2115
        rm -rf "${i/.rpm/}/"
        ;;

      esac
      count=$(($count + 1))
    done

    # we have now unpacked the package, lets combine the pre/post install scripts
    # into one pinstall.sh script

    local pinstall_file="$BUILD_DIR/${PARENTPKG}-${SUFFIX}/pinstall.sh"

    # append this pinstall/postinst/doinst script to a new pinstall.sh
    if [ ! -f $pinstall_file ];then
      echo '#!/bin/sh' > "$pinstall_file"
      echo 'set -e'   >> "$pinstall_file"
    fi

    # concat the post install scripts (for puppy, slackware, arch, debian/ubuntu, etc) into 'pinstall.sh'
    for i in ${PARENTPKG}-${SUFFIX}/pinstall_* ${PARENTPKG}-${SUFFIX}/install/doinst_* ${PARENTPKG}-${SUFFIX}/DEBIAN/postinst_* ${PARENTPKG}-${SUFFIX}/DEBIAN/preinst_*
    do
      # not all packages have these post install files, so skip if its not there
      [ ! -f ${i} ] && continue
      # if we have a post or preinstall script, append it to pinstall.sh
      (
        # process into a pinstall file:
        # - change /usr/bin/foo to usr/bin/foo
        # - remove exits
        grep -vE '^#!|^set \-e|^exit|exit 0|exit 1' ${i} \
          | sed \
            -e "s# /bin# bin#g" \
            -e "s# /etc# etc#g" \
            -e "s# /lib# lib#g" \
            -e "s# /lib32# lib32#g" \
            -e "s# /lib32# lib32#g" \
            -e "s# /lib64# lib64#g" \
            -e "s# /opt# opt#g" \
            -e "s# /sbin# sbin#g" \
            -e "s# /usr# usr#g" \
            -e "s# /var# var#g" >> "$pinstall_file"

        echo '' >> "$pinstall_file"
        # we have combined the pre/post install stuff in $i into a new,
        # combined file, so remove the original
        rm -f ${i}
      )
    done

    if [ -f $BUILD_DIR/${PARENTPKG}-${SUFFIX}/pinstall.sh ];then
      chmod +x $BUILD_DIR/${PARENTPKG}-${SUFFIX}/pinstall.sh
    fi
    # remove any debian/ubuntu/slackware pre/post install stuff left in the package
    rm -rf $BUILD_DIR/${PARENTPKG}-${SUFFIX}/pinstall_*
    rm -rf $BUILD_DIR/${PARENTPKG}-${SUFFIX}/install
    rm -rf $BUILD_DIR/${PARENTPKG}-${SUFFIX}/DEBIAN

    # fix the symlinks to lib dirs - the linux-gnu-* dirs are symlinks in puppy,
    # so make sure we dont replace them with dirs (or programs won't load)
    for libdir in i386-linux-gnu i486-linux-gnu i586-linux-gnu i686-linux-gnu amd64-linux-gnu
    do
      if [ -d $BUILD_DIR/${PARENTPKG}-${SUFFIX}/usr/lib/${libdir}/ ];then
        mv -n -u $BUILD_DIR/${PARENTPKG}-${SUFFIX}/usr/lib/${libdir}/* $BUILD_DIR/${PARENTPKG}-${SUFFIX}/usr/lib/
        (
          cd $BUILD_DIR/${PARENTPKG}-${SUFFIX}/usr/lib || exit 1
          rmdir ${libdir:-?}/ && ln -s ${libdir}/ .
        )
      fi
    done

    # now we are ready to build our combined pkg
    [ "$PWD" != "$BUILD_DIR" ] && { cd "$BUILD_DIR/" || exit 1; }


    # if not building SFS, build a .pet
    if [ "$COMBINE2SFS" = false ];then #240613
      echo "Building PET package.. Please wait.."

      # build pet package... start with $removing PKGNAME-${SUFFIX}.pet.specs
      rm ${PKGNAME}-${SUFFIX}/*.specs 2>/dev/null

      # get compression type
      file -b "${PKGNAME}-${SUFFIX}" | grep -i -q "^xz" && TAREXT=xz || TAREXT=gz

      # tar up the folder
      tar -c -f ${PKGNAME}-${SUFFIX}.tar ${PKGNAME}-${SUFFIX} &>/dev/null
      sync

      case $TAREXT in
        xz)xz -z -9 -e ${PKGNAME}-${SUFFIX}.tar ;;
        gz)gzip --best ${PKGNAME}-${SUFFIX}.tar ;;
      esac

      TARBALL="${PKGNAME}-${SUFFIX}.tar.$TAREXT"
      FULLSIZE="$(stat --format=%s ${TARBALL})"
      MD5SUM="$(md5sum $TARBALL | cut -f 1 -d ' ')"
      echo -n "$MD5SUM" >> $TARBALL
      sync

      mv -f $TARBALL ${PKGNAME}-${SUFFIX}.pet
      sync

      if [ $? -eq 1 ];then
        echo "Cannot create PET file ${PKGNAME}-${SUFFIX} from dir."
        error "Please check $PWD"
      fi

      # move our new PET to $WORKDIR
      mv ${PKGNAME}-${SUFFIX}.pet $WORKDIR/${PKGNAME}-${SUFFIX}.pet
      # get the size
      s=$(LANG=C du -m "$WORKDIR/${PKGNAME}-${SUFFIX}.pet" | sed "s/\s.*//")

    else #240613  build a .sfs
      echo "Building SFS package.. Please wait.."

      dir2sfs "${PKGNAME}-${SUFFIX}" 1>/dev/null

      # get the full file name, it may (or not) have been appended with '-DISTRO_VERSION'
      SFS_FILE=$(find . -maxdepth 1 -type f -name "*${PKGNAME}*-${SUFFIX}*.sfs" | head -1)

      s=$(LANG=C du -m "${SFS_FILE}" | sed "s/\s.*//")
      MD5SUM=$(md5sum "$SFS_FILE" | cut -f1 -d ' ')
      mv "$SFS_FILE" "$WORKDIR/"
    fi

    # done, go back to work dir from WORKDIR/build_pkg
    cd "$WORKDIR" || exit 1
    rm -R  "${BUILD_DIR:-?}/" 2>/dev/null

    # create install command
    if [ "$COMBINE2SFS" = false ];then
      PKGEXT=pet
      PKGCMD="Install command: $SELF install ${WORKDIR}/${PKGNAME}-${SUFFIX}"
    else
      PKGEXT=sfs
      PKGCMD="Install command: sfs_load --cli -q \"${WORKDIR}/$(basename $SFS_FILE)\""
    fi

    #226013 updated output
    echo -e "Created package ${magenta}${PKGNAME}-${SUFFIX}.${PKGEXT}${endcolour} (${s}MB)"
    echo "The md5 checksum: $MD5SUM"
    echo "$PKGCMD"

  else # no exact PKGNAME match in repo
    not_found "${PKGNAME}"
    exit 1
  fi

  cd "$PREVDIR" || exit 1
}


merge_pkg(){                      # merge the given comma-separated packages FUNCLIST
  # make sure at least 2 packages exist

  [ ! "$1" ] && print_usage merge && exit 1
  [ "$(echo "$1" |grep ',')" = "" ] && print_usage merge && exit 1

  cd "$WORKDIR" 1>/dev/null || exit 1

  local PKG_LIST="$(echo "${1}" | tr ',' '\n' | sort -u)"
  local SUFFIX='' WITH_DEPS='' SPLIT_PKG=''

  # process options
  for opt in "$@"
  do
    if [ "$opt" = '--with-deps' ];then
      WITH_DEPS=true
    fi
    if [ "$opt" = '--split' ];then
      SPLIT_PKG=true
    fi
  done

  if [ "$WITH_DEPS" = true ];then
    SUFFIX="-WITHDEPS"
    echo "Gathering dependencies to include.."
    echo
    # add deps of pkgs to list of pkgs to merge
    for package in $PKG_LIST
    do
      PKG_LIST="$PKG_LIST $(list_deps "$package")"
    done
    PKG_LIST="$(echo "$PKG_LIST" | tr ' ' '\n' | sort -u)"

    # strip out local file names, keep only PKGNAME_ONLY
    PKG_LIST="$(for package in $PKG_LIST
    do
      pkgname=$(get_pkg_name "$(basename "$package")" 2>/dev/null)
      if [ "$(is_blacklisted_pkg "$pkgname")" = true ];then
        continue
      fi
      echo $pkgname
    done | sort -u | grep -v ^$)"
  fi

  echo "Merging the following packages:"
  echo
  echo "${PKG_LIST}" | sed 's/^/  /g'
  echo

  # get a new package name for the new, merged package
  local PKGNAME="$(get_pkg_name "$(basename "${1//,*/}")" 2>/dev/null)"
  bash -c 'read -e -r -p "Enter a package name and hit ENTER: " -i "${PKGNAME}-MERGED${SUFFIX}" NEWPKGNAME; echo $NEWPKGNAME > /tmp/pkg/NEWPKGNAME'
  echo
  NEWPKGNAME="$(cat /tmp/pkg/NEWPKGNAME)"

  if [ "$NEWPKGNAME" = "" ];then
    echo "You must give a new package name!"
    return 1
  fi

  rm -rf "${NEWPKGNAME:-?}/" &>/dev/null
  mkdir "${NEWPKGNAME}"

  # remove any old folders
  rm -rf ${WORKDIR:-?}${NEWPKGNAME}/ &>/dev/null

  # for each package to merge
  for package in $PKG_LIST
  do

    # get the package details
    local PKGNAME="$(get_pkg_name "$(basename "$package")" 2>/dev/null)"
    local PKGNAME_ONLY="$(get_pkg_name_only "$PKGNAME" 2>/dev/null)"
    local PKGEXT="$(get_pkg_ext "$PKGNAME")"
    local PKGFILE=''

    [ "$PKGNAME" = ""  ] && continue
    [ "$PKGNAME" = " " ] && continue
    [ "$PKGNAME" = "-" ] && continue

    # download it
    pkg_download "$PKGNAME" || \
    {
      echo -e "${yellow}Warning${endcolour}: package '$PKGNAME' not downloaded."
      continue
    }

    # get the downloaded file
    PKGFILE="$(find $WORKDIR -maxdepth 1 -type f -name "$(get_pkg_filename "$PKGNAME")")"

    [ ! -f "$PKGFILE" ] && \
      PKGFILE="$(find $WORKDIR -maxdepth 1 -type f -name "${PKGNAME}*${PKGEXT}")"

    [ ! -f "$PKGFILE" ] && \
      PKGFILE="$(find $WORKDIR -maxdepth 1 -type f -name "${PKGNAME_ONLY}_*${PKGEXT}")"

    [ ! -f "$PKGFILE" ] && \
      PKGFILE="$(find $WORKDIR -maxdepth 1 -type f -name "${PKGNAME_ONLY}-*${PKGEXT}")"

    if [ ! -f "$PKGFILE" ];then
      # the dep may not be in the repos (wings3d wants 'erlang-abi', for example)
      # in which case, it won't have been downloaded, so skip it in that case
      continue
    fi

    # unpack the downloaded file
    pkg_unpack "$PKGFILE"
    rm "${PKGFILE:-?}"

    # move the unpacked files into our new package dir
    PKGDIR="$(find $WORKDIR -maxdepth 1 -type d -name "${PKGNAME}*" | grep -v ${NEWPKGNAME})"

    if [ ! -d "$PKGDIR" ];then
      echo -e "${red}Error${endcolour}: could not find extracted package dir '$PKGDIR'"
      return 1
    fi

    cp -R "$PKGDIR"/* "$NEWPKGNAME"
    rm -rf "${PKGDIR:-?}/"
  done

  if [ ! -d "${WORKDIR}/$NEWPKGNAME" ];then
    echo -e "${red}Error${endcolour}: Dir ${lightblue}${NEWPKGNAME}${endcolour} NOT created!"
    return 1
  fi

  echo
  echo "Package contents:"
  find "${NEWPKGNAME}/"
  echo '--------------------------------'
  echo

  # create the merged PET package
  dir2pet "${NEWPKGNAME}/" || error "Could not create $NEWPKGNAME} PET file"

  rm -rf "./${NEWPKGNAME:-?}/" &>/dev/null
  rm -rf "${WORKDIR:-?}/${NEWPKGNAME:-?}/" &>/dev/null

  # get the filename of the new PET package
  NEWPKGFILENAME="$(find . -maxdepth 1 -type f -name "${NEWPKGNAME}*.pet")"

  # output messages
  if [ ! -f "$NEWPKGFILENAME" ];then
    echo
    echo -e "${red}Error${endcolour}: Package ${yellow}${NEWPKGFILENAME}${endcolour} NOT created!"
    return 1
  fi

  if [ "$SPLIT_PKG" = true ];then
    echo
    echo "Splitting package into separate EXE, DEV, DOC, NLS packages..."
    echo
    split_pkg "$NEWPKGFILENAME"
  fi

  return 0
}


split_pkg(){                      # split package ($1) into dev, doc, nls packages FUNCLIST

  # make sure the package exists
  [ ! "$1" ] || [ ! -f "$1" ] && print_usage split && exit 1

  local PKGNAME="$(get_pkg_name "$(basename "$1")" 2>/dev/null)"
  local PKGNAME_ONLY="$(get_pkg_name_only "$PKGNAME" 2>/dev/null)"
  local PKGEXT="pet"

  # get package extension
  PKGEXT="$(get_pkg_ext "$1")"

  pkg_unpack "$1" &>/dev/null

  # get the package directory we just extracted
  local PKG_PATH="$(find "$(dirname "$PKGNAME")" -maxdepth 1 -type d -iname "$PKGNAME" | head -1)"

  # get the full path to the package dir (dir with contents of pkg to be split)
  PKG_PATH="$(realpath "$PKG_PATH")"

  # make sure we have the right package dir
  [ ! -d "$PKG_PATH" ] && PKG_PATH="$(realpath "$PKGNAME")"

  # get the base name of the package directory
  local PKG_DIR_NAME=$(basename "$PKG_PATH")

  # get the package name
  local PKG_NAME="$PKGNAME_ONLY"

  # get the parent directory of the package
  local PARENT_DIR="$(dirname "$PKG_PATH")"

  # set the correct package naming style
  local dev_suffix='_DEV'
  local doc_suffix='_DOC'
  local nls_suffix='_NLS'
  if [ "${PKGEXT:-pet}" = "deb" ];then
    dev_suffix='-dev'
    doc_suffix='-doc'
    nls_suffix='-nls'
  fi

  # get the sub-package names
  local EXE_PKG="$PKGNAME"
  local DEV_PKG="$(echo "$PKG_DIR_NAME" | sed -e "s/^${PKGNAME_ONLY}/${PKGNAME_ONLY}${dev_suffix}/")"
  local DOC_PKG="$(echo "$PKG_DIR_NAME" | sed -e "s/^${PKGNAME_ONLY}/${PKGNAME_ONLY}${doc_suffix}/")"
  local NLS_PKG="$(echo "$PKG_DIR_NAME" | sed -e "s/^${PKGNAME_ONLY}/${PKGNAME_ONLY}${nls_suffix}/")"

  # remove the target package dirs if they already exist
  [ -d "$DEV_PKG" ] && rm -rf "$DEV_PKG"
  [ -d "$DOC_PKG" ] && rm -rf "$DOC_PKG"
  [ -d "$NLS_PKG" ] && rm -rf "$NLS_PKG"
  # now create them fresh and empty
  mkdir -p "$DEV_PKG"
  mkdir -p "$DOC_PKG"
  mkdir -p "$NLS_PKG"

  # make sure the package directory begins with the given package name
  case $(basename "$PKG_PATH") in
  	$PKG_NAME*)
  		;;
  	*)
  		echo "Error: $(basename "$PKG_PATH") must match $PKG_NAME"
  		print_usage split
  		exit 1
  		;;
  esac

  cd "$PKG_PATH" &>/dev/null || { echo "Not found: $PKG_PATH"; return 1; }

  local files_in_current_dir
  files_in_current_dir="$(find -mindepth 1)"

  for i in $files_in_current_dir
  do
  	# if the file no longer exists, skip this iteration
  	[ ! -e "$i" ] && continue

  	local FILE_NAME=$(basename "$i")

  	case "$FILE_NAME" in
  		*.la|*.a|*.o|*.prl|pkgconfig|include|*.m4|*.h|*.c|*.cpp)
  			PKGNAME="$DEV_PKG"
  			;;
  		gdb)
  			[ -d "$i" ] && PKGNAME="$DEV_PKG"
  			;;
  		dir)
  			[ -f "$i" ] && PKGNAME="$DOC_PKG"
  			;;
  		doc|*-doc|gtk-doc|Help|HELP|readme.*|README.*|ABOUT|about.txt|ABOUT.TXT|readme|README|manual|MANUAL|faq|FAQ|todo|TODO|examples|EXAMPLES|LessTif|man-html|E-docs)
  			PKGNAME="$DOC_PKG"
  			;;
  		help)
  			[ -d "$i" ] && PKGNAME="$DOC_PKG"
  			;;
  		man|info) # if it's a directory named "man" or "info", move to doc
  			[ -d "$i" ] && PKGNAME="$DOC_PKG"
  			 ;;
  		locale|locales|lang|strings) # if it's a directory named "locale", move to nls
  			[ -d "$i" ] && PKGNAME="$NLS_PKG"
  			;;
  		i18n|nls)
  			PKGNAME="$NLS_PKG"
  			;;
  		system.profile-*|*.strings|normal.awt-*) # AbiWord stores its locale information in those files
  			[ "$PKGNAME_ONLY" = "abiword" ] && PKGNAME="$NLS_PKG"
  			;;
  		*)
  			PKGNAME="$EXE_PKG"
  			;;
  	esac

  	# verbosity, output the redirection for each redirected file
  	case "$PKGNAME" in
  		$DEV_PKG|$DOC_PKG|$NLS_PKG)
  			#local SUFFIX="$(echo $SUFFIX | tr [:lower:] [:upper:])"

  			#echo "$FILE_NAME -> $PKG"

  			# detect the sub_directory inside the package
  			local SUB_DIR="${i%/$FILE_NAME}"
  			SUB_DIR="${SUB_DIR:2}"

  			# create the directory under the sub-package directory
  			mkdir -p "$PARENT_DIR/$PKGNAME/$SUB_DIR"

  			# move the file to the sub-package
  			mv "$i" "$PARENT_DIR/$PKGNAME/$SUB_DIR"

  			# get rid of empty directories in the EXE package
  			rmdir "$SUB_DIR" &>/dev/null
  			;;
  	esac

  done

  # if the EXE package is empty, remove it
  is_empty="$(find "$PKG_PATH" -maxdepth 2 -type f 2>/dev/null)"
  [ -z "$is_empty" ] && rm -rf "$PKG_PATH"

  # go back to where we started (where the main package lives)
  # shellcheck disable=SC2164
  [ -d "$CURDIR" ] && cd "$CURDIR" &>/dev/null

  # build each package from the package dir
  for dir in "$EXE_PKG" "$DEV_PKG" "$DOC_PKG" "$NLS_PKG"
  do
    if [ -d "$dir" ];then
      echo
      dir2${PKGEXT//./} "$dir" && rm -rf "$dir"
    fi
  done

  # get a list of the new packages we created
  new_pkgs="$(find . -maxdepth 1 -type f -name "${PKGNAME}*.$PKGEXT"
  find . -maxdepth 1 -type f -name "${DEV_PKG}*.$PKGEXT"
  find . -maxdepth 1 -type f -name "${DOC_PKG}*.$PKGEXT"
  find . -maxdepth 1 -type f -name "${NLS_PKG}*.$PKGEXT")"

  if [ "$new_pkgs" != "" ];then
    echo
    echo -e "${green}Success${endcolour}: Package split into these new files:"
    echo
    echo "$new_pkgs" | sed 's/^.\//  /'
  fi

  # cleanup
  [ -d "$DEV_PKG" ] && rm -rf "$DEV_PKG"
  [ -d "$DOC_PKG" ] && rm -rf "$DOC_PKG"
  [ -d "$NLS_PKG" ] && rm -rf "$NLS_PKG"

  return 0
}



# main pkg funcs

pkg_download(){                   # download a pkg ($1) to WORKDIR FUNCLIST

  # exit if no valid options
  [ ! "$1" ] || [ "$1" = "-" ] && print_usage download && exit 1

  . "${PKGRC}"

  local pkg_ext=''        # extension of pkg, empty if not a supported pkg ext
  local PKGNAME=''        # the pkgname with version
  local PKG_FILENAME=''   # package file name (field 8 of repo, with extension)
  local PKGFILE=''        # full path to package file
  local NET=''            # 1 or 0 if net connection available
  local curr_repo=''      # name of current repo in the loop
  local curr_repo_ext=''  # pkg ext for the current repo in the loop
  local curr_repo_url=''  # mirror that is used to download the pkg
  local pkg_in_repo=''    # true if pkg found in ANY repo, else false

  # the file with our repo URL info
  sources_file="${HOME}/.pkg/sources"

  # set download options
  [ "$FORCE" = true  ] && CONTINUE='' || CONTINUE='-c'
  [ "$ASK"  != true  ] && QTAG=''

  # get pkg extension
  pkg_ext=$(get_pkg_ext "$1")

  # get pkg name with version (if given!), no extension or path
  PKGNAME="$(basename "$1" .$pkg_ext)"
  # get full package name from given pkg name string .. vlc -> vlc-1.2.3-blah
  PKGNAME=$(get_pkg_name "$PKGNAME")

  # the file to save to.. not reliable till we checked the repos
  PKGFILE="${WORKDIR}/${PKGNAME}.$pkg_ext"
  [ ! -f "$PKGFILE" ] && PKGFILE="${WORKDIR}/$(get_pkg_filename "$PKGNAME")"

  #PKG_FNAME_GUESS="$PKGFILE"

  PKG_FILENAME="$(basename $PKGFILE)"

  if [ -z "${PKG_FILENAME}" ];then
    error "Cant find the package file name needed to download"
    return 1
  fi

  # skip if downloaded already, print msg
  [ -f "$PKGFILE" ] && [ "$FORCE" = false ] && DONE=true && echo -e "Already downloaded ${magenta}${PKG_FILENAME}${endcolour}" && return 0

  #if pkg not yet downloaded, or we are downloading all, or we are forcing downloads
  if [ ! -f "$PKGFILE" ] || [ "$NO_INSTALL" = true ] || [ "$FORCE" = true ];then

    # mark this pkg as not yet downloaded
    DONE=false

    PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")

    # exit if no internet connection
    #NET="`check_net`"; [ $NET -eq 1 ] && echo "You need an internet connection" && exit 2

    # for each repo, starting with current repo
    repo_file_list | while read repo_file
    do

      # get name of current repo in loop
      prev_repo="$curr_repo"
      curr_repo_info="$(LANG=C grep -m1 "|$repo_file|" "$sources_file" 2>/dev/null | cut -f1,2 -d'|')"
      curr_repo="${curr_repo_info/|*/}"
      curr_repo_ext="${curr_repo_info/*|/}"

      # check if $repo_file contains the given pkg
      pkg_in_this_repo="$(LANG=C cut -f1,2,7,8 -d'|' ${REPO_DIR}/$repo_file 2>/dev/null | grep -m1 "^${PKGNAME}|")"
      [ "$pkg_in_this_repo" = '' ] && pkg_in_this_repo="$(LANG=C cut -f1,2,7,8 -d'|' ${REPO_DIR}/$repo_file 2>/dev/null | grep -m1 "|${PKG_FILENAME}\$")"
      [ "$pkg_in_this_repo" = '' ] && pkg_in_this_repo="$(LANG=C cut -f1,2,7,8 -d'|' ${REPO_DIR}/$repo_file 2>/dev/null | grep -m1 "|${PKGNAME_ONLY}|")"

      # skip this repo if no exact match of package file found
      if [ -z "$pkg_in_this_repo" ];then
        continue
      fi

      # skip pings and download if already downloaded.. unless forcing download
      if [ -f "$PKGFILE" ] && [ "$FORCE" != true ];then
        DONE=true
        break
      fi

      # ask user to download
      echo -en "Download ${magenta}${PKGNAME_ONLY}${endcolour} from ${lightblue}${curr_repo}${endcolour} repo$QTAG:  "
      [ "$ASK" = true ] && read -n 1 CONFIRM </dev/tty || CONFIRM=y
      [ "$CONFIRM" != 'y' ] && echo

      # if user answered yes, we will now download the pkgs
      if [ "$CONFIRM" != "y" ];then #25073
        DONE=true
        break
      fi

      echo # start a new line

      # get the subdir (from repo line) that the package lives in
      sub_dir="$(echo "$pkg_in_this_repo" | cut -f3 -d'|' | sed 's/^\.//')"

      if [ "$sub_dir" = "." ];then
        sub_dir=''
      fi

      # make a space separated list of all our repo URLs ..
      # we also add a final /, fixing any double slashes
      curr_repo_url_list="$(LANG=C grep -m1 "|$repo_file|" $sources_file 2>/dev/null \
        | cut -f4,5,6,7 -d'|' \
        | tr '|' '\n'         \
        | sed                 \
          -e 's#\$#/#g'       \
          -e 's#//\$#/#g'     \
        | tr '\n' ' '         )"

      # update the ext to that of current repo
      pkg_ext="$curr_repo_ext"

      # get the best repo mirror
      #if [ "$prev_repo" != "$current_repo"  ] && [ -f $TMPDIR/curr_repo_url ] || [ ! -f $TMPDIR/curr_repo_url ];then
        #echo "Checking '$curr_repo' repo mirrors..."
        for URL in $curr_repo_url_list
        do
          [ -z "$URL" ] && continue
          [ "$URL" = '/' ] && continue
          [ "$URL" = '' ] && continue
          # add some system values into the repo URL (arch, distro version, etc.. from DISTRO_SPECS)
          URL="$(echo "$URL"| sed -e 's@${DBIN_ARCH}@'$DBIN_ARCH'@g')"
          URL="$(echo "$URL"| sed -e 's@${DISTRO_COMPAT_VERSION}@'$DISTRO_COMPAT_VERSION'@g')"
          URL="$(echo "$URL"| sed -e 's@${DDB_COMP}@'$DDB_COMP'@g')"
          URL="$(echo "$URL"| sed -e 's@${SLACKWARE}@'$SLACKWARE'@g')"
          URL="$(echo "$URL"| sed -e 's@${SLACKARCH}@'$SLACKARCH'@g')"
          URL="$(echo "$URL"| sed -e 's@${lxDISTRO_COMPAT_VERSION}@'$lxDISTRO_COMPAT_VERSION'@g')"
          #ping -W2 -c1 -q $(echo  "${URL}" | awk -F/ '{print $3}') &>/dev/null
          wget --quiet --timeout=2 --no-parent --spider "${URL}" &>/dev/null && \
          {
            # set the current URL
            curr_repo_url="$URL"
            if [ ! -z "$curr_repo_url" ];then
              echo "$curr_repo_url" > $TMPDIR/curr_repo_url
              break
            fi
          }
        done
      #else
      # curr_repo_url="`cat $TMPDIR/curr_repo_url`"
      #fi

      # exit if URL is not found or empty
      if [ -z "$curr_repo_url" ]; then
        error "Package URL not found"
        return 8
      fi

      # lets build our DOWNLOAD_URL: set it to the working repo mirror we found above
      DOWNLOAD_URL="${curr_repo_url}"

      # now add the subdir to DOWNLOAD_URL .. sub_dir may be empty, but we add a trailing '/' anyway
      DOWNLOAD_URL="${DOWNLOAD_URL}${sub_dir}/"

      # add some system values into the repo URL (arch, distro version, etc.. from DISTRO_SPECS)
      DOWNLOAD_URL="$(echo "$DOWNLOAD_URL"| sed -e 's@${DBIN_ARCH}@'$DBIN_ARCH'@g')"
      DOWNLOAD_URL="$(echo "$DOWNLOAD_URL"| sed -e 's@${DISTRO_COMPAT_VERSION}@'$DISTRO_COMPAT_VERSION'@g')"
      DOWNLOAD_URL="$(echo "$DOWNLOAD_URL"| sed -e 's@${DDB_COMP}@'$DDB_COMP'@g')"
      DOWNLOAD_URL="$(echo "$DOWNLOAD_URL"| sed -e 's@${SLACKWARE}@'$SLACKWARE'@g')"
      DOWNLOAD_URL="$(echo "$DOWNLOAD_URL"| sed -e 's@${SLACKARCH}@'$SLACKARCH'@g')"
      DOWNLOAD_URL="$(echo "$DOWNLOAD_URL"| sed -e 's@${lxDISTRO_COMPAT_VERSION}@'$lxDISTRO_COMPAT_VERSION'@g')"

      # add our package to the URL
      DOWNLOAD_URL="${DOWNLOAD_URL}${PKG_FILENAME}"

      # remove any double forward slashes (the main URL or subdir may have ended in slashes, it may not, we added our own to be sure)
      DOWNLOAD_URL="$(echo "$DOWNLOAD_URL"| sed -e "s@//$PKG_FILENAME@/$PKG_FILENAME@g")"

      # if sub_dir not empty, lets clean that bit too
      [ "$sub_dir" != '' ] && DOWNLOAD_URL="$(echo "$DOWNLOAD_URL" \
        | sed \
          -e "s@//${sub_dir}@/${sub_dir}@g" \
          -e "s@${sub_dir}//@${sub_dir}/@g")"

      # exit if URL is not found (if we get a 404 back)
      if [ -z "$DOWNLOAD_URL" ]; then
        error "Package URL not found   $DOWNLOAD_URL"
        return 8
      else
        wget -S --spider "$DOWNLOAD_URL" &>/dev/null || \
        {
          error "Package URL not found   $DOWNLOAD_URL"
          return 8
        }
      fi

      # we may be using multiple URLs, so each time we change URL,
      #  remember the new one
      if [ "$OLDURL" != "$DOWNLOAD_URL" ];then
        OLDURL="$DOWNLOAD_URL";
        echo -e "URL: ${lightblue}${DOWNLOAD_URL}${endcolour}";
      fi

      # if --force, remove the package if it already exists
      [ "$FORCE" = true ] && rm -f "${PKGFILE}" &>/dev/null

      # BEGIN DOWNLOAD file here..

      # print DOWNLOADING msg
      echo -en "Downloading ${magenta}${PKG_FILENAME}${endcolour}. Please wait:     "

      # if called as 'gpkg', give a pop GUI (uses Xdialog) showing download progress..
      # can be used by X apps to easily start (and show!) downloads
      if [ "$SELF" = "gpkg" ];then

        download_progress "$DOWNLOAD_URL" "${PKGFILE}" 2>/dev/null

      else # if called as 'pkg', dont use Xdialog, output to terminal

        if [ "$QUIET" = true ];then
          echo
          echo -n "Downloading now..."
          LANG=C wget \
            --no-check-certificate \
            --progress=dot -O "${PKGFILE}" \
            -4 $CONTINUE "$DOWNLOAD_URL" &>/dev/null
        else
          # START DOWNLOAD, show percentage as we go
          LANG=C wget \
            --no-check-certificate \
            --progress=dot -O "${PKGFILE}" \
            -4 $CONTINUE "$DOWNLOAD_URL" 2>&1 \
            | grep --line-buffered "%" \
            | sed -u -e "s#\.##g" \
            | awk '{printf("\b\b\b\b%4s", $2)}' #220613
        fi

      fi

      # clean up output
      [ "$QUIET" != true ] && echo -ne "\b\b\b\b"
      echo

      # ln -s "${PKG_FILENAME}" "$PKG_FNAME_GUESS" 2>/dev/null #TODO use relative symbolic links + symbolic link cleanup.

      # if file downloaded ok
      if [ -f "${PKGFILE}" ];then
        echo -e "${green}Downloaded:${endcolour} ${PKGFILE}"
        DONE=true
        break

      else # file NOT downloaded ok

        error "Failed to download '${PKGFILE}'."
        echo "Check '$DOWNLOAD_URL'"

        # remove the page we tried to get pkg from (if exists)
        rm "${WORKDIR}/index.html" &>/dev/null
        DONE=true
        exit 6
      fi

    done #done while read list of repo files

  fi
}


pkg_install(){                    # install downloaded package ($1) FUNCLIST

  . ${PKGRC}

  # exit if no valid option
  [ ! "$1" ] || [ "$1" = "-" ] && print_usage install && exit 1

  # skip if not installing pkgs
  [ "$NO_INSTALL" = true ] && return 0

  local pkg_ext
  local PKGNAME
  local PKGNAME_ONLY
  local PKGFILE
  local PREVDIR="$CURDIR"
  local petspecs

  # get pkg extension
  pkg_ext=$(get_pkg_ext "$1")
  # get pkg name only, no extension or path
  PKGNAME="$(basename "$1" .$pkg_ext)"
  # exit if no valid option
  [ "$PKGNAME" = '' ] && print_usage install && exit 1
  # get name without version
  PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")

  [ "$(is_installed_pkg "$PKGNAME")" = true ] && [ "$FORCE" = false ] && echo "Already installed: $PKGNAME" && return 1
  [ "$(is_blacklisted_pkg "$PKGNAME_ONLY")" = true ] && echo "Blacklisted package: $PKGNAME" && return 1

  if [ -f "$1" ];then
    PKGFILE="$1"
    PKGNAME=$(basename "$1" .$pkg_ext)
  else
    # get the real file name (inc path) from the given PKGFILE and pkg_ext (which may be empty)
    PKGFILE=$(find "$CURDIR" -mount -maxdepth 1 -type f -name "${PKGNAME}*${pkg_ext}" | head -1)
    [ ! -f "$PKGFILE" ] && PKGFILE=$(find "$CURDIR" -mount -maxdepth 1 -type f -name "$(get_pkg_filename "$PKGNAME")" | head -1)
    [ ! -f "$PKGFILE" ] && PKGFILE=$(find "$CURDIR" -mount -maxdepth 1 -type f -name "${PKGNAME}*${EX}" | grep -m1 $EX)
    [ -f "$PKGFILE" ] && PKGNAME=$(basename "$1" .$pkg_ext)
  fi

  # maybe the file is not in the current dir, but in WORKDIR, so lets look there too
  if [ ! -f "$PKGFILE" ];then
    PKGFILE=$(find "$WORKDIR" -mount -maxdepth 1 -type f -name "${PKGNAME}*${pkg_ext}" | head -1)
    [ ! -f "$PKGFILE" ] && PKGFILE=$(find "$WORKDIR" -mount -maxdepth 1 -type f -name "${PKGNAME}*${EX}" | grep -m1 $EX)

    # if we found the file in WORKDIR, make that our CURDIR
    if [ -f "$PKGFILE" ];then
      PKGNAME=$(basename "$PKGFILE" .$pkg_ext)
      CURDIR="$WORKDIR"
      cd "$WORKDIR" || exit 1
    else
      # if we still didn't find it, do a broader check
      PKGFILE=$(find "$WORKDIR" -mount -maxdepth 1 -type f -name "${PKGNAME}*" | head -1)
      if [ -f "$PKGFILE" ];then
        PKGNAME=$(basename "$PKGFILE" .$pkg_ext)
        CURDIR="$WORKDIR"
        cd "$WORKDIR" || exit 1
      fi
    fi
  fi

  if [ ! -f "$PKGFILE" ];then
    echo "Package '$PKGNAME' not yet downloaded."

    matching_local_pkgs="$(list_downloaded_pkgs $PKGNAME)"

    if [ "$matching_local_pkgs" != "" ];then
      echo "You could install one of the following packages with \`$SELF -i PKGNAME\`:"
      list_downloaded_pkgs "$(basename "$PKGNAME" .$pkg_ext 2>/dev/null)"

    elif [ -z "$matching_local_pkgs" ] && grep -q -m1 "^${PKGNAME}|" "${REPO_DIR}/${REPOFILE}"; then
      echo "You must first download one of the following packages with \`$SELF -d PKGNAME\`:"
      $PKGSEARCH "$(basename $PKGNAME .$pkg_ext 2>/dev/null)"

    else
      not_found "${PKGNAME}"
    fi
    return 1
  fi

  # get the extension of this newly found pkg (which we should have found by now)
  pkg_ext=$(get_pkg_ext "$PKGFILE")
  [ "$pkg_ext" = "" ] && pkg_ext=$(get_pkg_ext "$PKGNAME")

  if [ "$pkg_ext" = '' ];then
    echo "Not installing $PKGFILE."
    error "Invalid file extension ($pkg_ext)."
    return 1
  fi

  # remove any previous PET/pkg stuff lying around from previous installs
  rm -f /pet.specs /pinstall.sh /puninstall.sh /install/doinst.sh
  #remove the old error log
  rm $TMPDIR/$SELF-cp-errlog 2>/dev/null

  # get filename from download file
  PKGNAME=$(basename "$PKGFILE" .$pkg_ext)
  # ask/inform user before install
  echo -n "Install package ${PKGNAME}$QTAG:  "
  [ "$ASK" = true ] && read -n 1 CONFIRM </dev/tty || CONFIRM=y
  [ "$ASK" = true ] && echo -ne "\b\b\n"

  # if user answered yes, we will now download the pkgs
  if [ "$CONFIRM" != "y" ];then
    return 0
  fi

  # print new line if we didnt take any user input on tty
  [ "$ASK" != true ] && echo

  # run any relevant plugins
  ASK=$PLUGIN_ASK FORCE=$FORCE run_plugins 'pre_install'

  #if [ "`pkg_contents "$PKGFILE" 2>/dev/null`" = '' ];then
  # error "$PKGFILE not a valid package."
  # exit 1
  #fi

  # extract the archive file into a $CURDIR/$PKGNAME folder
  case "$pkg_ext" in

    pet) # needs tar 1.26+
      rmdir "${CURDIR}/${PKGNAME}" &>/dev/null
      mkdir -p "${CURDIR}/${PKGNAME}"
      [ ! -f "$PKGFILE" ] && PKGFILE="$(find ${CURDIR} -mount -maxdepth 1 -type f -name "${PKGNAME}*.pet")"
      PETPKG=${PKGFILE%.pet} #remove trailing ".pet"

      head -c -32 ${PETPKG}.pet > ${PETPKG}.tar
      tar --force-local -tf ${PETPKG}.pet 2>/dev/null > /tmp/pkg/file_contents

      sort -u /tmp/pkg/file_contents > /tmp/pkg/file_contents_sorted
      mv /tmp/pkg/file_contents_sorted /tmp/pkg/file_contents

      LINE_PREFIX="$(head -1 /tmp/pkg/file_contents)"

      case "$LINE_PREFIX" in
        "./"*)
          pPATTERN="s%^\\./${PETPKG##*/}%% ; /pet\.specs/d ; /pinstall\.sh/d ; /puninstall\.sh/d ; /^\\/$/d ; "
          tar --force-local --strip=2 --directory="${CURDIR}/${PKGNAME}/" -xf ${PETPKG}.tar
          ;;
        *)
          pPATTERN="s%^${PETPKG##*/}%%     ; /pet\.specs/d ; /pinstall\.sh/d ; /puninstall\.sh/d ; /^\\/$/d ; "
          tar --force-local --strip=1 --directory="${CURDIR}/${PKGNAME}/" -xf ${PETPKG}.tar
          ;;
      esac

      if [ $? -ne 0 ] ; then
        echo "ERROR: failed to unpack ${PETPKG}.pet"
        rm -f ${PETPKG}.tar
        exit 1
      fi

      rm -f ${PETPKG}.tar

      # save the uninstall script for later
      if [ -f "${CURDIR}/${PKGNAME}/puninstall.sh" ];then
        mv "${CURDIR}/${PKGNAME}/puninstall.sh" ${REPO_DIR}/${PKGNAME}.remove
      fi

      cat /tmp/pkg/file_contents 2>/dev/null \
        | sed \
          -e "$pPATTERN" \
          -e "s#^\.\/#\/#g" \
          -e "s#^#\/#g" \
          -e "s#^\/\/#\/#g" \
          -e 's#^\/$##g' \
          -e 's#^\/\.$##g' > ${REPO_DIR}/${PKGNAME}.files

      rm /tmp/pkg/file_contents 2>/dev/null
    ;;

    sfs)
      [ ! -f "$PKGFILE" ] && PKGFILE="$(find ${CURDIR} -mount -maxdepth 1 -type f -name "${PKGNAME}*.sfs")"
      [ ! -f "$PKGFILE" ] && PKGFILE="$(find ${WORKDIR} -mount -maxdepth 1 -type f -name "${PKGNAME}*.sfs")"
      echo sfs_load -q --cli +"$PKGFILE" #2>/dev/null
      sfs_load -q --cli +"$PKGFILE" #2>/dev/null
      rm -f ${REPO_DIR}/${PKGNAME}.files 2>/dev/null
      # create ${REPO_DIR}/$PKGNAME.files
      pkg_contents "$PKGFILE" | while read line
      do
        [ -f "$line" ] && echo "$line" >> ${REPO_DIR}/${PKGNAME}.files
      done
      # exit, we dont need to unpack and copy
      return 0
    ;;

    deb)

      rmdir "${CURDIR}/${PKGNAME}" &>/dev/null
      mkdir -p "${CURDIR}/${PKGNAME}"
      [ ! -f "$PKGFILE" ] && PKGFILE="$(find ${CURDIR} -mount -maxdepth 1 -type f -name "${PKGNAME}*.deb")"
      cp "${PKGFILE}" "${CURDIR}/${PKGNAME}/${PKGNAME}.deb" || exit 4
      cd "${CURDIR}/${PKGNAME}/" || exit 1

      if [ -f "${CURDIR}/${PKGNAME}/${PKGNAME}.deb" ];then
        dpkg-deb --contents "${CURDIR}/${PKGNAME}/${PKGNAME}.deb" \
          | grep -v '/$' \
          | tr -s ' ' \
          | cut -f6 -d' ' \
          | grep -v '^$' > ${REPO_DIR}/${PKGNAME}.files
      fi

      dpkg-deb -x ${CURDIR}/${PKGNAME}.deb ${CURDIR}/${PKGNAME}
      [ $? -ne 0 ] && exit 1
      [ -d /DEBIAN ] && rm -rf /DEBIAN #130112 precaution.
      dpkg-deb -e "${CURDIR}/${PKGNAME}/${PKGNAME}.deb" /DEBIAN #130112 extracts deb control files to dir /DEBIAN. may have a post-install script, see below.
      rm "${PKGNAME}.deb"

      cd - 1>/dev/null || exit 1
    ;;

    *tgz|*txz|*tzst|*tar.gz|*tar.xz|*tar.zst|*tzst|*tlz|*tar.lzma|*tbz|*tar.bz2|*tar.zst)
      rmdir "${CURDIR}/${PKGNAME}" &>/dev/null
      mkdir -p "${CURDIR}/${PKGNAME}"
      [ ! -f "$PKGFILE" ] && PKGFILE="$(find ${CURDIR} -mount -maxdepth 1 -type f -name "${PKGNAME}*.${pkg_ext}")"
      cp "$PKGFILE" "${CURDIR}/${PKGNAME}/${PKGNAME}.$pkg_ext" || exit 4
      cd "${CURDIR}/${PKGNAME}/" || exit 1
      case "$pkg_ext" in
        *tbz|*tar.bz2)  bzip2 -dc "${PKGNAME}.$pkg_ext" | tar -xf - 2> $TMPDIR/$SELF-cp-errlog ;;
        *tlz|*tar.lzma) lzma -dc "${PKGNAME}.$pkg_ext"  | tar -xf - 2> $TMPDIR/$SELF-cp-errlog ;;
        *) tar --force-local -xf "${PKGNAME}.$pkg_ext" 2> $TMPDIR/$SELF-cp-errlog ;;
      esac
      tar --force-local -tf "${PKGNAME}.$pkg_ext" > ${REPO_DIR}/${PKGNAME}.files
      rm "${PKGNAME}.$pkg_ext"
      cd - 1>/dev/null || exit 1
    ;;

    rpm)
      PKGNAME="$(basename "${PKGFILE}" .rpm)"
      busybox rpm -qp "$PKGFILE" > /dev/null 2>&1
      [ $? -ne 0 ] && exit 1
      PFILES="$(busybox rpm -qpl "$PKGFILE")"
      [ $? -ne 0 ] && exit 1
      echo "$PFILES" > ${REPO_DIR}/${PKGNAME}.files
      pkg_unpack "$PKGFILE" 1>/dev/null
    ;;

  esac

  [ ! -d "${PKGNAME}/" ] && error "Cannot enter directory '${PKGNAME}/', it doesn't exist." && exit 4

  cd "${PKGNAME}/" 1>/dev/null || exit 1

  # now extract pkg contents to /
  cp -a --remove-destination ./* ${DIRECTSAVEPATH}/ 2> $TMPDIR/$SELF-cp-errlog

  # if source is a directory, target is a symlink... process again
  if [ -s $TMPDIR/$SELF-cp-errlog ];then
    grep -E 'Cannot create symlink to|cannot overwrite non-directory' $TMPDIR/$SELF-cp-errlog  2>/dev/null \
      | cut -f 2 -d "'" \
      | while read ONEDIRSYMLINK
        do
          # adding that extra trailing / does the trick...
          cp -a --remove-destination ./${ONEDIRSYMLINK}/* /${ONEDIRSYMLINK}/ 2> $TMPDIR/$SELF-cp-errlog #260713
        done
  fi
  sync
  cd .. 1>/dev/null || exit 1

  # move the *.files to ${REPO_DIR}
  FILES=''
  FILES="$(find "$CURDIR" -mount -maxdepth 1 -iname "*.files" | head -1)"
  [ -f "$FILES" ] && mv "$FILES" "${REPO_DIR}/" 2>/dev/null #260713

  #pkgname.files may need to be fixed...
  grep -v '/$' ${REPO_DIR}/${PKGNAME}.files \
    | sed \
      -e "s#^\.\/#\/#g"   \
      -e "s#^#\/#g"       \
      -e "s#^\/\/#\/#g"   \
      -e 's#^\/$##g'      \
      -e 's#^\/\.$##g'    \
      -e '\%^/install/%d' \
    | sort -u > ${REPO_DIR}/${PKGNAME}.files2

  mv ${REPO_DIR}/${PKGNAME}.files2 ${REPO_DIR}/${PKGNAME}.files
  # some pets add images and icons at / so move them
  mv /{*.xpm,*.png,*.ico} /usr/share/pixmaps/ 2>/dev/null

  # run the post install scripts (for puppy, slackware, arch, debian/ubuntu, etc)
  (
    for i in /pinstall.sh /install/doinst.sh /DEBIAN/postinst
    do
      [ -z ${i} ] || [ ! -e /${i} ] && continue
      chmod +x /${i}
      cd /
      nohup sh ${i} &>/dev/null
      sleep 0.1
      rm -f ${i:-?}
      cd ${CURDIR}/ || exit 1
    done
    rm -rf /install
    rm -rf /DEBIAN
  )

  #130314 run arch linux pkg post-install script...
  #precaution. see 3builddistro, script created by noryb009.
  if [ -f /.INSTALL ] && [ -f /usr/local/petget/ArchRunDotInstalls ];then
    #this code is taken from below...
    dlPATTERN='|'"$(echo -n "${PKGNAME}" | sed -e 's%\\-%\\\\-%')"'|'
    archVER="$(cat $TMPDIR/petget_missing_dbentries-Packages-* 2>/dev/null \
      | grep "$dlPATTERN" \
      | head -n 1 \
      | cut -f 3 -d '|')"
    if [ "$archVER" ];then #precaution.
      cd /
      mv -f .INSTALL .INSTALL1-${archVER}
      cp -a /usr/local/petget/ArchRunDotInstalls ArchRunDotInstalls
      LANG=$LANGUSER ./ArchRunDotInstalls
      rm -f ArchRunDotInstalls
      rm -f .INSTALL*
      cd ${CURDIR}/ || exit 1
    fi
  fi

  PKGCAT=''
  PKGSIZE=''
  PKGDESC=''
  DEPLIST=''

  # clean up pet installs
  if [ "$pkg_ext" = "pet" ];then
    cd /

    # get pkg info from pet.spec before we delete it, because the PET may not be a repo pkg
    petspecs="$(cat /pet.specs 2>/dev/null)"

    if [ "$petspecs" != '' ];then
      # now get pkg info
      PKGCAT="$(echo $petspecs|  cut -f5  -d'|')"
      PKGSIZE="$(echo $petspecs| cut -f6  -d'|')"
      PKGDESC="$(echo $petspecs| cut -f10 -d'|')"
      DEPSLIST="$(echo $petspecs|cut -f9  -d'|')"
    fi

    cd ${CURDIR}/ || exit 1
  fi

  # cleanup a bit
  rm -R "${PKGNAME:-?}/" 2>/dev/null || echo "${yellow}Warning:${endcolour} Cannot remove directory '${PKGNAME}/'." #150213

  #flush unionfs cache, so files in pup_save layer will appear "on top"...
  if [ "$DIRECTSAVEPATH" != "" ];then
   #but first, clean out any bad whiteout files...
   # 22sep10 shinobar: bugfix was not working clean out whiteout files
   find /initrd/pup_rw -mount -type f -name .wh.\*  -printf '/%P\n'|
   while read ONEWHITEOUT
   do
    ONEPATTERN="$(echo -n "$ONEWHITEOUT" | sed -e 's%/\\.wh\\.%/%')"'/*' ;#echo "$ONEPATTERN" >&2
    grep -q -x "$ONEPATTERN" ${REPO_DIR}/${PKGNAME}.files && rm -f "/initrd/pup_rw/$ONEWHITEOUT"
   done
   # /usr/local/petget/removepreview.sh when uninstalling a pkg,
   # may have copied a file from sfs-layer to top, check...
   # shellcheck disable=SC2002
   cat ${REPO_DIR}/${PKGNAME}.files |
   while read ONESPEC
   do
    [ "$ONESPEC" = "" ] && continue #precaution.
    if [ ! -d "$ONESPEC" ];then
     [ -e "/initrd/pup_rw${ONESPEC}" ] && rm -f "/initrd/pup_rw${ONESPEC}"
    fi
   done
   #now re-evaluate all the layers...
   busybox mount -t aufs -o remount,udba=reval unionfs / #remount with faster evaluation mode.
   [ $? -ne 0 ] && logger -s -t "pkg" "Failed to remount aufs / with udba=reval"
   sync
  fi

  # get pkg size from local file, or repos
  [ "$PKGSIZE" = '' ] && PKGSIZE=$(LANG=C du -s -k ${CURDIR}/${PKG} 2>/dev/null | cut -f1)
  [ "$PKGSIZE" = '' ] && PKGSIZE=$(grep -m1 "^${PKGNAME}|" "${REPO_DIR}/Packages-"* 2>/dev/null | cut -f6 -d'|' | head -1)
  # get category and description from current repo
  [ "$PKGCAT" = ''  ] && PKGCAT=$(LANG=C  grep -m1 "|${PKGNAME_ONLY}|" "${REPO_DIR}/${REPOFILE}" 2>/dev/null | cut -f5 -d'|' | head -1)
  [ "$PKGCAT" = ''  ] && PKGCAT=$(LANG=C  grep -m1 "^${PKGNAME}|"      "${REPO_DIR}/${REPOFILE}" 2>/dev/null | cut -f5 -d'|' | head -1)
  [ "$PKGDESC" = '' ] && PKGDESC=$(LANG=C grep -m1 "|${PKGNAME_ONLY}|" "${REPO_DIR}/${REPOFILE}" 2>/dev/null| cut -f10 -d'|' | head -1)
  [ "$PKGDESC" = '' ] && PKGDESC=$(LANG=C grep -m1 "^${PKGNAME}|"      "${REPO_DIR}/${REPOFILE}" 2>/dev/null| cut -f10 -d'|' | head -1)
  # if details not found in current repo, check all repos
  [ "$PKGCAT" = ''  ] && PKGCAT=$(LANG=C  grep -h -m1 "|${PKGNAME_ONLY}|" "${REPO_DIR}/Packages-"* 2>/dev/null | cut -f5 -d'|' | head -1)
  [ "$PKGCAT" = ''  ] && PKGCAT=$(LANG=C  grep -h -m1 "^${PKGNAME}|"      "${REPO_DIR}/Packages-"* 2>/dev/null | cut -f5 -d'|' | head -1)
  [ "$PKGDESC" = '' ] && PKGDESC=$(LANG=C grep -h -m1 "|${PKGNAME_ONLY}|" "${REPO_DIR}/Packages-"* 2>/dev/null| cut -f10 -d'|' | head -1)
  [ "$PKGDESC" = '' ] && PKGDESC=$(LANG=C grep -h -m1 "^${PKGNAME}|"      "${REPO_DIR}/Packages-"* 2>/dev/null| cut -f10 -d'|' | head -1)

  # add unit to size
  PKGSIZE="${PKGSIZE}K"
  PKGSIZE="${PKGSIZE//KK$/K}"

  # get pkg version
  PKGVER="$(get_pkg_version "$PKGNAME")"
  #PKGARCH="`LANG=C echo "$PKGNAME" | cut -f3 -d'-' | grep -E 'i[3-9]|x[8-9]|arm64|armel|armhf|noarch'`"

  # last check for pkg info
  [ "$DEPSLIST" = '' ] && DEPSLIST="$(grep -m1 "^${PKGNAME}|" ${REPO_DIR}/Packages-* 2>/dev/null | cut -f9 -d'|' | grep '+' | head -1)"
  [ "$PKGDESC" = ''  ] && PKGDESC="No description"

  #080917 - build woof compatible repo line .. #090817
  if ! cut -f1 -d'|' ${REPO_DIR}/user-installed-packages 2>/dev/null | grep -q -m1 "^${PKGNAME}"; then

    # get the package db entry to add to user-installed-packages...
    # first, get it from petspecs if possible, or from the pkgs repo, or make one
    if [ -f /pet.specs ];then
      DB_ENTRY="$(head -n1 /pet.specs)"
    elif grep -1 -m1 "^${PKGNAME}|" "${REPO_DIR}/$REPOFILE"; then
      DB_ENTRY="$(grep -m1 "^${PKGNAME}|" "${REPO_DIR}/$REPOFILE")"
    else
      DB_ENTRY="${PKGNAME}|${PKGNAME_ONLY}|${PKGVER}|${BUILD}|${PKGCAT}|${PKGSIZE}|${PKGDIR}|${PKGNAME}.${pkg_ext}|${DEPSLIST}|${PKGDESC}|${DISTRO_BINARY_COMPAT}|${DISTRO_COMPAT_VERSION}"
    fi

    # now add the db entry to user-installed-packages
    echo "$DB_ENTRY" >> ${REPO_DIR}/user-installed-packages #130913

  fi

  # now delete the petspecs file(s), we already added our PKG info to installed-packages
  rm /pet.specs &>/dev/null
  rm /*.pet.specs &>/dev/null

  # make sure /tmp has correct permission, a pkg may have overwritten it
  # shellcheck disable=SC2010
  ls -dl /tmp | grep -q '^drwxrwxrwt' || chmod 1777 /tmp #130305 rerwin.

  if [ "$(is_installed_pkg $PKGNAME)" != true ] || [ ! -s ${REPO_DIR}/${PKGNAME}.files ];then
    error "$PKGNAME may not have installed correctly."
  fi

  # installed OK! output message
  echo -e "${green}Installed:${endcolour} $PKGNAME"
  [ "$(which logger)" != '' ] && logger "$0 Package $PKGNAME installed by $APP $APPVER"

  # show if pkg has menu entry
  menu_entry_msg "$PKGNAME_ONLY"
  # do fixmenus, if menu entry found
  if grep -q -m1 '/usr/share/applications/.*.desktop' ${REPO_DIR}/${PKGNAME}.files 2>/dev/null; then
    [ ! -f /tmp/pkg/update_menus_busy ] && update_menus &
  fi

  # clean up user-installed-packages (remove duplicates and empty lines, but DONT sort)
  grep -v "^\$" ${REPO_DIR}/user-installed-packages | uniq > ${REPO_DIR}/user-installed-packages_clean
  mv ${REPO_DIR}/user-installed-packages_clean ${REPO_DIR}/user-installed-packages

  # run any relevant post install plugins
  ASK=$PLUGIN_ASK FORCE=$FORCE run_plugins 'post_install'

  # puppy specific fixes for installed package
  postinstall_hacks "$PKGNAME" "$PKGNAME_ONLY" &

  # update system cache
  cache_progress_msg() {
    sleep 2
    echo "Updating cache..."
  }
  cache_progress_msg &
  pidof_cache_progress_msg=$!
  update_system_cache ${REPO_DIR}/${PKGNAME}.files 1>/dev/null 2>&1
  kill $pidof_cache_progress_msg &>/dev/null

  # go back to the dir we started in
  cd "$PREVDIR" || exit 1

}

postinstall_hacks(){              # fix pkgs after installation
  local PKGNAME="$1"
  local PKGNAME_ONLY="$2"

  # remove %u, %U, %f (etc) from Exec lines
  DESKTOPFILE="$(find /usr/share/applications -iname "${PKGNAME_ONLY}*.desktop")"
  [ -f "$DESKTOPFILE" ] && \
    sed -i 's/ %u//' $DESKTOPFILE && \
    sed -i 's/ %U//' $DESKTOPFILE && \
    sed -i 's/ %f//' $DESKTOPFILE && \
    sed -i 's/ %F//' $DESKTOPFILE

  case $PKGNAME in
   0ad-*|0ad_*)
    bbe -e 's/geteuid/getppid/' /usr/games/pyrogenesis > /usr/games/pyrogenesis1 2>/dev/null
    mv /usr/games/pyrogenesis1 /usr/games/pyrogenesis
    chmod 755 /usr/games/pyrogenesis
   ;;
   openclonk-*|openclonk_*)
    bbe -e 's/geteuid/getppid/' /usr/games/openclonk > /usr/games/openclonk1 2>/dev/null
    mv /usr/games/openclonk1 /usr/games/openclonk
    chmod 755 /usr/games/openclonk
   ;;
   vlc_*|vlc-*)
    VLCDESKTOP="$(find /usr/share/applications -mindepth 1 -maxdepth 1 -iname 'vlc*.desktop')"
    [ -f $VLCDESKTOP ] && sed -i 's/ --started-from-file %U//' $VLCDESKTOP
    [ -f $VLCDESKTOP ] && sed -i 's/ --started-from-file//' $VLCDESKTOP

    #120907 vlc in debian/ubuntu configured to not run as root (it is a pre-compile configure option to enable running as root).
    #this hack will fix it...
    #note, this code is also in FIXUPHACK in 'vlc' template.
    if [ -f /usr/bin/bbe ];then #bbe is a sed-like utility for binary files.
     if [ -f /usr/bin/vlc  ];then
       bbe -e 's/geteuid/getppid/' /usr/bin/vlc > /tmp/vlc-temp1
       mv -f /tmp/vlc-temp1 /usr/bin/vlc
       chmod 755 /usr/bin/vlc
     fi
    fi
  ;;
  google-chrome-*) #130221 pemasu. 130224 pemasu: limit cache size...
    if [ -f /usr/bin/bbe ];then #bbe is a sed-like utility for binary files.
      if [ -f /opt/google/chrome/chrome  ];then
        bbe -e 's/geteuid/getppid/' /opt/google/chrome/chrome > /tmp/chrome-temp1
        mv -f /tmp/chrome-temp1 /opt/google/chrome/chrome
        chmod 755 /opt/google/chrome/chrome
        [ -e /usr/bin/google-chrome ] && rm -f /usr/bin/google-chrome
        echo '#!/bin/sh
        exec /opt/google/chrome/google-chrome --user-data-dir=/root/.config/chrome --disk-cache-size=10000000 --media-cache-size=10000000 "$@"' > /usr/bin/google-chrome
        chmod 755 /usr/bin/google-chrome
        ln -s google-chrome /usr/bin/chrome
        ln -s /opt/google/chrome/product_logo_48.png /usr/share/pixmaps/google-chrome.png
        ln -s /opt/google/chrome/product_logo_48.png /usr/share/pixmaps/chrome.png
        CHROMEDESKTOP="$(find /usr/share/applications -mindepth 1 -maxdepth 1 -iname '*chrome*.desktop')"
        if [ "$CHROMEDESKTOP" = "" ];then #precaution.
          echo '[Desktop Entry]
Encoding=UTF-8
Version=1.0
Name=Google Chrome web browser
GenericName=Google Chrome
Comment=Google Chrome web browser
Exec=google-chrome
Terminal=false
Type=Application
Icon=google-chrome.png
Categories=WebBrowser;' > /usr/share/applications/google-chrome.desktop
        fi
      fi
    fi
  ;;
  chromium*) #130221 pemasu. 130224 pemasu: limit cache size...
    if [ -f /usr/bin/bbe ];then #bbe is a sed-like utility for binary files.
     if [ -f /usr/lib/chromium/chromium  ];then
    bbe -e 's/geteuid/getppid/' /usr/lib/chromium/chromium > /tmp/chrome-temp1
    mv -f /tmp/chrome-temp1 /usr/lib/chromium/chromium
    chmod 755 /usr/lib/chromium/chromium
    [ -e /usr/bin/chromium ] && rm -f /usr/bin/chromium
    echo '#!/bin/sh
  exec /usr/lib/chromium/chromium --user-data-dir=/root/.config/chrome --disk-cache-size=10000000 --media-cache-size=10000000 --audio-buffer-size=2048 "$@"' > /usr/bin/chromium
    chmod 755 /usr/bin/chromium
    ln -s /usr/share/icons/hicolor/48x48/apps/chromium.png /usr/share/pixmaps/chromium.png
    CHROMEDESKTOP="`find /usr/share/applications -mindepth 1 -maxdepth 1 -iname '*chromium-br*.desktop'`"
    if [ "$CHROMEDESKTOP" = "" ];then #precaution.
     echo '[Desktop Entry]
Encoding=UTF-8
Version=1.0
Name=Chromium web browser
GenericName=Chromium
Comment=Chromium web browser
Exec=chromium
Terminal=false
Type=Application
Icon=chromium.png
Categories=WebBrowser;' > /usr/share/applications/chromium.desktop
    fi
     fi
    fi
   ;;
   jwm_theme_*)
    #120924 DejaVu font no good for non-Latin languages...
    #see also langpack_* pinstall.sh (template is in /usr/share/doc/langpack-template/pinstall.sh, read by momanager).
    LANGUSER="`grep '^LANG=' /etc/profile | cut -f 2 -d '=' | cut -f 1 -d ' '`"
    case $LANGUSER in
     zh*|ja*|ko*) #chinese, japanese, korean
    sed -i -e 's%DejaVu Sans%Sans%' /etc/xdg/templates/_root_*
    sed -i -e 's%DejaVu Sans%Sans%' /root/.jwm/themes/*-jwmrc
    sed -i -e 's%DejaVu Sans%Sans%' /root/.jwm/jwmrc-theme
     ;;
    esac
    #130326 font size fix for 96 dpi...
    if [ "$PKGNAME_ONLY" ];then
     JWMTHEMEFILE="$(grep '^/root/\.jwm/themes/.*-jwmrc$' ${REPO_DIR}/${PKGNAME_ONLY}.files | head -n 1)"
     [ "$JWMTHEMEFILE" ] && hackfontsize "JWMTHEMES='${JWMTHEMEFILE}'"
    fi
   ;;
   openbox*)
    #120924 DejaVu font no good for non-Latin languages...
    #see also langpack_* pinstall.sh (template is in /usr/share/doc/langpack-template/pinstall.sh, read by momanager).
    LANGUSER="`grep '^LANG=' /etc/profile | cut -f 2 -d '=' | cut -f 1 -d ' '`"
    case $LANGUSER in
     zh*|ja*|ko*) #chinese, japanese, korean
    sed -i -e 's%DejaVu Sans%Sans%' /etc/xdg/openbox/*.xml
    sed -i -e 's%DejaVu Sans%Sans%' /root/.config/openbox/*.xml
     ;;
    esac
   ;;
   gtk_theme_*)
    #120924 DejaVu font no good for non-Latin languages...
    #see also langpack_* pinstall.sh (template is in /usr/share/doc/langpack-template/pinstall.sh, read by momanager).
    LANGUSER="`grep '^LANG=' /etc/profile | cut -f 2 -d '=' | cut -f 1 -d ' '`"
    case $LANGUSER in
     zh*|ja*|ko*) #chinese, japanese, korean
    GTKRCFILE="$(find /usr/share/themes -type f -name gtkrc | tr '\n' ' ')"
    for ONEGTKRC in $GTKRCFILE
    do
     sed -i -e 's%DejaVu Sans%Sans%' $ONEGTKRC
    done
     ;;
    esac
    #130326 font size fix for 96 dpi...
    if [ "$PKGNAME_ONLY" ];then
     GTKTHEMEFILE="$(grep '^/usr/share/themes/.*/gtk-2\.0/gtkrc$' ${REPO_DIR}/${PKGNAME_ONLY}.files | head -n 1)"
     [ "$GTKTHEMEFILE" ] && hackfontsize "GTKRCS='${GTKTHEMEFILE}'"
    fi
   ;;
   seamonkey*|firefox*)
    #120924 DejaVu font no good for non-Latin languages...
    #see also langpack_* pinstall.sh (template is in /usr/share/doc/langpack-template/pinstall.sh, read by momanager).
    LANGUSER="`grep '^LANG=' /etc/profile | cut -f 2 -d '=' | cut -f 1 -d ' '`"
    case $LANGUSER in
     zh*|ja*|ko*) #chinese, japanese, korean
    MOZFILE="$(find /root/.mozilla -type f -name prefs.js -o -name '*.css' | tr '\n' ' ')"
    for ONEMOZ in $MOZFILE
    do
     sed -i -e 's%DejaVu Sans%Sans%' $ONEMOZ
    done
     ;;
    esac
   ;;
   mc_*) #121206 midnight commander
    #in ubuntu, won't run from the menu. this fixes it...
    [ -f /usr/share/applications/mc.desktop ] && sed -i -e 's%^Exec=.*%Exec=TERM=xterm mc%' /usr/share/applications/mc.desktop
   ;;
   xsane*) #130122
    #xsane puts up a warning msg at startup if running as root, remove it...
    #this code is also in file FIXUPHACK in xsane template (in Woof).
    #WARNING: this may only work for x86 binary.
    if [ -f /usr/bin/bbe ];then #bbe is a sed-like utility for binary files.
     if [ -f /usr/bin/xsane  ];then
    bbe -e 's/\x6b\x00getuid/\x6b\x00getpid/' /usr/bin/xsane > /tmp/xsane-temp1
    mv -f /tmp/xsane-temp1 /usr/bin/xsane
    chmod 755 /usr/bin/xsane
     fi
    fi
   ;;
   kompozer*) #130507
    [ -f /usr/bin/kompozer ] && [ -d /usr/lib/kompozer ] && sed -i -e 's%^moz_libdir=%export MOZILLA_FIVE_HOME="/usr/lib/kompozer" #BK\nmoz_libdir=%' /usr/bin/kompozer
   ;;
  esac
}


choose_pkg(){                     # given partial name ($1), choose from a list of matching packages FUNCLIST


  # exit if no valid options
  [ ! "$1" ] || [ "$1" = "" ] || [ "$1" = "-" ] && print_usage get && exit 1

  # get $REPONAME and $EX
  . "${PKGRC}"

  local REPOEX    # extension of pkgs in the current repo $REPONAME (from rc file)
  local PKGEX     # pkg extension we get from $1, defaults to $REPOEXT is empty
  local PKGNAME   # the name of the pkg, we get this from $1
  local PKGNAME_ONLY  # the pkg name without version, we get this from PKGNAME
  local PKGS      # the list of PKGS returned matching $1/$PKGNAME
  local INT=1     # used to provide numbered lists
  local sort      # set to either sort or sort -r

  REPOEX=$EX
  # get pkg extension
  PKGEX=$(get_pkg_ext "$1")

  # if no extension, set to extension of current repo
  [ "$PKGEX" = '' ] && PKGEX=$REPOEX

  # get pkg name with version, no extension or path
  PKGNAME="$(basename "$1" .$PKGEX)"

  # get the full pkg name, to compare against repo pkgs we find
  PKGNAME_FULL="$(get_pkg_name "$PKGNAME")"

  # get pkg name only .. without version or suffix
  PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")

  # remove any previous user choice lists
  rm $TMPDIR/PKGLIST &>/dev/null
  rm $TMPDIR/USRPKGLIST &>/dev/null

  # get all pkgs that match the given pkgname
  # returns full pkg names (field1 of repo, pkgname with ver but no extension) each on a new line
  PKGS="$($PKGSEARCH "${PKGNAME}")"

  if [ "$FORCE" = false ] && [ "$(is_installed_pkg "$PKGNAME_FULL")" = true ] && [ "$HIDE_INSTALLED" = true ];then
    # remove it from choices
    PKGS="$(echo "$PKGS" | grep -v ^$PKGNAME_FULL\$)"
  fi

  # extra steps for ubuntu and debian repos, if multiple choices returned.. remove non-compatible archs, remove dev and dbg pkgs...
  if [ "$PKGEX" = "deb" ] && [ "$(echo "$PKGS" | wc -l)" != "1" ];then

    ARCH="$(uname -m)"
    #remove x64 pkgs from choices if not using an x64 cpu
    [ "$ARCH" != "x86_64" ] && PKG="$(echo "$PKGS" | grep -v -E 'amd64|x86_64')"

    # set any pkgs matching current arch to top of list:
    # first pkg found (newest) added to top, then the next, etc,
    for LINE in $(echo "$PKGS"  | sort -r)
    do
      # if not searching for -dev or -dgb pkg, move it to bottom of the list
      if [ "$(is_blacklisted_pkg "$(get_pkg_name_only "$LINE")")" = false ] && \
         [ "$(echo "$PKGNAME" | grep -E "\-dbg_|\-dev_")" = "" ] && \
         [ "$(echo "$LINE" | grep -E "\-dbg_|\-dev_")" != "" ]
      then
        PKGS="$(echo "$PKGS" | grep -v  "$LINE")"
        PKGS="$PKGS
$LINE"
      fi
      # if pkg is for current cpu arch, move it to top of the list
      if [ "$(echo "$LINE" | grep -m1 "$ARCH")" != "" ];then
        PKGS="$(echo "$PKGS" | grep -v  "$LINE")"
        PKGS="$LINE
$PKGS"
      fi
    done
    #remove debug and dev pkgs
    #PKGS="`echo "$PKGS" | grep -v "\-dbg_"`"
    #PKGS="`echo "$PKGS" | grep -v "\-dev_"`"
  fi

  # get the user to choose which packages they want to install
  if [ "$ASK" = true ] && [ "$PKGS" != "" ];then
    echo "Please choose the package number. For the first package,"
    echo "enter '1', without quotes. To install multiple packages,"
    echo "enter the numbers, separated by a comma. Example:  1,3,4"
    echo
  fi

  # if using ubuntu/debian packages, put pkg_* before pkg-* .. else dont
  [ "$PKGEX" = 'deb' ] && sort='sort -r' || sort='sort'

  # go through each actual pkg that matches the pkgname search, make it a numbered list
  echo "$PKGS" | $sort -u | while read LINE
  do
    if [ "$LINE" != "" ] && [ "$LINE" != "," ] && [ "$LINE" != " " ];then
      [ "$ASK" = true ] && echo "${INT}. $LINE"
      echo "${INT}. $LINE" >> $TMPDIR/PKGLIST
      INT=$(($INT + 1))
    fi
  done

  # if pkg list was made
  if [ -f $TMPDIR/PKGLIST ] && [ -s "$TMPDIR/PKGLIST" ];then

    # set to first pkg only as default
    if [ "$ASK" = false ];then
      USRPKGLIST="$(echo "$PKGS" | $sort | head -1)"
      echo "$USRPKGLIST" > $TMPDIR/USRPKGLIST
    fi

    # user can now input which actual pkgs to get, chosen by number
    if [ "$ASK" = true ];then
      echo
      echo "Give the numbers of the packages you want to install,"
      echo -n "separated by a comma, or hit ENTER only to skip: "
      read USRPKGLIST1 </dev/tty
      echo

      # if user chose nothing (hit ENTER only), just skip
      [ "$USRPKGLIST1" = '' ] && exit 0

      # split the results into newlines, create the list of chosen pkgs (used by other funcs)
      echo "${USRPKGLIST1}" | tr ',' '\n' | while read LINE
      do
        # set chosen pkg choice(s)
        grep "^$LINE. " "$TMPDIR/PKGLIST" 2>/dev/null | cut -f2 -d' ' >> $TMPDIR/USRPKGLIST
      done
    fi

    # remove temp file.. but keep $TMPDIR/USRPKGLIST, it contains our users choices, and is used by pkg_get() and get_deps()
    rm $TMPDIR/PKGLIST &>/dev/null
  fi
}


pkg_get(){                        # find, download and install $1 and its deps FUNCLIST

  # The function `choose_pkg` is run just before this one. It gives us $TMPDIR/USRPKGLIST,
  # which contains a list of packages the user wants to install or download.
  # In this func, we will go through the list and download/install the package, as well
  # as its dependencies (depending on what the user chose to do).

  . ${PKGRC}

  # exit if no valid options
  [ ! "$1" ] || [ "$1" = "" ] || [ "$1" = "-" ] && print_usage get && exit 1

  local PREVDIR="$CURDIR"
  local pkg_ext=$(get_pkg_ext "$1"); pkg_ext="${pkg_ext:-$EX}" # fall back to repo extension
  local PKGNAME="$(get_pkg_name "$(basename "$1" .$pkg_ext)")"
  local PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")
  local PKGLIST="${PKGNAME}"
  local pkg_builtin=''

  # exit if no valid pkg name
  [ ! "$PKGNAME" ] || [ "$PKGNAME" = "" ] || [ "$PKGNAME" = "-" ] && print_usage get && exit 1

  # we want to download all pkgs to same place
  cd "$WORKDIR" || exit 1
  CURDIR="$WORKDIR"

  # use the list of pkgs user has chosen to install, or the given PKGNAME
  if [ -f $TMPDIR/USRPKGLIST ] && [ -s "$TMPDIR/USRPKGLIST" ];then
    PKGLIST="$(grep -v "^\$" "$TMPDIR/USRPKGLIST")"
  fi

  if [ -z "$PKGLIST" ];then
    echo "No packages to get, exiting."
    exit 1
  fi

  # list the pkgs and ask to download (and maybe install)
  echo "$PKGLIST" | while read pkg
  do

    [ -z "$pkg" ] && continue

    local pkg_name=$(get_pkg_name "$pkg" 2>/dev/null)
    [ "$pkg_name" = '' ] || [ ! "$pkg_name" ] && continue

    local pkg_name_only=$(get_pkg_name_only "$pkg" 2>/dev/null)
    [ "$(is_blacklisted_pkg "$pkg_name_only")" = true ] && continue

    local pkg_already_done=$(grep -m1 "^$pkg_name_only\$" $TMPDIR/PKGSDONE 2>/dev/null)
    [ "$pkg_already_done" != '' ] && continue

    local pkg_in_repo=$(is_repo_pkg "$pkg_name_only")
    local PKGFILE=''

    # dont even try to download if no matches found
    if [ "$pkg_in_repo" != true ] || [ "$pkg_name_only" = "" ];then
      echo "Cannot find ${PKGNAME}.."
      continue
    fi

    # get deps early (if any)
    list_deps "$pkg_name" > ${TMPDIR}/${pkg_name}_bgdep_list &

    local pkg_is_builtin=$(is_builtin_pkg "$pkg_name_only")
    local pkg_is_in_devx=$(is_devx_pkg "$pkg_name_only")

    # skip getting pkg if its a builtin, unless HIDE_BUILTINS=false
    if [ "$pkg_is_builtin" = true ] && [ "${HIDE_BUILTINS}" = true ];then
      echo "Skipping $pkg_name_only (already built-in).."
      continue
    fi

    # skip getting pkg if its in the devx, unless HIDE_BUILTINS=false
    if [ "$pkg_is_in_devx" = true ] && [ "${HIDE_BUILTINS}" = true ];then
      echo "Skipping $pkg_name_only (already in devx).."
      continue
    fi

    # if we are intending to install the pkg
    if [ "$NO_INSTALL" = false ] && [ "$FORCE" = false ];then
      # skip if package is already installed, unless --force given
      if [ "$FORCE" = false ] && [ "$(is_installed_pkg $pkg_name)" = true ];then
        echo -e "Package ${magenta}${pkg_name_only}${endcolour} already installed."
        echo -e "Use the -f option to force installation: $SELF add $pkg_name_only -f"
        continue
      fi
    fi

    # DOWNLOAD PKG
    ASK=false pkg_download "$pkg_name"

    # now lets find the downloaded package
    [ ! -f "$PKGFILE" ] && PKGFILE="$(find "$CURDIR" -maxdepth 1 -type f -name "$(get_pkg_filename "$pkg_name")")"

    if [ ! -f "$PKGFILE" ]; then
      PKGFILE_symlink="$(find "$CURDIR" -maxdepth 1 -type l -name "${pkg_name}*.*")"
      PKGFILE="$(readlink "$PKGFILE_symlink")"
      rm "$PKGFILE_symlink"
    fi

    # add extension if Pkg returned an erroneous or user dir
    [ -d "$PKGFILE" ] && PKGFILE="${PKGFILE}.$pkg_ext"

    if [ ! -f "${PKGFILE}" ];then
      echo "Can't find ${PKGNAME} or not a valid pkg.."
      continue
    fi

    # check if we install or not
    if [ "${NO_INSTALL}" = false ];then

      # if a valid pkg, with files to extract
      #if [ "$(pkg_contents "$PKGFILE" 2>/dev/null)" != '' ];then

        #INSTALL PKG
        ASK=false pkg_install "${PKGFILE}"

      #fi

    fi

    # if pkg was installed, or Pkg is simply downloading all deps
    if [ "$(is_installed_pkg "$pkg_name")" = true ] || [ "${NO_INSTALL}" = true ];then

      # get the dependencies for this package
      [ "$(has_deps $pkg_name)" = true ] && ASK=false get_deps "${pkg_name}"

    fi

    # done with this pkg, add it to done list, will be skipped it seen again, until loop is finished
    echo "$pkg_name_only" >> $TMPDIR/PKGSDONE
  done
}

get_latest_pkg() {
  [ -z "$1" ] && exit 1

  list_all_pkg_names "${1}${separator}" \
    | sort -n -r  \
    | head -1
}

pkg_update(){                     # update installed pkgs, $1 is optional filter FUNCLIST

  # exit if no valid options
  #[ ! "$1" ] || [ "$1" = "-" ] && print_usage pkg-update && exit 1

  # get rc file settings
  . "${PKGRC}"

  local PKGNAME=''
  local PKGLIST=''
  local pkg_ext=$EX

  if [ "$1" != '' ];then

    PKGNAME=$(basename "$1")
    PKGNAME=$(get_pkg_name "$PKGNAME")
    PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")

    # get installed packages
    INSTALLED_PKG_LIST="$(HIDE_BUILTINS=true list_installed_pkgs "$PKGNAME_ONLY")"

    #is_builtin=`is_builtin_pkg "$PKGNAME"`

    # dont update builtins unless -F was given
    #if [ "$is_builtin" = true ] && [ "$HIDE_BUILTINS" = true ];then
    #  echo -e "Package ${magenta}${PKGNAME}${endcolour} is built in, not updating."
    #  #echo -e "Use `$SELF -F --pkg-update $PKGNAME` to update it anyway."
    #  exit 0
    #fi
  else
    # get installed packages
    INSTALLED_PKG_LIST="$(HIDE_BUILTINS=true list_installed_pkgs)"
  fi

  # we don't want get_pkg to search this file, when it's called below,
  # as we're not writing the current packages to it, so remove the file
  rm -f $TMPDIR/USRPKGLIST 2>/dev/null

  # iterate over the list
  echo "$INSTALLED_PKG_LIST"  | grep -v ^$ | sort -u | while read installed_pkg
  do

    [ -z "$installed_pkg" ] && continue

    # skip pkg if its a builtin
    installed_pkg_name_only="$(get_pkg_name_only "${installed_pkg}")"
    [ "$(is_blacklisted_pkg "$installed_pkg_name_only")" = true ] && continue

    latest_pkg="$(get_latest_pkg "$installed_pkg_name_only")"
    [ -z "$latest_pkg" ] && continue


    if ! vercmp $(get_pkg_version "$latest_pkg") gt $(get_pkg_version "$installed_pkg")
    then
      echo -e "${green}Latest${endcolour}: $installed_pkg"
      continue
    fi

    ASKREPLY=y
    if [ "$ASK" = true ];then
      echo "Do you want to update to ${latest_pkg}? [y/N]   "
      read -n 1 ASKREPLY </dev/tty
      [ "$ASK" = true ] && echo -ne "\b\b\n"
    fi

    if [ "$ASK" = false ] || [ "$ASKREPLY" = "y" ];then
        (
          cd "$WORKDIR" &>/dev/null || exit 1

          repo_pkg="$(get_pkg_name "$installed_pkg")"
          echo -e "${yellow}Updating${endcolour} $repo_pkg"

          ASK=$ASK FORCE=$FORCE pkg_download "$latest_pkg" &>/dev/null && \
          {

            ASK=$ASK FORCE=true pkg_uninstall "$installed_pkg" &>/dev/null \
              && pkg_install "$latest_pkg" &>/dev/null

            echo -e "${yellow}Updated${endcolour}: ${bold}${magenta}$latest_pkg${endcolour}"

          } || pkg delete "$latest_pkg" &>/dev/null
        )
    fi

  done
}


pkg_uninstall(){                  # remove an installed package ($1) FUNCLIST

  # quit if no valid options
  [ ! "$1" ] || [ "$1" = "-" ] && print_usage uninstall && exit 1

  local PKGNAME
  local PKGNAME_ONLY
  local PKGFILE
  local PKGFILENAME
  local pkg_ext

  # get pkg extension
  pkg_ext=$(get_pkg_ext "$1")

  #get pkg name with version, but no extension or path
  PKGNAME="$(basename "$1" .$pkg_ext)"
  PKGNAME="$(basename "$PKGNAME" .pet)"
  PKGNAME="$(basename "$PKGNAME" .deb)"
  PKGNAME="$(basename "$PKGNAME" .sfs)"
  PKGNAME="$(basename "$PKGNAME" .tar.gz)"
  PKGNAME="$(basename "$PKGNAME" .tar.xz)"
  PKGNAME="$(basename "$PKGNAME" .tar.zst)"
  PKGNAME="$(basename "$PKGNAME" .tgz)"
  PKGNAME="$(basename "$PKGNAME" .txz)"
  PKGNAME="$(basename "$PKGNAME" .tzst)"
  PKGNAME=$(get_pkg_name "$PKGNAME")

  # get pkg name only .. without versions or suffix
  PKGNAME_ONLY="$(get_pkg_name_only "$PKGNAME")"

  local pkg_is_blacklisted=$(is_blacklisted_pkg "$PKGNAME_ONLY")

  # skip pkg if its a builtin
  [ "$pkg_is_blacklisted" = true ] && return 1

  local pkg_is_builtin=$(is_builtin_pkg "$PKGNAME_ONLY")

  # skip pkg if its a builtin
  [ "$pkg_is_builtin" = true ] && return 1

  local pkg_is_sfs_file="$(sfs_load -q -i | grep -v ^sfs_load | grep ^$PKGNAME)"

  # if pkg is SFS, "uninstall" it here
  if [ "$pkg_is_sfs_file" != "" ] || [ "$pkg_ext" = "sfs" ];then
    PKGNAME="$(sfs_load -q -i | grep -v ^sfs_load | grep ^$PKGNAME | head -1)"
    sfs_load -q --cli -"${CURDIR}/${PKGNAME}" 2>/dev/null
    is_installed=true # we want to continue
  fi

  local is_installed=$(is_installed_pkg "$PKGNAME")

  if [ "$is_installed" = false ] && [ "$FORCE" != true ];then
    # if any installed pkg matches $PKGNAME
    if [ "$(list_installed_pkgs $PKGNAME)" != "" ];then #290613
      # list the matching pkgs
      echo "These installed packages match '$PKGNAME':"
      list_installed_pkgs "$PKGNAME"
    fi

    return 1
  fi

  PKGFILENAME="$(get_pkg_filename "$PKGNAME")"
  # get the list of files to be deleted, exact match
  PKGFILE="$(find ${REPO_DIR}/ -maxdepth 1 -type f -name "$(basename "$PKGFILENAME" .$pkg_ext).files")"
  # if no exact match, search for pkgname*
  [ ! -f "$PKGFILE" ] && PKGFILE="$(find ${REPO_DIR}/ -maxdepth 1 -type f -name "${PKGNAME}*.files")"
  [ ! -f "$PKGFILE" ] && PKGFILE="$(find ${REPO_DIR}/ -maxdepth 1 -type f -name "${PKGNAME_ONLY}_*.files")"
  [ ! -f "$PKGFILE" ] && PKGFILE="$(find ${REPO_DIR}/ -maxdepth 1 -type f -name "${PKGNAME_ONLY}-*.files")"
  [ ! -f "$PKGFILE" ] && PKGFILE="${PKGNAME}.files"
  [ ! -f "$PKGFILE" ] && PKGFILE="${PKGNAME}.sfs.files"
  [ ! -f "$PKGFILE" ] && PKGFILE="${PKGNAME}-${CP_SUFFIX}.sfs.files"

  #if PKG.files not found, then remove it from alien packages list
  if [ ! -f "$PKGFILE" ];then

    #error "'${PKGFILE}' not found.. Cleaning up.."

    # backup the original list of user installed pkgs
    cp ${REPO_DIR}/user-installed-packages $TMPDIR/user-installed-packages.backup

    # remove $PKGNAME from list of installed pkgs
    grep -v "^${PKGNAME}" ${REPO_DIR}/user-installed-packages 2>/dev/null > ${REPO_DIR}/user-installed-packages.updated

    # if we created a new file ok
    if [ -f ${REPO_DIR}/user-installed-packages.updated ];then
      # replace the user-installed-packages file with our new one
      mv ${REPO_DIR}/user-installed-packages.updated ${REPO_DIR}/user-installed-packages
    fi

    # clean up user-installed-packages (remove duplicates and empty lines)
    grep -v "^\$" ${REPO_DIR}/user-installed-packages | uniq > ${REPO_DIR}/user-installed-packages.clean
    mv ${REPO_DIR}/user-installed-packages.clean ${REPO_DIR}/user-installed-packages

    # no *.files to process, so if not forcing full uninstall, we can exit here
    [ "$FORCE" != true ] && return 1
  fi

  # if we are here, we have a ${REPO_DIR}/***.files to work with (or using --force)

  # get pkgs that depend on $PKGNAME
  [ "$FORCE" = true ] && dependents='' || dependents="$(list_dependents "$PKGNAME")"

  # if we have dependents, we should not uninstall and just exit, unless --force was given
  if [ ! -z "$dependents" ] && [ "$(echo "$dependents" | grep -m1 'not installed')" = '' ] && [ "$FORCE" != true ];then
    # inform user of dependent pkgs
    echo -e "${yellow}Warning${endcolour}: $PKGNAME_ONLY is needed by:  "
    echo
    echo -e "${magenta}$(echo "$dependents" | sed 's/^/  /g')${endcolour}"
    echo
    echo "Uninstall the packages above first, or use:"
    echo -e "${bold}pkg uninstall $PKGNAME$ --force${endcolour}"
    echo
    return 1
  fi

  # ask/inform user before uninstall
  echo -n "Uninstall the package ${PKGNAME}$QTAG:  "
  [ "$ASK" = true ] && read -n 1 CONFIRM </dev/tty || CONFIRM=y
  [ "$ASK" = true ] && echo -ne "\b\b\n"

  # if user answered yes, we will now uninstall the pkgs
  if [ "$CONFIRM" != "y" ];then
    return 0
  fi

  # print new line if we didnt take any user input on tty
  [ "$ASK" != true ] && echo

  # run any relevant plugins
  ASK=$PLUGIN_ASK FORCE=$FORCE run_plugins 'pre_uninstall'

  # execute uninstall script.
  if [ -x "${REPO_DIR}/${PKGNAME}.remove" ];then
    ${REPO_DIR}/${PKGNAME}.remove &>/dev/null
    rm -f ${REPO_DIR}/${PKGNAME}.remove &>/dev/null
  fi

  # if we have no pkg file (listing of pkg contents), we cant cat/grep it
  if [ ! -f "$PKGFILE" ];then
    echo "Not found: ${REPO_DIR}/$PKGNAME.files"
    return 1
  fi

  # check if has menu entry
  grep -q -m1 ".desktop\$" "$PKGFILE" && HASMENUENTRY=true || HASMENUENTRY=false

  # remove files listed in *.files
  cat "$PKGFILE" | while read LINE
  do
    # some symlinks may not get removed. '-e' will not work if symlink
    # is pointing to a non-existent file. So, check for symlink...
    REMFILE=""
    [ -h "$LINE" ] && REMFILE="yes"
    [ -e "$LINE" ] && REMFILE="yes"
    if [ "$REMFILE" = "yes" ];then
      if [ ! -d "$LINE" ];then
        if [ -e "/initrd/pup_ro2$LINE" ];then
          # deleting the file on the top layer places a ".wh" whiteout file, that hides the original file.
          # what we want is to remove the installed file, and restore the original pristine file...
          cp -af "/initrd/pup_ro2${LINE}" "$LINE"
        else
          rm -f "$LINE" &>/dev/null
        fi
        #delete empty dirs...
        DELDIR="$(dirname "$LINE" 2>/dev/null)"
        [ "$(ls -1 "$DELDIR")" = "" ] && rmdir "$DELDIR" &>/dev/null
      fi
    fi
  done

  # go through again and remove any empty dirs...
  cat "$PKGFILE" 2>/dev/null  | while read LINE
  do
    DELDIR="$(dirname "$LINE" 2>/dev/null)"
    [ -d "$DELDIR" ] && [ "$(ls -1 "$DELDIR")" = "" ] && rmdir "$DELDIR"
    #check one level up... but do not delete top dir, like /opt...
    DELLEVELS=$(echo -n "$DELDIR" | sed -e 's/[^/]//g' | wc -c | sed -e 's/ //g')
    if [ $DELLEVELS -gt 2 ];then
      DELDIR="$(dirname "$DELDIR" 2>/dev/null)"
      [ -d "$DELDIR" ] && [ "$(ls -1 "$DELDIR")" = "" ] && rmdir $DELDIR
    fi
  done

  # remove $PKGNAME from user-installed-packages
  NEWUSERPKGS="$(grep -v "^${PKGNAME}" ${REPO_DIR}/user-installed-packages)"
  [ "$NEWUSERPKGS" != "" ] && echo "$NEWUSERPKGS" > ${REPO_DIR}/user-installed-packages

  # clean up user-installed-packages (remove duplicates and empty lines)
  grep -v "^\$" ${REPO_DIR}/user-installed-packages | uniq > ${REPO_DIR}/user-installed-packages_clean
  mv ${REPO_DIR}/user-installed-packages_clean ${REPO_DIR}/user-installed-packages

  # update system cache
  update_system_cache ${PKGFILE} 1>/dev/null 2>&1

  # remove ${REPO_DIR}/$PKGNAME.files
  rm $PKGFILE ${PKGFILE} 2>/dev/null

  # do fixmenus, if menu entry found
  if [ "$HASMENUENTRY" = true ];then
    [ ! -f /tmp/pkg/update_menus_busy ] && update_menus &
  fi

  # UNINSTALL DONE .. print message
  echo -e "${green}Uninstalled:${endcolour} $PKGNAME"

  # run any relevant plugins
  ASK=$PLUGIN_ASK FORCE=$FORCE run_plugins 'post_uninstall'

  # log uninstall with the system logs
  [ "$(which logger)" != '' ] && logger "$0 Package $PKGNAME uninstalled by $APP $APPVER"
}


pkg_remove(){                     # remove pkg ($1) and its leftover deps FUNC_LIST

  # quit if no valid options
  [ ! "$1" ] || [ "$1" = "-" ] && print_usage remove && exit 1

  local PKGNAME
  local PKGNAME_ONLY
  local PKGFILE
  local pkg_ext

  # get pkg extension
  pkg_ext=$(get_pkg_ext "$1")

  #get pkg name with version, but no extension or path
  PKGNAME="$(basename "$1" .$pkg_ext)"
  PKGNAME=$(get_pkg_name "$PKGNAME")

  # get pkg name only .. without versions or suffix
  PKGNAME_ONLY="$(get_pkg_name_only "$PKGNAME")"

  if [ "$(is_installed_pkg "$PKGNAME")" = false ];then
    echo "Package '$1' not installed."
    return 1
  fi

  pkg_uninstall "$PKGNAME"

  # now we will remove any left over dependencies

  file="$(find $TMPDIR -iname "${1}*_dep_list")"

  if [ -f "$file" ];then

    # if we have a deps list file, go over it three times, uninstalling all deps
    # that have no packages that depend on them ... fugly solution, but works ok..

    for x in 1 2 3 4
    do
      tr ' ' '\n' "$file" | while read user_installed_dep
      do
        [ "$user_installed_dep" = '' ] && continue
        ASK=false pkg_uninstall $user_installed_dep &>/dev/null && \
          echo -e "${green}Uninstalled:${endcolour} $(get_pkg_name $user_installed_dep)"
      done
    done

  fi

  return 0
}


clean_pkgs(){                     # delete downloaded pkg files of installed pkgs FUNCLIST
  local pkg_to_rm
  [ "$ASK" = true ] && ASKOPT='--ask'
  # list all (matching) installed pkgs
  list_installed_pkgs | while read line;
  do
    # get all pkgs except the combined (user-created) pkgs
    pkg_to_rm="$(list_downloaded_pkgs $line | grep -v $CP_SUFFIX)"
    # if it has a downloaded pkg in $WORKDIR, (offer to) delete it
    [ "$pkg_to_rm" != '' ] && rm -v "${WORKDIR:-?}/$pkg_to_rm";
  done
}


pkg_blacklist(){                  # give package name ($1) to "blacklist" (ignore) it

  # exit if no valid option
  [ ! "$1" ] || [ "$1" = "-" ] && print_usage blacklist && exit 1

  # skip if already in black list
  echo "$PKG_BLACKLIST" | grep -q -m1 "^${1}\$" && return 0
  # skip if its a builtin
  [ "$(is_builtin_pkg "$1")" = true ] && return 1

  echo "$1" >> ~/.pkg/blacklisted_packages
  sort -u ~/.pkg/blacklisted_packages > ~/.pkg/blacklisted_packages__sorted
  mv ~/.pkg/blacklisted_packages__sorted ~/.pkg/blacklisted_packages

  # regenerate the black list ($PKG_BLACKLIST)
  get_blacklist
}


pkg_whitelist(){                  # give package name ($1) to remove it from the "blacklist"

  # exit if no valid option
  [ ! "$1" ] || [ "$1" = "-" ] && print_usage whitelist && exit 1

  grep -v "^${1}\$" ~/.pkg/blacklisted_packages > ~/.pkg/blacklisted_packages__sorted
  mv ~/.pkg/blacklisted_packages__sorted ~/.pkg/blacklisted_packages

  # regenerate the black list ($PKG_BLACKLIST)
  get_blacklist
}


# dependency funcs

get_deps_entry(){                 # $1 is PKGNAME, returns dep entry from repo db
  [ "$1" = '' ] || [ "$1" = "-" ] && print_usage list-deps && exit 1

  local PKGNAME="$(get_pkg_name "$1")"
  local pkg_ext=''
  local repo_files=''
  local deps_list=''
  local deps=''
  local repo_of_pkg=''
  local repo_file_of_pkg=''

  # get pkg extension
  pkg_ext=$(get_pkg_ext "$1")


  # get repo file to search from RC file
  repo_file_of_pkg="$REPOFILE"

  # if searching dependencies in all repos
  if [ "$DEPSEARCH" = "list_all_pkg_names" ];then

    # get the repo that $PKGNAME lives in
    repo_of_pkg=$(which_repo "$PKGNAME" | cut -f2 -d' ' | head -1)
    # then get the repo file for that repo.. that is where this pkg lists its deps
    repo_file_of_pkg=$(grep -m1 ^"$repo_of_pkg|" ~/.pkg/sources-all | cut -f3 -d'|')

  fi

  # add the full path to the repo file
  repo_file_of_pkg="${REPO_DIR}/$repo_file_of_pkg"

  # search for deps entry in repo file.. look for ^pkgname|
  deps_list="$(LANG=C grep -m1 "^${PKGNAME}|" $repo_file_of_pkg 2>/dev/null)"

  # try again if needed.. look for |pkgname.$pkg_ext|
  [ -z "$deps_list" ] && [ "$PKGNAME" != '' ] && deps_list="$(LANG=C grep -m1 "|${PKGNAME}.$pkg_ext|" $repo_file_of_pkg 2>/dev/null)"

  # try again if needed.. look for |pkgname|
  [ -z "$deps_list" ] && [ "$PKGNAME" != '' ] && deps_list="$(LANG=C grep -m1 "|${PKGNAME}|" $repo_file_of_pkg 2>/dev/null)"

  # try again if needed.. look for |pkgfilename|
  [ -z "$deps_list" ] && [ "$PKGNAME" != '' ] && deps_list="$(LANG=C grep -m1 "|$(get_pkg_filename ${PKGNAME})|" $repo_file_of_pkg 2>/dev/null | head -1 | grep -m1 ^$PKGNAME)"

  # if no deps, exit with error
  [ -z "$deps_list" ] && return 1

  if [ ! -z "$deps_list" ];then
    echo "$deps_list"  \
      | cut -f9 -d'|'  \
      | grep '+'       \
      | sed            \
        -e "s/:any//g" \
        -e "s/&[geql][eqt][0-9a-z._-]*//g" \
      | grep -vE '/ge|/le'
  fi
}


list_all_installed_pkgs(){        # list inc builtins if HIDE_BUILTINS=false
  # reset list of installed pkgs
  echo -n '' > $TMPDIR/installed_pkgs

  if [ "${HIDE_INSTALLED}" = true ] && [ "$FORCE" = false ];then
    # add user installed pkgs to list of pkgs to remove from final output
    cut -f2 -d'|' ${REPO_DIR}/user-installed-packages >> $TMPDIR/installed_pkgs
  fi

  if [ "${HIDE_BUILTINS}" = true ];then
    # add builtins to list of pkgs to remove from final output
    cut -f2 -d'|' ${REPO_DIR}/woof-installed-packages >> $TMPDIR/installed_pkgs
  fi

  if [ -f ${REPO_DIR}/devx-installed-packages ];then
    # add devx pkgs to list of pkgs to remove from final output
    cut -f2 -d'|' ${REPO_DIR}/devx-installed-packages >> $TMPDIR/installed_pkgs
  fi

  if [ -f $TMPDIR/installed_pkgs ] && [ -s $TMPDIR/installed_pkgs ];then
    sort -u $TMPDIR/installed_pkgs | grep -v ^$ > $TMPDIR/installed_pkgs__sorted
    mv $TMPDIR/installed_pkgs__sorted $TMPDIR/installed_pkgs
  fi
}


has_deps(){                       # return true if $1 has deps, else false
  [ "$1" = '' ] || [ "$1" = "-" ] || [ ! "$1" ] && echo false
  [ "$(get_deps_entry $1)" != '' ] && echo true || echo false
}


list_deps(){                      # list all deps of PKG ($1), space separated on one line FUNCLIST
  [ "$1" = '' ] || [ "$1" = "-" ] && print_usage list-deps && exit 1

  # clean up
  rm ${TMPDIR}/missing_dep* ${TMPDIR}/installed_pkg* ${TMPDIR}/all_dep* ${TMPDIR}/DEP_DONE /tmp/pkg/list_deps_busy 2>/dev/null

  echo true > /tmp/pkg/list_deps_busy

  # get current $REPOFILE, $DEPSEARCH
  #. ${PKGRC}

  local PKGNAME=''
  local PKGNAME_ONLY=''
  local pkg_ext=''
  local repo_files=''
  local deps_list=''
  local deps=''
  local repo_of_pkg=''
  local repo_file_of_pkg=''

  # get pkg extension
  pkg_ext=$(get_pkg_ext "$1")

  #pkg name only ,no path, no extension
  PKGNAME=$(get_pkg_name "$1")
  PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")

  # get the deps of the pkg, note, in the repo deps are NOT listed by proper pkg names, .. they are +dbus,+glib,+SDL
  # search for deps entry in repo file.. look for |pkgname.ext|
  deps_list="$(LANG=C get_deps_entry "$PKGNAME")"

  # if no deps, exit with error
  [ "$deps_list" = "" ] && rm /tmp/pkg/list_deps_busy 2>/dev/null && return 1

  # change "+foo,+bar" to "foo bar"
  deps="${deps_list/+/}"                    # remove first + at start of line
  deps="${deps//,+/ }"                      # remove others .. DEPS will now be just 'dep1 dep2 dep3'
  deps="${deps//  / }"                      # remove double spaces
  deps="${deps//.pet/}"                     # remove extensions (creeping in from somewhere!)
  deps="${deps//.${EX:-noextension}/}"      # remove extensions (creeping in from somewhere!)
  deps="${deps//.${pkg_ext:-noextension}/}" # remove extensions (creeping in from somewhere!)


  if [ "$deps" = '' ] || [ "$deps" = ' ' ];then
    rm /tmp/pkg/list_deps_busy 2>/dev/null
    return 0
  fi

  # put all deps of pkg in a tmp file
  echo "${deps// /,}" | tr ',' '\n' | grep -v ^$ | sort -u > $TMPDIR/all_deps_0

  # create list of installed pkgs ($TMPDIR/installed_pkgs)
  list_all_installed_pkgs

  grep -vE "'$PKG_BLACKLIST_REGEX'" ${TMPDIR}/all_deps_0 2>/dev/null | sort -u > ${TMPDIR}/all_deps_0_without_blacklisted_packages
  mv ${TMPDIR}/all_deps_0_without_blacklisted_packages ${TMPDIR}/all_deps_0

  # remove any deps in installed pkgs list from all deps.. to leave only missing deps
  comm -23 ${TMPDIR}/all_deps_0 ${TMPDIR}/installed_pkgs 2>/dev/null | grep -v ^$ | sort -u > ${TMPDIR}/all_deps_0_cleaned
  mv ${TMPDIR}/all_deps_0_cleaned ${TMPDIR}/all_deps_0

  rm -f ${TMPDIR}/DEP_DONE 2>/dev/null

  if [ ! -f $TMPDIR/all_deps_0 ] || [ ! -s $TMPDIR/all_deps_0 ];then
    rm /tmp/pkg/list_deps_busy 2>/dev/null
    return 0
  fi

  # recursive search deps of deps
  for i in 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
  do
    deps_list_file="${TMPDIR}/all_deps_${i}"

    if [ ! -s $deps_list_file ];then
      continue
    fi

    # remove all blacklisted packages from the list
    grep -vE "'$PKG_BLACKLIST_REGEX'" "$deps_list_file" > ${TMPDIR}/deps_list_file_without_blacklisted_pkgs
    mv ${TMPDIR}/deps_list_file_without_blacklisted_pkgs  $deps_list_file

    # remove done packages from the $deps_list_file
    if [ -s ${TMPDIR}/DEP_DONE ];then
      comm -23 $deps_list_file ${TMPDIR}/DEP_DONE 2>/dev/null | grep -v ^$ | sort -u > ${deps_list_file}_cleaned
      mv ${deps_list_file}_cleaned ${deps_list_file}
    fi

    # remove installed pkgs from $deps_list_file
    if [ -s ${TMPDIR}/installed_pkgs ];then
      comm -23 $deps_list_file ${TMPDIR}/installed_pkgs 2>/dev/null | grep -v ^$ | sort -u > ${deps_list_file}_cleaned
      mv ${deps_list_file}_cleaned ${deps_list_file}
    fi

    # set name of next file
    next_deps_list_file="${TMPDIR}/all_deps_$(($i + 1))"

    # for each dep in $deps_list_file, put its deps into $next_deps_list_file..

    for current_dep in $(sort -u $deps_list_file | grep -v ^$ | sed -e "s/,$//g")
    do
      [ "$current_dep" = '' ] || [ "$current_dep" = ' ' ] && continue
      grep -q -m1 "$current_dep" ${TMPDIR}/installed_pkgs 2>/dev/null && continue
      grep -q -m1 "$current_dep" ${TMPDIR}/DEP_DONE 2>/dev/null && continue
      grep -q -m1 "$current_dep" $HOME/.pkg/blacklisted_packages 2>/dev/null && continue

      local subdeps=''
      local subdeps_list=''
      local subdeps_entry="$(get_deps_entry "$current_dep")"

      subdeps="${subdeps_entry/+/}"                   # remove first + at start of line
      subdeps="${subdeps//,+/ }"                      # remove others .. DEPS will now be just 'dep1 dep2 dep3'
      subdeps="${subdeps//  / }"                      # remove double spaces
      subdeps="${subdeps//.pet/}"                     # remove extensions (creeping in from somewhere!)
      subdeps="${subdeps//.${EX:-noextension}/}"      # remove extensions (creeping in from somewhere!)
      subdeps="${subdeps//.${pkg_ext:-noextension}/}" # remove extensions (creeping in from somewhere!)

      if [ "$subdeps" != '' ] && [ "$subdeps" != ' ' ];then
        # create the next deps list file to parse, containing the deps of this $current_dep
        echo "$subdeps" | tr ' ' '\n' | grep -v ^$ | sort -u >> $next_deps_list_file
        echo "$current_dep" >> ${TMPDIR}/DEP_DONE
      fi
    done

  done

  # add all deps together, sorted, duplicates removed
  cat ${TMPDIR}/all_deps_* 2>/dev/null | sort -u | grep -v ^$ > ${TMPDIR}/all_deps_sorted
  mv ${TMPDIR}/all_deps_sorted ${TMPDIR}/all_deps

  # remove tmp files, no longer needed
  rm ${TMPDIR}/all_deps_* &>/dev/null

  # remove any deps in installed pkgs list from all deps.. to leave only missing deps
  if [ -f ${TMPDIR}/installed_pkgs ] && [ -s  ${TMPDIR}/installed_pkgs ];then
    comm -23 ${TMPDIR}/all_deps ${TMPDIR}/installed_pkgs 2>/dev/null | sort -u | grep -v ^$ > ${TMPDIR}/missing_deps
  fi

  if [ ! -s ${TMPDIR}/missing_deps ];then
    rm /tmp/pkg/list_deps_busy 2>/dev/null
    return 0
  fi

  # remove all blacklisted packages from the list
  grep -vE "'$PKG_BLACKLIST_REGEX'" ${TMPDIR}/missing_deps 2>/dev/null | sort -u > ${TMPDIR}/missing_deps_without_blacklisted_pkgs
  mv ${TMPDIR}/missing_deps_without_blacklisted_pkgs ${TMPDIR}/missing_deps

  if [ ! -s ${TMPDIR}/missing_deps ];then
    rm /tmp/pkg/list_deps_busy 2>/dev/null
    return 0
  fi

  # get fixed deps list
  deps="$(LANG=C sort -u ${TMPDIR}/missing_deps 2>/dev/null | tr ' ' '\n' | while read dep
  do
    get_pkg_name_only "$dep"
  done)"

  # finally, print deps list
  [ "$deps" != "" ] && echo "$deps" | sed -e 's/^ //g' | tr '\n' ' '

  # clean up
  rm ${TMPDIR}/missing_dep* ${TMPDIR}/installed_pkg* ${TMPDIR}/all_dep* ${TMPDIR}/DEP_DONE /tmp/pkg/list_deps_busy 2>/dev/null
}


find_deps(){                      # given a package name ($1), makes 2 lists: DEPS_INSTALLED and DEPS_MISSING FUNCLIST
  # This function takes 1 argument: PKGNAME
  #
  # PKGNAME should be the name of a package in one of your repos,
  # such as 'vlc' or 'hardinfo'.
  #
  # This function creates 2 files: $TMPDIR/deps_missing and $TMPDIR/deps_installed.
  # Each file is list the dependencies for PKGNAME, each dependency on a new line.
  # get_deps() can then go through those files and download/install the missing deps.
  #
  # If --force was given, all deps will be treated as missing.

  # get current repo ($REPOFILE)
  . ${PKGRC}

  local PKGNAME=''            # the pkg given ($1), may be full name, or generic name (no version), etc
  local PKGNAME_ONLY=''       # the pkg given ($1), without version (vlc,htop,etc)
  local pkg_ext=''            # the pkg extension, blank if not a valid extension or none given
  local repo_files=''         # the list of repo files to check, may be current only or all
  local deps_list=''          # deps of PKGNAME in comma-delimited format: dep1,dep2,dep3
  local deps_missing=''       # comma separated list of missing deps
  local deps_installed=''     # comma separated list of deps already installed
  local deps_on_new_lines=''  # as above, but each dep on a new line
  local dep=''                # dep name scraped from deps_list, usually the same as dep_name_only
  local dep_name_only=''      # short (generic) pkg name, no version (vlc,htop,etc)
  local dep_full_name=''      # pkg name with version (vlc-2.3.3-i686_s700, etc)
  local loading_indicator     # blank if only a few deps to parse, or .

  # get pkg extension
  pkg_ext=$(get_pkg_ext "$1")

  # pkg name with version, but no path, no extension
  PKGNAME="$(basename "$1" .$pkg_ext)"

  # we can't rely on the user input, try to get the right pkg names
  PKGNAME=$(get_pkg_name "$PKGNAME")             # vlc -> vlc-2.3-blah_etc
  PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME")   # vlc-2.3-blah_etc -> vlc

  # if PKGNAME still empty, we cant find its deps, move on
  [ -z "$PKGNAME" ] && return 1

  # didnt exit yet, so remove the old tmp dirs
  rm ${TMPDIR}/all_deps     &>/dev/null
  rm $TMPDIR/deps_installed &>/dev/null
  rm $TMPDIR/deps_missing   &>/dev/null
  rm $TMPDIR/deps_missing1  &>/dev/null
  # reset the ENV vars other funcs listen to
  export DEPS_INSTALLED=''
  export DEPS_MISSING=''

  # get the list of deps from the repo entry of this pkg
  deps_list="$(LANG=C list_deps "$PKGNAME")"

  echo "${deps_list// /
}" | grep -v ^$ | sort -u > ${TMPDIR}/all_deps

  # create list of installed pkgs ($TMPDIR/installed_pkgs)
  list_all_installed_pkgs

  # remove any deps in installed pkgs list from all deps.. to leave only missing deps
  comm -23 ${TMPDIR}/all_deps ${TMPDIR}/installed_pkgs 2>/dev/null | grep -v ^$ | sort -u > ${TMPDIR}/missing_deps
  deps_list="$(grep -v "^$" "${TMPDIR}/missing_deps")"

  # exit if no deps to parse
  [ "$deps_list" = '' ] && return 1

  # so now, $deps_list='dep1 dep2 dep3'

  # now get the deps list with each dep on its own line
  deps_on_new_lines="${deps_list// /
}"

  # set a loading bar (appending dots....) if we have numerous deps to search
  [ $(echo "$deps_on_new_lines" | wc -l) -gt 4 ] && loading_indicator='.' || loading_indicator=''

  # now.. we go through ALL deps listed, and create a list for installed or not .. $dep will be 'gtkdialog3', for example
  for dep in $deps_list
  do
    # append dots as we go, like a loading spinner
    [ "$loading_indicator" = '.' ] && echo -n "$loading_indicator"

    # $dep is currently
    dep_full_name=$(get_pkg_name "$dep")     #vlc-2.3.3-i586_s700
    dep_name_only=$dep  #vlc

    # if we added this dep to the list of PKGs already done, skip it
    grep -q -m1 "^$dep_name_only\$" $TMPDIR/PKGSDONE 2>/dev/null && continue

    # skip these non pkgs
    [ "$(is_repo_pkg "$dep")" = false ] && continue

    # lets check if the $dep is installed or not

    # if dep was found in a repo and not installed, add to missing deps list
    if [ "$FORCE"  = true ] || [ "$(is_installed_pkg "$dep_full_name")" = false ];then
      grep -q -m1 "^$dep_name_only\$" $TMPDIR/deps_missing 2>/dev/null || \
      {
        echo "$dep_name_only" | grep -v "^$PKGNAME" >> $TMPDIR/deps_missing
      }

    else
      # else if the dep is already installed, add to installed deps list
      grep -q -m1 "^$dep_name_only\$" $TMPDIR/deps_installed 2>/dev/null || \
      {
        echo "$dep_name_only" | grep -v "^$PKGNAME" >> $TMPDIR/deps_installed
      }
    fi

    # clean up deps_installed, remove duplicates, etc
    if [ -f $TMPDIR/deps_installed ];then
      sort -u $TMPDIR/deps_installed 2>/dev/null > $TMPDIR/deps_installed1
      mv $TMPDIR/deps_installed1 $TMPDIR/deps_installed 2>/dev/null
    fi

  done # end of while $dep

  # make a comma separated list from newlines
  deps_installed="$(sort -u $TMPDIR/deps_installed 2>/dev/null | tr '\n' ',' | sed -e 's/,,/,/' -e 's/,$//' -e 's/^,//')"
  deps_missing="$(sort -u $TMPDIR/deps_missing 2>/dev/null | tr '\n' ',' | sed -e 's/,,/,/' -e 's/,$//' -e 's/^,//')"

  #120213, fixed, force all deps to be in the download list, if --force was given
  if [ "$FORCE" = true ];then
    # dont skip installed deps (except builtins.. handled elsewhere)
    if [ "$deps_installed" != "" ];then
      deps_missing="${deps_installed},${deps_missing}"
      deps_missing="$(echo "${deps_missing//,,/}" | sed -e 's/,$//' -e 's/^,//')"
    fi
  fi

  # later, get_deps() will use $DEPS_MISSING and $DEPS_INSTALLED
  DEPS_MISSING="$deps_missing"
  DEPS_INSTALLED="$deps_installed"

  # end appending dots... msg, by printing a new line
  [ "$loading_indicator" != '' ] && echo

}


get_deps(){                       # find, get and install the deps of pkgname ($1) FUNCLIST

  [ -z "$1" ] || [ ! "$1" ] || [ "$1" = "-" ] && print_usage deps && exit 1

  . ${PKGRC} #150813

  local EX
  local PKGNAME
  local DEPCONFIRM

  # get pkg extension
  local EX=$(get_pkg_ext "$1")

  # get pkg name with version, but no path, no extension
  local PKGNAME="$(LANG=C basename "$1" .$EX)"

  # don't rely on user input, get the name w version from repos
  local PKGNAME=$(get_pkg_name "$PKGNAME" 2>/dev/null)
  local PKGNAME_ONLY=$(get_pkg_name_only "$PKGNAME" 2>/dev/null)

  # if pkg is blacklisted, also skip it
  local pkg_is_blacklisted=$(is_blacklisted_pkg "$PKGNAME_ONLY" 2>/dev/null)
  [ "$pkg_is_blacklisted" = true ] && return

  # if pkg is builtin, skip it, we dont need to get its dependencies
  local pkg_is_builtin=$(is_builtin_pkg "$PKGNAME_ONLY" 2>/dev/null)
  [ "$pkg_is_builtin" = true ] && [ "$HIDE_BUILTINS" = true ] && return

  # skip if already processed, it should be listed in $TMPDIR/PKGSDONE
  local pkg_already_done=$(LANG=C grep -m1 "^$PKGNAME_ONLY\$" $TMPDIR/PKGSDONE 2>/dev/null)
  [ "$pkg_already_done" != "" ] && [ "$FORCE" = false ] && return

  echo -n "Resolving dependencies.." # find deps will append ... as it goes

  # wait until list_deps() is finished (if it's running at all...)
  while [ -f /tmp/pkg/list_deps_busy ];do
    echo -n '.'
    sleep 0.75
  done

  echo

  # if list_deps() created a file listing the deps, get it from the file created, else, run list deps to be sure
  if [ -s ${TMPDIR}/${PKGNAME}_bgdep_list ];then
    DEPS_MISSING="$(cat ${TMPDIR}/${PKGNAME}_bgdep_list)"
  else
    DEPS_MISSING="$(list_deps "$PKGNAME" 2>/dev/null)"
  fi

  # if we have missing deps, or are downloading them all regardless (INSTALLDEPS=false), or using --force
  if [ "$DEPS_MISSING" != "" ] || [ "${NO_INSTALL}" = true ] || [ "$FORCE" = true ];then
    # ask to download (and maybe install) the deps
    DEPCONFIRM=y
    if [ "$ASK" = true ];then
      echo "Missing deps: $DEPS_MISSING"
      echo -n "Download the missing dependencies$QTAG:  "
      read -n 1 DEPCONFIRM </dev/tty
      echo
      # skip if user chose --ask and didn't answer 'y'
      [ "$DEPCONFIRM" != "y" ] && return
    fi

    # if user answered yes, we will now download (and maybe install) the deps
    if [ "$DEPCONFIRM" = "y" ] || [ "$FORCE" = true ];then

      # make a list of the deps, each on a new line for each dep/newline
      WARNLIBS='';

      # clean up our deps list, and make space separated only (no commas)
      DEPS_MISSING="${DEPS_MISSING//,/ }"
      DEPS_MISSING="${DEPS_MISSING//.pet/}"             # remove extensions (creeping in from somewhere!)
      DEPS_MISSING="${DEPS_MISSING//.${EX:-noextension}/}"       # remove extensions (creeping in from somewhere!)
      DEPS_MISSING="${DEPS_MISSING//.${pkg_ext:-noextension}/}"  # remove extensions (creeping in from somewhere!)

      # show deps info, if any available
      [ "${DEPS_MISSING}" != ""  ]   && echo "Dependencies to get: ${DEPS_MISSING//,/, }"
      [ "$FORCE" = false ] && [ "${DEPS_INSTALLED}" != "" ] \
        && echo "Dependencies installed: $(LANG=C grep -v "^\$" $TMPDIR/deps_installed 2>/dev/null | head -1)"

      # for each missing dep  (or simply for each dep, if $FORCE is true)
      for DEP in ${DEPS_MISSING//,/ }
      do

        #skip if the dep is the main package
        [ "$DEP" = "" ] || [ "$DEP" = "${PKGNAME_ONLY}" ] || [ "$DEP" = "${PKGNAME}" ] && continue

        local DEPNAME_ONLY="$DEP"
        local DEPFILE=''

        # skip getting pkg if its blacklisted
        local dep_is_blacklisted=$(is_blacklisted_pkg "$DEPNAME_ONLY" 2>/dev/null)
        if [ "$dep_is_blacklisted" = true ];then
          echo "Skipping $DEPNAME_ONLY (blacklisted).."
          continue
        fi

        # skip getting pkg if its a builtin, unless HIDE_BUILTINS=false
        local dep_is_builtin=$(is_builtin_pkg "$DEPNAME_ONLY" 2>/dev/null)
        if [ "$dep_is_builtin" = true ] && [ "${HIDE_BUILTINS}" = true ];then
          echo "Skipping $DEPNAME_ONLY (already built-in).."
          continue
        fi

        # skip if already processed, it should be listed in $TMPDIR/PKGSDONE
        local dep_already_done=$(LANG=C grep -m1 "^$DEPNAME_ONLY\$" $TMPDIR/PKGSDONE 2>/dev/null)
        [ "$dep_already_done" != "" ] && [ "$FORCE" = false ] && continue

        # skip getting pkg if its user installed and not using --force
        local dep_is_usr_pkg=$(is_usr_pkg "$DEPNAME_ONLY" 2>/dev/null)
        if [ "$dep_is_usr_pkg" = true ] && [ "${FORCE}" != true ];then
          echo "Skipping $DEPNAME_ONLY (already installed).."
          continue
        fi

        # skip getting pkg if its in the devx, unless HIDE_BUILTINS=false
        local dep_is_in_devx=$(is_devx_pkg "$DEPNAME_ONLY" 2>/dev/null)
        if [ "$dep_is_in_devx" = true ] && [ "${HIDE_BUILTINS}" = true ];then
          echo "Skipping $DEPNAME_ONLY (already built-in).."
          continue
        fi

        local DEPNAME=$(get_pkg_name "$DEP" 2>/dev/null)

        #DOWNLOAD THE PKG
        ASK=false pkg_download "$DEPNAME" 2>/dev/null

        # skip install unless NO_INSTALL=true
        if [ "${NO_INSTALL}" = false ];then

          # get the actual file we just downloaded to WORKDIR
          DEPFILE="$(find "$WORKDIR" -maxdepth 1 -type f -name "$DEPNAME*" 2>/dev/null)"

          #INSTALL THE DEP, if it was downloaded
          [ "$(is_local_pkg "$DEPFILE" 2>/dev/null)" = true ] && pkg_install "$DEPFILE" 2>/dev/null

          # mark the pkg as done!
          echo "$DEPNAME_ONLY" >> $TMPDIR/PKGSDONE

        else # if not installing,
          # skip dep checking of the deps that dont get installed
          continue
        fi


        # we finished with this dep, mark it done,
        # .. so we can skip it if it appears again (in a recursive dep check loop for example)
        echo "$DEPNAME_ONLY" >> $TMPDIR/PKGSDONE #260713


      done #done for DEP in DEPS_MISSING

    fi #endif DEPCONFIM=y

  else
    echo "No missing dependencies."
  fi # endif DEPS_MISSING != ''

  # if some deps were missing (listed but not found), print msg
  [ "$INSTALLDEPS" = true ] && actioned=installed || actioned=downloaded
  [ "$WARNLIBS" != "" ]     && echo -e "${yellow}Warning:${endcolour} Not $actioned from repo: $WARNLIBS"
  #exit 0 #110913
}


pkg_ldd(){                    # check given package ($1) for missing deps FUNCLIST

  # exit if no valid usage
  [ ! "$1" ] || [ "$1" = "-" ] && print_usage deps-check && exit 1

  . "${PKGRC}"

  local PKGNAME
  local FNDFILES
  local RES
  local MISSING
  local list

  # get pkg name
  PKGNAME=$(get_pkg_name "$1")
  rm $TMPDIR/pkg-$PKGNAME-MISSING.txt &>/dev/null

  [ "$(is_installed_pkg "$PKGNAME")" = false ] && print_usage deps-check && exit 1

  echo "Searching for missing dependencies.. Please wait."

  if [ "$NON_RECURSIVE" = true ];then
    list="$PKGNAME"
  else
    list="$PKGNAME $(list_deps $PKGNAME)"
  fi

  [ -f $TMPDIR/ldd_done ] && rm $TMPDIR/ldd_done
  for pkg_name in $list
  do
    if [ -f $TMPDIR/ldd_done ];then
      grep -q -m1 "$pkg_name" $TMPDIR/ldd_done && continue
    fi
    local pkg_name_only=$(get_pkg_name_only "$pkg_name")
    # get the *.files for this pkg
    FNDFILES="$(find ${REPO_DIR}/ -iname "${pkg_name}.files" 2>/dev/null)"
    [ ! -f "$FNDFILES" ] && FNDFILES="$(find ${REPO_DIR}/ -iname "${pkg_name}_*.files" 2>/dev/null)"
    [ ! -f "$FNDFILES" ] && FNDFILES="$(find ${REPO_DIR}/ -iname "${pkg_name}-*.files" 2>/dev/null)"
    [ ! -f "$FNDFILES" ] && FNDFILES="$(find ${REPO_DIR}/ -iname "${pkg_name}*.files"  2>/dev/null)"
    [ ! -f "$FNDFILES" ] && continue

    # get list of ldd-able file
    cat "$FNDFILES" | grep -E '/lib/|/lib64/|/bin/|/games/|/sbin/' > ${TMPDIR}/ldd_file_list_${pkg_name}
    [ ! -s ${TMPDIR}/ldd_file_list_${pkg_name} ] && continue

    #loop through list
    for file in $(cat ${TMPDIR}/ldd_file_list_${pkg_name})
    do
      [ ! -x "$file" ] && continue
      RES="$(ldd $file 2>/dev/null)"
      MISSING="$(echo "$RES" | grep found)"
      if [ "$MISSING" != "" ] && [ "$MISSING" != " " ];then
        echo "  $file: " >> $TMPDIR/${pkg_name}-MISSINGLIBS.txt
        echo "$MISSING" | sed 's/^/  /g' >> $TMPDIR/${pkg_name}-MISSINGLIBS.txt
      fi
    done

    #print message
    if [ -f $TMPDIR/${pkg_name}-MISSINGLIBS.txt ];then
      echo -e "${yellow}WARNING${endcolour}: ${magenta}${pkg_name_only}${endcolour} has missing dependencies: "
      echo -e "$(cat $TMPDIR/${pkg_name}-MISSINGLIBS.txt)"
    else
      [ "$PKGFIX" = "" ] && echo -e "${green}OK:${endcolour} ${pkg_name} has no missing dependencies."
    fi
    rm -f ${TMPDIR}/ldd_file_list* $TMPDIR/${pkg_name}-MISSINGLIBS.txt 2>/dev/null
    echo "$pkg_name" >> $TMPDIR/ldd_done
  done
  # install any missing packages, if possible
  if [ "$PKGFIX" != "" ] && [ ! -z "$MISSING" ];then
    echo "Installing missing packages:"
    echo "$MISSING" | sed 's/\.so.*//g' | while read dep
    do
      depname=$(list_all_pkg_names $dep | head -1)
      [ ! -z "$depname" ] && pkg_get $depname
    done
  fi
  [ -f $TMPDIR/ldd_done ] && rm $TMPDIR/ldd_done
}


get_all_deps(){                   # try to install all missing deps FUNCLIST
 echo "Checking $(list_installed_pkgs | wc -l) installed packages for missing dependencies. Please wait..."
 rm $TMPDIR/pkg_get_all_deps 2>/dev/null

 list_installed_pkgs | while read LINE; do
  DEPLIST="$(LANG=C list_deps "$LINE")"
  [ "$DEPLIST" != "" ] && [ "$LINE" != "" ] && echo "$LINE|$DEPLIST" >> $TMPDIR/pkg_get_all_deps
 done

 [ ! -f $TMPDIR/pkg_get_all_deps ] && echo "No missing dependencies." && exit 0

 ASKOPT='';   [ "$ASK" = true   ] && export ASKOPT='--ask ';
 FORCEOPT=''; [ "$FORCE" = true ] && export FORCEOPT='--force ';

 cat $TMPDIR/pkg_get_all_deps 2>/dev/null | while read LINE
 do
  [ "$LINE" = "" ] || [ "$(echo "$LINE" | grep -v '|')" = "" ] && continue
  # get pkg gname from field 1
  PKGNAME="${LINE%%|*}"
  DEPS="${LINE##*|}"

  echo "Checking $PKGNAME..."

  for DEP in $DEPS
  do
    # try to get the pkg name
    DEPPKG="$(list_all_pkg_names $DEP-)" || \
    DEPPKG="$(list_all_pkg_names $DEP_)" || \
    DEPPKG="$(list_all_pkg_names $DEP)"
    # if dep not in any repos, skip it
    [ "$DEPPKG" = "" ] && continue
    DEPPKG="$(echo "$DEPPKG" | head -1)"
    # skip if the dep is already installed
    [ "$(is_installed_pkg "$DEPPKG")" = true ] && continue
    # ask to get dep
    echo -n "Get the missing package: ${DEPPKG}$QTAG:  "
    echo
    [ "$ASK" = true ] && read -n 1 CONFIRM </dev/tty || CONFIRM=y
    [ "$ASK" = true ] && echo -ne "\b\b\n"
    # if user answered yes, we will now download the pkgs
    if [ "$CONFIRM" = "y" ];then
      NO_INSTALL=false pkg_get "$DEPPKG" # get the missing dep (and its deps)
    fi
  done
 done
 rm -f $TMPDIR/pkg_get_all_deps 2>/dev/null
}


list_dependents(){                # list user installed pkgs that depend on $1 FUNCLIST

  local PKGNAME=''
  local PKGNAME_ONLY=''

  if [ "$1" = '' ];then
    print_usage what-needs
    exit 1
  fi

  # try to get correct pkg names
  PKGNAME=$(get_pkg_name "$1")
  PKGNAME_ONLY=$(get_pkg_name_only "$1")

  # if pkg is not installed, then nothing depends on it
  if [ "$(is_installed_pkg "$PKGNAME")" = false ];then
    echo "Package $1 not installed, nothing depends on it."
    exit 1
  fi

  # list all pkgs (from all repos) with $PKGNAME_ONLY as a dep
  cut -f1,2,9 -d'|' ${REPO_DIR}/Packages-* \
    | sed -e "s/:any//g" -e "s/&[geql][eqt][0-9a-z._-]*//g" 2>/dev/null \
    | grep -E "+${PKGNAME_ONLY},|+${PKGNAME_ONLY}\|" 2>/dev/null \
    | cut -f2 -d'|' \
    | grep -v "^\$" \
    | grep -v "^#"  \
    | grep -v "^$PKGNAME_ONLY\$" \
    | sort -u \
    > ${TMPDIR}/dependents_list_all

  if [ "$HIDE_BUILTINS" = false ];then
    # list all builtin and devx packages with $PKGNAME_ONLY as a dependency..
    cut -f1,2,9 -d'|' ${REPO_DIR}/woof-installed-packages ${REPO_DIR}/devx-installed-packages \
      ${REPO_DIR}/devx-only-installed-packages \
      | grep -E "+${PKGNAME_ONLY},|+${PKGNAME_ONLY}\|" \
      | cut -f2 -d'|' \
      | grep -v "^\$" \
      | grep -v "^#"  \
      | grep -v "^$PKGNAME_ONLY\$" \
      | sort -u \
      >> ${TMPDIR}/dependents_list_all
  fi

  # remove duplicates
  sort -u ${TMPDIR}/dependents_list_all | grep -v ^$ > ${TMPDIR}/dependents_list_all__sorted
  mv ${TMPDIR}/dependents_list_all__sorted ${TMPDIR}/dependents_list_all

  # remove packages that are not installed
  cut -f2 -d'|' ${REPO_DIR}/user-installed-packages | sort -u | grep -v ^$ > $TMPDIR/user-installed_sorted
  comm -12 ${TMPDIR}/dependents_list_all $TMPDIR/user-installed_sorted | sort -u > ${TMPDIR}/dependents_list

  # print the list if we have one
  [ -f ${TMPDIR}/dependents_list ] && [ -s ${TMPDIR}/dependents_list ] && cat ${TMPDIR}/dependents_list

  rm ${TMPDIR}/dependents_lis* 2>/dev/null
}


# file conversion

deb2pet(){                        # $1 must be valid deb file or repo pkg FUNCLIST
  [ ! -f "$1" ] && print_usage deb2pet && exit 1

  local DEB="${CURDIR}/$(basename "${1}")"
  local DIRNAME="${CURDIR}"
  #create file name we work with
  [ -f "$1" ] && DEB="$1" && DIRNAME="$(dirname "$1")"

  #keep old file, download it if needed
  #[ -f "$(basename "$1" .deb)" ] || ASK=$ASK FORCE=$FORCE pkg_download "$(basename "$1" .deb)"

  # if the deb exists
  if [ -e "$DEB" ]; then
    #remove the extensions
    #example, will be something like FOLDR=$HOME/Desktop/atari800_3.1.0-2+b2_i386
    FOLDR="$(echo "$DEB"|sed 's/\.deb$//')"

    #make the new dir, copy the deb file into it, and cd into it
    mkdir -p "$FOLDR"; cp "$DEB" "$FOLDR"; cd "$FOLDR";

    #get the new full path and filename
    DEB="$(ls | grep ".deb")"

    # extract into current dir and remov ethe copied deb file
    pkg_unpack "$DEB" 1>/dev/null

    #this will be something like  PKGNAME=atari800_3.1.0-2+b2_i386
    PKGNAME="`basename "$DEB" .deb`"

    # the folders unpacked do not always match $PKGNAME, so look for it
    FOLDR_FIRST5CHARS=$(echo "${FOLDR:0:5}")
    PKGNAME=$(find "$CURDIR/$FOLDR" -maxdepth 1 -type d -name "$FOLDR_FIRST5CHARS*" | sed 's#.*/##g')

    #now we package up the stuff into a pet
    [ -d "${CURDIR}/${FOLDR}/${PKGNAME}" ] \
      && dir2pet "${CURDIR}/${FOLDR}/${PKGNAME}" \
      || error "Directory '${CURDIR}/${FOLDR}/${PKGNAME}' could not be found after unpacking '$DEB'."

    [ ! -f "$FOLDR.pet" ] && [ ! -f "${CURDIR}/${PKGNAME}.pet" ] && error "$FOLDR.deb NOT converted to PET package!"

    #clean up
    cd "$CURDIR"
    rm -rf "$FOLDR"

  else
    echo "Package '$(basename $DEB)' not found in '$CURDIR'."
    return 1
  fi
}


dir2pet(){                        # dir to PET, $1 must be valid dir FUNCLIST

  # exit if no options
  [ ! -d "$1" ] && print_usage dir2pet && exit 1

  DIR="$1"
  SUFFIX=''

  [ "$2" != "" ] && SUFFIX="$2"

  #[ -d "$DIR" ] && cd `dirname "$DIR"`

  # get pkg name only,
  DIR="$(basename "${DIR}")"
  [ "$SUFFIX" != "" ] && cp -R "$DIR" "${DIR}${SUFFIX}" && DIR="${DIR}${SUFFIX}"

  echo -e "Converting directory ${lightblue}$DIR${endcolour} to .pet package."

  # we must have a dir with same name as a valid pkg
  if [ -d "$DIR" ];then
    # move it to the build dir, to work on
    mkdir -p "$CURDIR/build_pkg/"
    [ ! -e "$CURDIR/build_pkg/$DIR" ] && cp -R "$DIR" "$CURDIR/build_pkg/"

    ARCHINDEPENDENT='yes'
    for ONEEXEC in `find $CURDIR/build_pkg/${DIR}/ -maxdepth 6 -type f -perm -o+x`
    do
      [ -f $ONEEXEC ] && [ "`file $ONEEXEC | grep ' ELF '`" != "" ] && ARCHINDEPENDENT='no'
    done

    # if it's a _DEV pkg.. it can't be ARCHINDEPENDENT
    case "${BASEPKG}" in *"_DEV"*) ARCHINDEPENDENT='no' ;; esac
    [ "`find $CURDIR/build_pkg/${DIR}/ -maxdepth 6 -type f -name '*.a' -o -type f -name 'lib*.so*' -o -type f -name '*.la'`" != "" ] && ARCHINDEPENDENT='no'
    [ "$ARCHINDEPENDENT" = "no" ] && COMPAT=$DISTRO_BINARY_COMPAT V=$DISTRO_COMPAT_VERSION

        #...borrowed from dir2pet script
    #w482 directory may already have a pet.specs, reuse it...
    NAMEONLY=""
    PUPMENUDESCR=""
    PUPOFFICIALDEPS=""
    PUPCATEGORY=""
    PUPPATH="" #100201
    ARCHDEPENDENT="yes" #100201
    DEFREPO="" #100201
    if [ -f $CURDIR/build_pkg/${DIR}/pet.specs ];then #160803
     #new: pkgname|nameonly|version|pkgrelease|category|size|path|fullfilename|dependencies|description|
     #optionally on the end: compileddistro|compiledrelease|repo| (fields 11,12,13)
     PETSPECS="`cat $CURDIR/build_pkg/${DIR}/pet.specs | head -n 1`" #160803
     while IFS="|" read -r F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 <&3
     do
       DB_pkgname="$F1"
       DB_nameonly="$F2"
       NAMEONLY="$DB_nameonly"
       DB_version="$F3"
       DB_pkgrelease="$F4"
       DB_category="$F5"
       PUPCATEGORY="$DB_category"
       DB_size="$F6"
       DB_path="$F7"
       PUPPATH="$DB_path" #100201
       DB_fullfilename="$F8"
       DB_dependencies="$F9"
       PUPOFFICIALDEPS="$DB_dependencies"
       DB_description="$F10"
       PUPMENUDESCR="$DB_description"
       DB_compileddistro="$F11"
       DB_compiledrelease="$F12"
       ARCHDEPENDENT="${DB_compileddistro}|${DB_compiledrelease}"
       DB_repo="$F13"
       DEFREPO="$DB_repo"
      done 3< $CURDIR/build_pkg/${DIR}/pet.specs
    else
      echo -e "\nCategories:
  BuildingBlock, Desktop, System, Setup, Utility,
  Filesystem, Graphic, Document, Business, Personal,
  Network, Internet, Multimedia, Fun\n"
      read -p 'Type one of the categories above, then hit ENTER: ' CAT_ENTRY </dev/tty;

      echo
      read -p "Add a short description, then hit ENTER: " DESC_ENTRY </dev/tty;

      echo -e "\nAdd dependencies in this format:  ${bold}+libglib,+ffmpeg${endcolour}\n"
      read -p 'Enter dependencies (if any), then hit ENTER: ' DEPS_ENTRY </dev/tty;

      echo "${DIR}|$(get_pkg_name_only "$DIR")|$(get_pkg_version "$DIR")||${CAT_ENTRY:-Utility}|$(du -h "$CURDIR/build_pkg/${DIR}/" | tail -1 | cut -f1)||${DIR}.pet|${DEPS_ENTRY}|${DESC_ENTRY:-No description}|$COMPAT|$V||" > $CURDIR/build_pkg/${DIR}/pet.specs
    fi

    # build .pet.specs

    BASEPKG="`basename $DIR`"
    DIRPKG="`dirname $DIR`"
    [ "$DIRPKG" = "/" ] && DIRPKG=""

    #difficult task, separate package name from version part...
    #not perfect, some start with non-numeric version info...
    [ "$NAMEONLY" = "" ] && NAMEONLY=`get_pkg_name_only "$BASEPKG"`

    # get pet details from the pre-existing pet.specs (if any): deps, category, descr, version, nameonly, arch, distro version
    PUPOFFICIALDEPS="$DB_dependencies"

    TOPCAT="$PUPCATEGORY"
    [ -z "$TOPCAT" ] && TOPCAT=BuildingBlock

    PUPMENUDESCR="$DB_description"
    [ -z "${PUPMENUDESCR}" ] && PUPMENUDESCR="No description provided"

    VERSION="`get_pkg_version "$BASEPKG"`"

    # build pet spec
    if [ ! -f $CURDIR/build_pkg/${DIR}/pet.specs ];then
      echo "$BASEPKG|${NAMEONLY}|$VERSION|$DB_pkgrelease|$TOPCAT|$DB_size|$REPO_SUBDIR|${BASEPKG}.pet|$PUPOFFICIALDEPS|$PUPMENUDESCR|$COMPAT|$V||" > $CURDIR/build_pkg/${DIR}/pet.specs
    fi

    # delete the slackware package management files
    #if [ -d "$CURDIR/build_pkg/install" ];then
    # rm -r "$CURDIR/build_pkg/install"; rmdir "$CURDIR/build_pkg/install";
    #fi

    # delete arch pkg stuff
    #rm -r "$CURDIR/build_pkg/.INSTALL" &>/dev/null
    #rm "$CURDIR/build_pkg/.PKGINFO" &>/dev/null

    # now tar up the folder, ready to make into tar.gz, then into .pet
    cd $CURDIR/build_pkg/

    # we need to choose xz or gzip pets
    arch=`uname -m`
    if [ "${arch:0:3}" = "arm" ];then
      TAREXT="gz"
    else
      TAREXT="xz"
    fi

    # if in a pre-woof puppy then we dont use xz
    if [ ! -f ${REPO_DIR}/woof-installed-packages ] || [ ! -f /etc/DISTRO_SPECS ];then
      # pre woof format
      echo "PETMENUDESCR='${DIR}'" >  $CURDIR/build_pkg/${DIR}/${DIR}.pet.specs
      echo "PETOFFICIALDEPS=''"    >> $CURDIR/build_pkg/${DIR}/${DIR}.pet.specs
      echo "PETREGISTER='yes'"     >> $CURDIR/build_pkg/${DIR}/${DIR}.pet.specs
      compression=xz
      TAREXT="xz"
    fi
    tar -c -f ${DIR}.tar ${DIR} 1>/dev/null
    sync
    [ "`which xz`" = "" ] && TAREXT=gz
    case $TAREXT in
      xz)xz -z -9 -e ${DIR}.tar ;;
      gz)gzip --best ${DIR}.tar ;;
    esac

    # now get info needed to make a pet file
    TARBALL="${DIR}.tar.$TAREXT"
    FULLSIZE="`stat --format=%s ${TARBALL}`"
    MD5SUM="`md5sum $TARBALL | cut -f 1 -d ' '`"

    # add the info to the file
    echo -n "$MD5SUM" >> $TARBALL
    sync

    # now rename it to .pet
    mv -f $TARBALL ${DIR}.pet
    sync

    # move the created pet out of build_pkg, into WORK_DIR
    mv ${DIR}.pet $CURDIR/${DIR}.pet
    cd $CURDIR

    # clean up
    rm -f -R $CURDIR/build_pkg/

    size=$(LANG=C du -m "${DIR}.pet" | sed "s/\s.*//")

    echo
    echo -e "Package ${magenta}${DIR}.pet${endcolour} created ($size MB)"
    echo "The md5sum is: `md5sum ${DIR}.pet | cut -f1 -d' '`."
  else
    echo "Directory '$DIR' not found."
    exit 1
  fi
}


dir2sfs(){                        # $1 must be dir of pkg contents FUNCLIST

  if [ ! -d "$1" ];then
    print_usage dir2sfs
    exit 1
  fi

  # if found, we will append it to the SFS filename
  [ "$DISTRO_VERSION" != "" ] && SFS_SUFFIX="_${DISTRO_VERSION}" || SFS_SUFFIX=''

  # get sfs name only, no extension or path
  SFS_DIR="`basename "$1" .sfs`"

  # if a valid dir
  if [ -d "$SFS_DIR" ];then
    rm "${SFS_DIR}/"*pet*specs 2>/dev/null #240613
    #start building the sfs file
    echo "Please wait... building SFS file.."
    local SFS_NAME="${SFS_DIR/$SFS_SUFFIX/}${SFS_SUFFIX}.sfs"
    LANG=C mksquashfs "$SFS_DIR" "$SFS_NAME" -noappend &>/dev/null && SUCCESS="y" || SUCCESS=""
    if [ -z "$SUCCESS" ] && [ ! -f "${SFS_DIR}${SFS_SUFFIX}.sfs" ]; then
      echo "Failed to create $SFS_NAME."
      exit 1
    fi
    chmod 644 "$SFS_NAME" #shinobar
    sync
    #get size, and output msg
    s=`LANG=C du -m "$SFS_NAME" | sed "s/\s.*//"`
    MD5SUM=`md5sum "$SFS_NAME" | cut -f1 -d ' '`
    echo -e "Created ${magenta}$SFS_NAME${endcolour} ( $s MB )"
    echo -e "The md5 checksum: $MD5SUM"
  else
    echo "Cannot create SFS:  '${SFS_DIR}' is not a directory."
    exit 1
  fi

  # clean up
  #rm -rf "${SFS_DIR}" &>/dev/null
  #rm -f "${SFS}${SFS_SUFFIX}"*.sfs-md5.txt &>/dev/null
  rm -f "${SFS}${SFS_SUFFIX}" &>/dev/null
}


dir2tgz(){                        # requires $1 as valid dir FUNCLIST

  [ ! -d "$1" ] && print_usage dir2tgz && exit 1

  DIR="${1/.t*gz/}"

  # remove trailing slash
  DIRNAME="`echo -n $DIR | sed -e 's%/$%%'`"
  DIRNAME="`basename ${DIRNAME}`" # get name only, no path

  # make sure any pet specs are named correctly - this new tar file might later be converted to a .pet
  echo "`ls -1 ${DIRNAME} | grep 'pet.specs'`" | while read LINE
  do
    mv "${DIRNAME}/$LINE" "${DIRNAME}/pet.specs" 2>/dev/null;
  done

  # create the tar file
  ##echo "Adding directory to '${DIRNAME}.tar.gz'.."
  tar -c -f "${DIRNAME}.tar" "${DIRNAME}/"
  gzip "${DIRNAME}.tar"
  sync

  # print message
  if [ -f "${DIRNAME}.tar.gz" ];then
    echo -e "Package ${magenta}${DIRNAME}.tar.gz${endcolour} created."
    echo "The md5sum is: `md5sum ${DIRNAME}.tar.gz | cut -f1 -d' '`."
  else
    echo "Package '${DIRNAME}.tar.gz' NOT created."
    return 1
  fi
}


pet2sfs(){                        # convert pet to sfs, $1 must be file or repo pkg FUNCLIST

  # require valid option or quit
  [ ! -f "$1" ] && print_usage pet2sfs && exit 1

  pkg_ext=`get_pkg_ext "$1"`

  [ "$pkg_ext" != pet ] && print_usage pet2sfs && exit 1

  #110213,0.9.1 we want the file in $WORKDIR
  #[ ! -f "${WORKDIR}/$(basename "$1" .pet).pet" ] && cp -f "${1/.pet/}.pet" "${WORKDIR}/$(basename "$1" .pet)" 2>/dev/null

  PKGNAME="$(basename "$1" .pet)" #get pkg name only, no extension or path
  PKGFILE="${CURDIR}/${PKGNAME}.pet" #the file to install

  # determine the compression, extend test to 'XZ'
  file -b "${PKGFILE}" | grep -i -q "^xz" && TAREXT=xz || TAREXT=gz
  [ "$TAREXT" = 'xz' ] && taropts='-xJf' || taropts='-zxf'

  pet2tgz "${PKGFILE}" 1>/dev/null

  # now extract the files into $CURDIR/$PKGNAME/
  tar --force-local $taropts "${PKGFILE//.pet/.tar.$TAREXT}" 2> $TMPDIR/$SELF-cp-errlog

  # if DISTRO_VERSION found, the sfs will prob have a suffix
  [ "$DISTRO_VERSION" != "" ] && SFS_SUFFIX="_${DISTRO_VERSION}" || SFS_SUFFIX=''

  # remove the old one, if needed
  rm "${PKGNAME}${SFS_SUFFIX}.sfs" 2>/dev/null

  # create the new one
  dir2sfs "${CURDIR}/${PKGNAME}" && rm -rf "${CURDIR}/${PKGNAME}"

  # remove the .tar.$TAREXT file
  rm -f "${PKGNAME}.tar.$TAREXT"

  # if pkg put the pet in $CURDIR (not user), remove it
  #[ -f "${PKGFILE}" ] && [ "`dirname "$1"`" != "$CURDIR" ] && rm -f "${PKGFILE}" 2>/dev/null

  # print message
  if [ ! -f "${PKGNAME}.sfs" ] && [ ! -f "${PKGNAME}${SFS_SUFFIX}.sfs" ];then
    echo "Package '${PKGNAME}.pet' not converted."
    return 1
  fi
}


pet2tgz(){                        # convert to tar.gz, $1 must be valid file FUNCLIST

  # if $1 is not a valid pkg name or a file that exists then exit..
  [ ! -f "$1" ] && print_usage pet2tgz && exit 1

  pkg_ext=`get_pkg_ext "$1"`
  [ "$pkg_ext" != "pet" ] && print_usage pet2tgz && exit 1

  PKGNAME="$(basename "$1" .pet)" # get pkg name only, no extension or path
  PKGFILE="$1"          # build the pkg file path

  # backup the package, to restore it later
  cp -f "$PKGFILE" "$TMPDIR/`basename $PKGFILE`.backup" 1>/dev/null

  chmod +w "$PKGFILE" # make it writable.
  FOOTERSIZE="32"

  # determine the compression, extend test to 'XZ'
  finfo=`file -b "$PKGFILE"`
  case $finfo in
    gz*|GZ*) EXT=gz ;;
    xz*|XZ*) EXT=xz ;;
    *) error "Unsupported compression type, or corrupted package." && exit 1 ;;
  esac

  # get the md5
  MD5SUM="`tail -c $FOOTERSIZE \"$PKGFILE\"`"
  NEWNAME="`echo -n \"$PKGFILE\" | sed -e "s/\\.pet$/\\.tar\\.$EXT/g"`" #131122
  head -c -$FOOTERSIZE "$PKGFILE" > $NEWNAME
  NEWMD5SUM="`md5sum \"$NEWNAME\" | cut -f 1 -d ' '`"
  sync
  [ ! "$MD5SUM" = "$NEWMD5SUM" ] && exit 1

  # restore original pet pkg
  [ -f "$TMPDIR/`basename $PKGFILE`.backup" ] && mv -f "$TMPDIR/`basename $PKGFILE`.backup" "$PKGFILE"

  # print message
  if [ -f "$NEWNAME" ];then
    echo -e "${green}Success${endcolour}: Package ${magenta}`basename ${NEWNAME}`${endcolour} created."
    echo "The md5sum is `md5sum "$NEWNAME" | cut -f1 -d' '`."
  else
    error "Package ${PKGNAME}.pet not converted!"
    return 1
  fi
}


pet2txz(){                        # calls pet2tgz FUNCLIST
  pet2tgz "$1"
}


sfs2pet(){                        # convert sfs to pet, requires $1 as a valid sfs FUNCLIST

  # exit if no valid options
  [ ! -f "$1" ] && print_usage sfs2pet && exit 1

  # exit if user did not give an SFS file, or didnt give a file at all
  [ "`file "$1" | grep  Squashfs`" = '' ] && print_usage sfs2pet && exit 1

  # we want the file in $CURDIR
  #[ ! -f "${WORKDIR}/$(basename "${1}")" ] && cp -f "$1" "${WORKDIR}/$(basename "${1}")" 2>/dev/null

  SFSNAME="$(basename "$1")"
  SFSDIR="$(dirname "$1")"
  SFSEXT="${SFSNAME##*.}"

  # if DISTRO_VERSION found, the sfs will prob have a suffix
  [ "$DISTRO_VERSION" != "" ] && SFS_SUFFIX="_${DISTRO_VERSION}" || SFS_SUFFIX=''

  # create the name without path or extension (may include a $SUFFIX)
  ROOTNAME=`basename "$SFSNAME" ".$SFSEXT"`

  # build the file name we will work on
  SFS="${SFSDIR}/${SFSNAME}"

  if [ -f "$SFS" ] && [ "$SFS" != "" ];then

    echo "Unsquashing $SFSNAME.. Please wait.."

    # remove any older dirs, and unsquash
    rm -rf "${CURDIR}/squashfs-root/"
    LANG=C unsquashfs "$SFS"  &>/dev/null

    # lets remove the SFS suffix, to get back the the 'valid' PET name
    ROOTNAME_NOSUFFIX=`echo "$ROOTNAME" | sed -e "s/$SFS_SUFFIX//"`

    # create the folder we will package up
    mv squashfs-root "${ROOTNAME_NOSUFFIX}/"

    dir2tgz "${ROOTNAME_NOSUFFIX}" 1>/dev/null

    tgz2pet "${ROOTNAME_NOSUFFIX}".tar.gz 1>/dev/null

    # remove the dir and the tgz we just created
    rm -rf "${ROOTNAME_NOSUFFIX}"
    rm -f "${ROOTNAME_NOSUFFIX}".tar.gz

    if [ -f "${ROOTNAME_NOSUFFIX}.pet" ];then
      echo -e "${green}Success${endcolour}: Package '${magenta}${ROOTNAME_NOSUFFIX}.pet${endcolour}' created."
      echo "The md5sum is: `md5sum ${ROOTNAME_NOSUFFIX}.pet | cut -f1 -d' '`"
    else
      echo "Package '${ROOTNAME_NOSUFFIX}.pet' not converted."
      return 1
    fi
  fi
}


tgz2pet(){                        # convert $1 (a tar.gz or tgz) to .pet FUNCLIST

  [ ! -f "$1" ] && print_usage tgz2pet && exit 1
  sync
  TARBALL="$1"
  [ ! -f "$TARBALL" ] && echo "The archive '$TARBALL' could not be found." && exit 1

  cp -f $TARBALL "$TMPDIR/`basename $TARBALL`.backup" 1>/dev/null

  TARBALL="${CURDIR}/$(basename "${TARBALL}")"
  chmod 644 "$TARBALL" #make it writable.
  echo "Converting `basename ${TARBALL}`.."

  #only accept .tgz or .tar.gz .tar.xz files...
  EXT=''
  case ${TARBALL} in
    *.tar.gz) EXT='.tar.gz' ;;
    *.tgz)    EXT='.tgz' ;;
    *.tar.xz) EXT='.tar.xz' ;;
    *.txz)    EXT='.txz' ;;
    *) echo "${1##*/}: File extension not allowed" >&2 ; exit 1 ;;
  esac
  [ "$EXT" = "" ] && error "$TARBALL must be a .tgz, .tar.gz, .txz or .tar.xz file" && exit 1

  #split TARBALL path/filename into components...
  BASEPKG="`basename $TARBALL $EXT`"
  DIRPKG="$CURDIR"
  [ "$DIRPKG" = "/" ] && DIRPKG=""
  case $EXT in
  *gz)OPT=-z;;
  *xz)OPT=-J;;
  esac

  # move pkg, update extensions (tgz -> .tar.gz, txz -> .tar.xz)
  # make code later more readable
  case $EXT in
  *tgz)mv -f $TARBALL $DIRPKG/${BASEPKG}.tar.gz
   TARBALL="$DIRPKG/${BASEPKG}.tar.gz"
   EXT='.tar.gz';;
  *txz)mv -f $TARBALL $DIRPKG/${BASEPKG}.tar.xz
   TARBALL="$DIRPKG/${BASEPKG}.tar.xz"
   EXT='.tar.xz';;
  esac

  # if tarball expands direct to '/' want to wrap around it (slackware pkg)... 100628 add -z ...
  # man bad bug here... the thing isn't expanded! #131122
  if [ "`tar --force-local ${OPT} --list -f ${TARBALL} | head -n 1`" = "./" ];then
    tar --force-local --one-top-level=${BASEPKG} -xf ${TARBALL}
    tar --force-local --remove-files -c -f ${DIRPKG}/${BASEPKG}.tar ${BASEPKG}/
    case $EXT in
    *gz) gzip --force --best ${DIRPKG}/${BASEPKG}.tar ;;
    *xz) xz --force -z -9 -e ${DIRPKG}/${BASEPKG}.tar ;;
    esac
  fi

  FULLSIZE="`stat --format=%s ${TARBALL}`"
  MD5SUM="`md5sum $TARBALL | cut -f 1 -d ' '`"
  echo -n "$MD5SUM" >> $TARBALL
  sync
  mv -f $TARBALL $DIRPKG/${BASEPKG}.pet
  sync

  # restore original tar file
  [ -f "$TMPDIR/`basename $TARBALL`.backup" ] && mv -f "$TMPDIR/`basename $TARBALL`.backup" "$TARBALL"

  # print msg
  if [ -f "${DIRPKG}/${BASEPKG}.pet" ];then
    echo -e "${green}Success:${endcolour} Created ${magenta}${BASEPKG}.pet${endcolour}."
    echo "This is the md5sum: `md5sum ${DIRPKG}/${BASEPKG}.pet | cut -f1 -d' '`"
  else
    error "Could not convert ${DIRPKG}/${BASEPKG}.$EXT"
    return 1
  fi
}


txz2pet(){                        # convert txz to pet, requires $1 as valid file FUNCLIST
  [ ! -f "$1" ] && print_usage txz2pet && exit 1
  FILE="$1"   # full path, filename and extension
  #keep old file, download it if needed
  #[ -f "$(basename "$1" .txz)" ] || pkg_download "$(basename "$1" .txz)" #  200813 try to download it
  # we want $FILE in $CURDIR
  [ ! -f "${CURDIR}/$(basename "${FILE}")" ] && cp -f "$FILE" "${CURDIR}/$(basename "${FILE}")" 2>/dev/null
  FILE="${CURDIR}/$(basename "${FILE}")"
  #set vars
  FILENAME="`basename "$FILE"`" # filename and extension only
  BARENAME="${FILENAME/.t*xz/}" # filename, no extension..
  PETFILE="${CURDIR}/${BARENAME}.pet" # the full path and filename of the pet file
  PETNAME="`basename "$PETFILE"`" # the filename of the pet file
  # create the pet directory, if needed
  mkdir -p "${CURDIR}/${BARENAME}"
  [ ! -d "${CURDIR}/${BARENAME}" ] && { echo "PET directory not created or found."; exit 1; }
  # unpack the file
  [ -f "$FILENAME" ] && tar --force-local -Jxvf "$FILENAME" -C "${BARENAME}/" 1>/dev/null || echo "Cannot untar $FILENAME"
  # create the pet file
  dir2pet "$BARENAME" || echo "PET working directory not found"

  if [ -f "$PETFILE" ];then # if pet file was created
    # remove the pet file working directory
    rm -R "${CURDIR}/${BARENAME}/" 2>/dev/null
    rmdir "${CURDIR}/${BARENAME}/" 2>/dev/null
    # report the file was created #nope, no need, dir2pet will do it
    #echo "Package '$PETNAME' created successfully."
  else
    echo "Package "$PETFILE" file not created"
    return 1
  fi
  # delete the original txz file
  rm -f "$FILE" &>/dev/null
}


# other

menu_entry_msg(){                 # show menu entry details of installed pkg FUNCLIST

  # exit if not valid usage
  [ ! "$1" ] || [ "$1" = "-" ] && exit 1

  . ${PKGRC}

  local MENUFILE=''
  local pkg_file_list=''
  local no_display=''
  local terminal_only=''
  local pkg_command=''

  # get the menu file, if it exists
  pkg_file_list=$(find ${REPO_DIR}/ -maxdepth 1 -type f -name "$(get_pkg_name ${1})*.files")

  if [ -f "$pkg_file_list" ];then
    MENUFILE="$(LANG=C grep -m1 '/usr/share/applications/' "$pkg_file_list" \
      | grep -i -m1 ".desktop\$")"
  else
    return 1
  fi

  # if pkg has a .desktop file
   if [ -f "$MENUFILE" ];then

    # exit if the menu item is set to NoDisplay
    no_display="`grep -m1 ^NoDisplay=true "$MENUFILE" 2>/dev/null`"
    terminal_only="`grep -m1 ^Terminal=true "$MENUFILE" 2>/dev/null`"

    # fix menu entries
    sed -i 's/ %u//g' "$MENUFILE"
    sed -i 's/ %U//g' "$MENUFILE"
    sed -i 's/ %f//g' "$MENUFILE"
    sed -i 's/ %F//g' "$MENUFILE"
    sed -i 's/ %d//g' "$MENUFILE"
    sed -i 's/ %D//g' "$MENUFILE"

    update_menus &

    # get the details for a final msg
    MENU_CAT="$(LANG=C grep -m1 "^Categories=" $MENUFILE 2>/dev/null | cut -f2 -d'=' | sed -e 's/\(.*\);/\1/g' -e 's/.*;//g' | head -1)"

    APATTERN="[ ,]${MENU_CAT}" #MHHP
    TOPMENU="$(LANG=C grep -m1 "${APATTERN}" /etc/xdg/menus/hierarchy | cut -f1 -d' ' | head -1)"

    if [ "$TOPMENU" = "" ];then
      APATTERN="[ ,]${MENU_CAT};"
      TOPMENU="$(LANG=C grep -m1 "${APATTERN}" /etc/xdg/menus/hierarchy | cut -f1 -d' ' | head -1)"
    fi

    MENU_NAME="`LANG=C grep -m1 "^Name=" $MENUFILE | cut -f2 -d'=' | head -1`"

    [ "$TOPMENU" = '' ] && TOPMENU="$MENU_CAT"

    # print msg
    if [ "$no_display" != "" ] || [ "$terminal_only" != '' ];then
      pkg_command="$(grep -m1 ^Exec= "$MENUFILE" | cut -f2 -d'=')"
      if [ "$pkg_command" != '' ];then
        echo
        echo -e "To run, type:  ${bold}${pkg_command}${endcolour}"
        echo
      fi
    else
      echo
      echo -e "${bold}Menu entry:     ${lightblue}${TOPMENU:-[None]}${endcolour}${bold} -> ${lightblue}${MENU_NAME:-[None]}${endcolour}"
      echo
    fi
    return 0
  fi
  # if no .desktop file, list the commands in $PATH
  pkg_command="$(cat "$pkg_file_list" | grep -E '/bin/|/sbin/' | sort -u | sed -e 's#.*/#  #g')"
  if [ "$pkg_command" != "" ];then
    echo
    echo -e "To run, type any of these commands:  "
    echo -e "${bold}${pkg_command}${endcolour}"
  fi
  # also list any man pages
  pkg_docs="$(cat "$pkg_file_list" | grep -E '/man[1-8]/' | sort -u | sed -e 's#.*/#  man #g' -e 's/\.gz$//g')"
  if [ "$pkg_docs" != "" ];then
    echo
    echo -e "To view the docs, type any of these commands:  "
    echo -e "${bold}${pkg_docs}${endcolour}"
  fi
  if [ "$pkg_command" != "" ] || [ "$pkg_docs" != "" ];then
    echo
  fi
  return 1
}


update_menus() {                  # update menus, calls fixmenus, refreshes WM
  echo started > /tmp/pkg/update_menus_busy
  fixmenus &>/dev/null
  # refresh JWM menus if using JWM window manager
  [ "`which jwm`" != "" ] && [ "`ps -e | grep jwm`" != "" ] && jwm -reload &>/dev/null
  rm /tmp/pkg/update_menus_busy 2>/dev/null
  return 0
}


check_net(){                      # check net connection (before downloading) FUNCLIST
  [ -f $TMPDIR/internetsuccess ] && echo 0 && exit 0 #220613
  [ ! "$1" ] || [ "$1" = "-" ] && URL="8.8.8.8" || URL="`echo  ${1} | awk -F/ '{print $3}'`"
  LANG=C ping -4 -c1 -q "$URL" &>/dev/null #220613
  REPLY=$?
  [ $REPLY -eq 0 ] && echo -n "ok" > $TMPDIR/internetsuccess #220613
  echo 0
}


get_stdin(){                      # read from stdin (when - is last option) FUNCLIST
  read -t 0.1 STDINVAR
}


not_found(){                      # list alternative packages when no match in repos FUNCLIST
  PKGNAME="${1/.pet/}"
  if [ "$(ls "${WORKDIR}/"| grep "${PKGNAME}")" != "" ];then
    [ "`list_downloaded_pkgs "${PKGNAME}"`" != "" ] && echo "These downloaded packages match your search:
`list_downloaded_pkgs "${PKGNAME}"`"
  fi
    [ "`$PKGSEARCH "${PKGNAME}"`" != "" ] && echo "These packages in the repos match your search:
`$PKGSEARCH "${PKGNAME}"`"
  return 1
}


first_run (){                     # welome message on first run

  # quit if not the first run
  [ ! -f ~/.pkg/firstrun ] && return 0
  # print msg
  echo '============================================================'
  echo -e "  ${bold}$APPNAME $APPVER${endcolour} - a command-line package manager"
  echo '============================================================'
  echo
  echo "  pkg repo-update      # update the contents of each installed repo"
  echo "  pkg repo-list        # list all available repos"
  echo "  pkg repo <name>      # change to the chosen repo"
  echo "  pkg show-config      # show current Pkg settings"
  echo "  pkg workdir <DIR>    # change where to keep downloaded packages"
  echo
  echo "  pkg search <term>    # search all fields in the current repo"
  echo "  pkg names <pkgname>  # search package names in the current repo"
  echo "  pkg status <pkgname> # print info about the given package"
  echo "  pkg add <pkgname>    # install & download packages and dependencies"
  echo
  echo " You can run the commands below to learn more about Pkg:"
  echo
  echo "  pkg help             # help info, all options and some tips"
  echo "  pkg help-all         # full help info, including advanced usage"
  echo "  pkg usage [cmd]      # show every command, or info on the given one"
  echo "  pkg examples         # show lots more example Pkg commands"
  echo
  echo " HINT: Use TAB to auto-complete package and repo names (and more).."
  echo
  echo '============================================================'

  # get the right list of repos
  update_sources &>/dev/null &

  # delete first run flag
  rm -f ~/.pkg/firstrun 2>/dev/null

  # delete other tmp stuff, make it like a first run
  rm $TMPDIR/func_list        &>/dev/null
  rm $TMPDIR/curr_repo_url    &>/dev/null
  rm $TMPDIR/internetsuccess  &>/dev/null
  rm $TMPDIR/pkg_aliases      &>/dev/null
  rm $TMPDIR/pkglist          &>/dev/null
  rm $TMPDIR/pkglist_*        &>/dev/null
  rm $TMPDIR/USRPKGLIST       &>/dev/null
  rm $TMPDIR/PKGSDONE         &>/dev/null
  rm $TMPDIR/deps_installed   &>/dev/null
  rm $TMPDIR/deps_missing     &>/dev/null
  rm $TMPDIR/$SELF-cp-errlog  &>/dev/null
  rm $TMPDIR/*-MISSING.txt    &>/dev/null

  exit 0
}


function pkg_manpage {
  if [ ! "$1" ];then
    $0 usage man
    exit 1
  fi
  local p=$(get_pkg_name "$1")
  local contents=''
  if [ "$(is_usr_pkg "$p")" = "true" ];then
    contents="$(grep -E '/man[1-8]/.*\.gz$' ~/.packages/${p}*.files)"
  else
    if [ "$(list_downloaded_pkgs "$p")" = "" ];then
      pkg d "$p"
    fi
    contents="$(pkg_contents $p)"
  fi
  [ -z "$contents" ] && return 1

  local manpages=$(echo "$contents" \
    | grep -E '/man[1-8]/.*\.gz$' \
    | grep -v ' -> ' \
    | sed -e 's|.*\./|/|g' -e 's|\.gz$||' -e 's|.*/||' \
    | sort -u)

  [ -z "$manpages" ] && return 1
  echo -e "\nOpening these man pages: \n${bold}"
  echo -e "$manpages${endcolor}" | sed 's/^/  /g'
  sleep 1

  for manpage in $manpages
  do
    man $manpage
  done
}


}
#====================  main functions  ======================#


{
#=====================  final checks  =======================#
if [ ! -f "${REPO_DIR}/$REPOFILE" ];then
  REPOFILE="$(cat  /root/.pkg/sources-all /root/.pkg/sources /etc/pkg/sources-all /etc/pkg/sources | grep -m 1 -E "^$REPONAME" | cut -d'|' -f3)"
  [ ! -z "$REPOFILE" ] && touch "${REPO_DIR}/$REPOFILE"
fi
# try to set a default repo if none was found
if [ ! -f "${REPO_DIR}/$REPOFILE" ] || [ ! -f "$HOME/.pkg/sources" ];then

  mkdir -p $HOME/.pkg 2>/dev/null
  mkdir -p ${REPO_DIR} 2>/dev/null
  [ ! -f "$HOME/.pkg/sources" ] && touch $HOME/.pkg/sources
  # try to get repo file from /root if it exists
  if [ -f ${REPO_DIR}/Packages-puppy-noarch-official ];then
    # copy any available Puppy repo files in root to ${REPO_DIR}
    cp ${REPO_DIR}/Packages-puppy-* ${REPO_DIR}/
  fi

  # if repo file was NOT added to home dir, fata error, exit
  if [ ! -f ${REPO_DIR}/Packages-puppy-noarch-official ];then
    error "Repo files not found. Check ${magenta}${REPO_DIR}${endcolour}"
    exit 1
  fi

  # if we got here, the noarch repo file is in ${REPO_DIR}, lets use it as the default/only repo
  echo -e "${yellow}Warning:${endcolour} No repo files found. Setting the default repo to 'noarch'."
  update_sources 1>/dev/null
  set_current_repo noarch 1>/dev/null
  # if repos added ok
  if [ $? -eq 0 ];then
    echo -e "${green}Success:${endcolour} 'noarch' added."
    echo "Re-running: $SELF $*"
    echo
    $SELF "$@"
    exit 0
  fi

fi

# create the user-installed pkgs file if it doesnt exists
[ ! -f ${REPO_DIR}/user-installed-packages ] && touch ${REPO_DIR}/user-installed-packages

first_run

}
#=====================  final checks  =======================#


{
#====================  main interface  ======================#

# run any relevant plugins
ASK=$PLUGIN_ASK FORCE=$FORCE run_plugins 'init'

while [ $# != 0 ]; do # get all options ($# means all options)
   I=1
   while [ ! -z $# -a $I -le `echo $# | wc -c` ]; do

    # accept from stdin, (using dash (-) as final option)
    for x in "$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9"
    do
      case "$x" in
        -)
          while true; do
            read ALINE
            [ "$ALINE" ] || break
            [ "$(echo $ALINE| cut -b1)" = '#' ] && continue # skip comment
            [ "$ALINE" = ':' ] && continue  # skip colon
            if [ "$ALINE" = "- " ] || [ "$ALINE" = " -" ] || [ "$ALINE" != "-" ];then
              OPTS="${@%-}" #get all opts, without last dash
              OPTS="${OPTS% }" #get all opts, strip last space
              $SELF $OPTS "$ALINE"
            fi
          done
          break
        ;;
        --ask|-a)         ASK=true ; PLUGIN_ASK=true; QTAG="?  (y/N)";;
        --quiet|-q)       QUIET=true ;;
        --force|-f)       FORCE=true ;;
        --fix)            PKGFIX=true ;;
        --non-recursive)  NON_RECURSIVE=true ;;
        --no-color)       green='' red='' magenta='' lightblue='' yellow='' bold='' endcolour='' ;;
        --no-colour|-nc)  green='' red='' magenta='' lightblue='' yellow='' bold='' endcolour='' ;;
        '--configure='*)  PKG_CONFIGURE="$(echo "$x" | sed -e 's/^--configure=//')" ;;
        '--cflags='*)     PKG_CFLAGS="$(echo "$x" | sed -e 's/^--cflags=//')"       ;;
      esac
    done

    # enable passing multiple pkgs separated by comma, space,
    # works with or without double quotes around pkgs
    opt="`shift; echo "$@"`"
    opt="${opt//,/ }"
    opt="${opt//|/ }"
    # only keep params up to the next option
    opt="${opt// -*/}"

    ## main options
    case $1 in

      -) # accept from stdin, pkg -i (defaults to pkg add $1 or pkg -u $1)
        if [ "$2" = "" ];then
          while true; do
            read ALINE
            [ "$ALINE" ] && [ "$ALINE" != '-' ] || break
            [ "$(echo $ALINE| cut -b1)" = '#' ] && continue # skip comment
            ALINE=`echo $ALINE` #strip spaces
            if [ "$ALINE" != "-" ] && [ "`$PKGSEARCH "$ALINE"`" != "" ];then
              [ "`is_installed_pkg $ALINE`" = false ] && pkg_get "$ALINE" || \
              pkg_uninstall "$ALINE"
            fi
          done
          shift
        fi
      ;;

      --ask|-a)         ASK=true ; PLUGIN_ASK=true; QTAG="?  (y/N)";;
      --quiet|-q)       QUIET=true ;;
      --force|-f)       FORCE=true ;;
      --fix)            PKGFIX=true ;;
      --non-recursive)  NON_RECURSIVE=true ;;
      --no-color)       green='' red='' magenta='' lightblue='' yellow='' bold='' endcolour='' ;;
      --no-colour|-nc)  green='' red='' magenta='' lightblue='' yellow='' bold='' endcolour='' ;;
      '--configure='*)  PKG_CONFIGURE="$(echo "$1" | sed -e 's/^--configure=//')" ;;
      '--cflags='*)     PKG_CFLAGS="$(echo "$1" | sed -e 's/^--cflags=//')"       ;;

      # package search
      --all-pkgs|--all)                 [ ! "$2" ] && cat ${REPO_DIR}/${REPOFILE} || cat ${REPO_DIR}/${REPOFILE} | grep "$2"; exit 0;;
      --search|-s|search|s)             [ ! "$2" ] && search_pkgs          || for x in "$opt"; do [ "$x" ] && [ "$x" != "-" ] && search_pkgs "$x";         done; ;;
      -ss|ss)                           [ ! "$2" ] && search_fast          || for x in "$opt"; do [ "$x" ] && [ "$x" != "-" ] && search_fast "$x";         done; ;;
      --search-all|-sa|search-all|sa)   [ ! "$2" ] && search_all_pkgs      || for x in "$opt"; do [ "$x" ] && [ "$x" != "-" ] && search_all_pkgs "$x";     done; ;;
      -ssa|ssa)                         [ ! "$2" ] && search_all_fast      || for x in "$opt"; do [ "$x" ] && [ "$x" != "-" ] && search_all_fast "$x";     done; ;;
      --names|-n|names|n)               [ ! "$2" ] && list_pkg_names       || for x in $opt;   do [ "$x" ] && [ "$x" != "-" ] && list_pkg_names "$x";      done; ;;
      --names-exact|-ne|names-exact|ne) [ ! "$2" ] && list_pkg_names       || for x in $opt;   do [ "$x" ] && [ "$x" != "-" ] && list_pkg_names "$x\$";    done; ;;
      --names-all|-na|names-all|na)     [ ! "$2" ] && list_all_pkg_names   || for x in $opt;   do [ "$x" ] && [ "$x" != "-" ] && list_all_pkg_names "$x";  done; ;;
--list-installed|list-installed|-li|li) [ ! "$2" ] && list_installed_pkgs  || for x in $opt;   do [ "$x" ] && [ "$x" != "-" ] && list_installed_pkgs "$x"; done; exit 0 ;;
--list-downloaded|list-downloaded|-ld|ld) [ ! "$2" ] && list_downloaded_pkgs || list_downloaded_pkgs "$2"; exit 0 ;;
--list-builtins|list-builtins|-lb|lb) [ ! "$2" ] && list_builtin_pkgs ||  list_builtin_pkgs "$2"; exit 0 ;;
      -LI|LI)                           [ ! "$2" ] && HIDE_BUILTINS=false list_installed_pkgs || HIDE_BUILTINS=false list_installed_pkgs "$2"; exit 0 ;; # list all installed pkgs inc builtins
  --names-exact-all|-nea|names-exact-all|nea) [ ! "$2" ] && list_all_pkg_names || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && list_all_pkg_names "$x\$"; done; exit 0 ;;

      # get, download, install, remove, pkgs
      --download|-d|download|d)         [ ! "$2" ] && pkg_download || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_download "$x";  done;;
      --install|-i|install|i)           [ ! "$2" ] && pkg_install  || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_install "$x";   done;;
      --uninstall|-u|uninstall|u)       [ ! "$2" ] && pkg_uninstall|| for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_uninstall "$x"; done;;
      --remove|-rm|remove|rm)           [ ! "$2" ] && pkg_remove   || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_remove "$x";    done;;
      --unpack|--extract|unpack|extract)[ ! "$2" ] && pkg_unpack   || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_unpack "$x";    done;;
      --clean|clean)                    [ ! "$2" ] && clean_pkgs   || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && clean_pkgs "$x";    done;;
      --get|-g|get|g|--add|add|a)       [ ! "$2" ] && pkg_get      || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && { choose_pkg "$x"; pkg_get "$x"; }; done ;;
      --get-only|-go|get-only|go)       [ ! "$2" ] && print_usage get-only || for x in $opt; do if [ "$x" ] && [ "$x" != "-" ];then choose_pkg "$x"; NO_INSTALL=true  pkg_get "$x"; fi; done ;;
      --delete|-l|delete|l)             [ ! "$2" ] && print_usage delete   || for x in $opt; do [ "$x" = '-' ] && continue; if [ -f "${WORKDIR}/$(basename "$x")" ];then if [ "$ASK" = true ];then echo -n "Remove package `basename $x`$QTAG "; read -n 1 CONFIRM </dev/tty; echo; else CONFIRM=y; fi; [ "$CONFIRM" = "y" ] && rm -v "${WORKDIR}/$(basename "$x")"; else not_found "$x"; fi; done ;; #110213,0.9.1  renamed to --delete|-l
      --delete-all|-la|delete-all|la)   ASK=true; QTAG="?  (y/N)"; if [ "$ASK" = true ];then echo -en "Remove all downloaded packages in ${lightblue}${WORKDIR}/${endcolour}$QTAG"; read -n 1 CONFIRM </dev/tty; echo; else CONFIRM=y; fi; [ "$CONFIRM" = "y" ] && rm -v ${WORKDIR}/*.pet ${WORKDIR}/*.pkg.* ${WORKDIR}/*.sfs ${WORKDIR}/*.tar.* ${WORKDIR}/*.tcz ${WORKDIR}/*.txz ${WORKDIR}/*.tgz ${WORKDIR}/*.deb ${WORKDIR}/*.rpm ${WORKDIR}/*.apk ${WORKDIR}/*.gz ${WORKDIR}/*.xz 2>/dev/null; exit 0;;
      --install-all|-ia)                list_downloaded_pkgs | while read pkg; do [ "$pkg" ] && [ "$pkg" != "-" ] && pkg_install "$pkg";   done;;
      --uninstall-all|-ua)              list_installed_pkgs  | while read pkg; do [ "$pkg" ] && [ "$pkg" != "-" ] && pkg_uninstall "$pkg"; done;;

      # pkg status, info
      --pkg-installed|-pi|installed|pi)   [ ! "$2" ] && is_installed_pkg || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && is_installed_pkg "$x"; done;;
      --pkg-entry|-pe|entry|pe)           [ ! "$2" ] && pkg_entry   || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_entry "$x";    done;;  # print repo entry, each field on a new line
      --pkg-status|-ps|status|ps)         [ ! "$2" ] && pkg_status  || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_status "$x";   done;;
      --contents|-c|contents|c)           [ ! "$2" ] && pkg_contents|| for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_contents "$x" 2>/dev/null; done;;
      --which|-w|which|w)                 [ ! "$2" ] && which_pkg   || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && which_pkg "$x";    done;;
      --which-repo|-wr|which-repo|wr)     [ ! "$2" ] && which_repo  || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && which_repo "$x";   done;;
      --pkg-repack|-pr|repack|pr)         [ ! "$2" ] && pkg_repack  || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_repack "$x";   done;;
      --pkg-update|-pu|update|pu)         [ ! "$2" ] && pkg_update  || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_update "$x";   done;;
      --pkg-combine|-pc|pkg-combine|pc)   [ ! "$2" ] && pkg_combine || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && COMBINE2SFS=false pkg_combine "$x"; done;;
      --pkg-split|split)                  [ ! "$2" ] && split_pkg   || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && split_pkg "$x"; done;;
      --pkg-merge|merge)                  [ ! "$2" ] && merge_pkg   || merge_pkg "$2" "$3" "$4"; exit 0;;
      --sfs-combine|-sc|sfs-combine|sc)   [ ! "$2" ] && pkg_combine || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && COMBINE2SFS=true  pkg_combine "$x"; done;;
      -PS|PS)                             [ ! "$2" ] && pkg_status  || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && HIDE_USER_PKGS=false FULL_PKG_STATUS=true pkg_status "$x"; done;; # full pkg status, with sorted deps

      --manpage|--man|manpage|man)        [ ! "$2" ] && pkg_manpage || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_manpage "$x"; done;;

      # pkg compiling
      --pkg-build|-pb|build|pb)           [ ! "$2" ] && pkg_build || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && PKG_CONFIGURE="$PKG_CONFIGURE" PKG_CFLAGS="$PKG_CFLAGS" pkg_build "$x"; done;;
   --pkg-build-list|-pbl|build-list|pbl)  [ ! "$2" ] && list_build_scripts || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && list_build_scripts "$x"; done;;

      # blacklist and whitelist
      blacklist)                          [ ! "$2" ] && pkg_blacklist  || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_blacklist "$x"; done;;
      whitelist)                          [ ! "$2" ] && pkg_whitelist  || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && pkg_whitelist "$x"; done;;

      # dependencies
      --what-needs|-wn|what-needs|wn)     [ ! "$2" ] && list_dependents; for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && list_dependents "$x";    done ;; # list pkgs depending on $x, not including builtins by default
      --list-deps|-le|list-deps|le)       [ ! "$2" ] && list_deps; for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && list_deps "$x";                done ;; # list pkg deps, not including builtins
      --deps|-e|deps|e)                   [ ! "$2" ] && get_deps;  for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && get_deps  "$x";                done ;;
    --deps-download|-ed|deps-download|ed) [ ! "$2" ] && get_deps;  for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && NO_INSTALL=true get_deps "$x"; done ;;
      --has-deps|-he|has-deps|he)         [ ! "$2" ] && has_deps;  for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && has_deps  "$x";                done ;;
      --deps-all|-ea|deps-all|ea)         [ ! "$2" ] && get_deps;  [ "$2" != "-" ] && NO_INSTALL=false get_all_deps "$2" ;;
      --deps-check|-ec|deps-check|ec|ldd) [ ! "$2" ] && print_usage deps-check || pkg_ldd "$2" ;;
      -LE|LE)                             [ ! "$2" ] && HIDE_BUILTINS=false list_deps || for x in $opt; do [ "$x" ] && [ "$x" != "-" ] && HIDE_BUILTINS=false list_deps "$x"; done ;;  # list a pkg deps, including builtins

      # repo
      --repo|-r|repo|r)                     [ ! "$2" ] && echo $REPONAME || set_current_repo "$2" ;;
      --repo-convert|-rc|repo-convert|rc)   [ ! "$2" ] && print_usage repo-convert || for x in $opt; do [ "$x" ] && [ "$x" != "-" ]  && convert_repofile "$x"; done ;;
      --repo-list|-rl|repo-list|rl)         [ "$2" != "-" ] && repo_list "$2"      ;;
      --repo-info|-ri|repo-info|ri)         [ "$2" != "-" ] && print_repo_info "$2";;
  --repo-file-list|-rfl|repo-file-list|rfl) [ "$2" != "-" ] && repo_file_list "$2" ;;
      --repo-update|-ru|repo-update|ru)     update_repo "$2";;
      --add-source|add-source)              [ "`echo $2|grep '|'`" = '' ] || [ "$2" = '-' ] && print_usage add-source || add_source "$2";;
      --add-repo|add-repo)                  [ ! "$2" ] || [ "$2" = '-'  ] && print_usage add-repo || shift; add_repo "$@"; exit 0;;
      --rm-repo|rm-repo)                    [ ! "$2" ] || [ "$2" = '-'  ] && print_usage rm-repo  || rm_repo "$2"; exit 0;;
      --update-sources|update-sources)      update_sources ;;

      # set repo settings
      --repo-pkg-scope|-rps|rps|repo-pkg-scope)  if [ "$2" ] && [ "$2" != "-" ];then set_pkg_scope "$2";      else echo "$PKGSCOPE"; fi; exit 0;;
      --repo-dep-scope|-rds|repo-dep-scope|rds)  if [ "$2" ] && [ "$2" != "-" ];then set_dep_scope "$2";      else echo "$DEPSCOPE"; fi; exit 0;;
      --bleeding-edge|-be|bleeding-edge|be)      if [ "$2" ] && [ "$2" != "-" ];then set_bleeding_edge "$2";  else echo "$BLEDGE";   fi; exit 0;;
      --rdep-check|-rdc|rdep-check|rdc)          if [ "$2" ] && [ "$2" != "-" ];then set_recursive_deps "$2"; else echo "$RDCHECK";  fi; exit 0;;

      # convert
      --deb2pet|deb2pet) [ ! "$2" ] && deb2pet || for x in $opt; do deb2pet "$x"; done ;;
      --dir2pet|dir2pet) [ ! "$2" ] && dir2pet || for x in $opt; do dir2pet "$x"; done ;;
      --dir2sfs|dir2sfs) [ ! "$2" ] && dir2sfs || for x in $opt; do dir2sfs "$x"; done ;;
      --dir2tgz|dir2tgz) [ ! "$2" ] && dir2tgz || for x in $opt; do dir2tgz "$x"; done ;;
      --pet2sfs|pet2sfs) [ ! "$2" ] && pet2sfs || for x in $opt; do pet2sfs "$x"; done ;;
      --pet2tgz|pet2tgz) [ ! "$2" ] && pet2tgz || for x in $opt; do pet2tgz "$x"; done ;;
      --pet2txz|pet2txz) [ ! "$2" ] && pet2txz || for x in $opt; do pet2txz "$x"; done ;;
      --sfs2pet|sfs2pet) [ ! "$2" ] && sfs2pet || for x in $opt; do sfs2pet "$x"; done ;;
      --tgz2pet|tgz2pet) [ ! "$2" ] && tgz2pet || for x in $opt; do tgz2pet "$x"; done ;;
      --txz2pet|txz2pet) [ ! "$2" ] && txz2pet || for x in $opt; do txz2pet "$x"; done ;;
    --dir2repo|dir2repo) [ ! "$2" ] && dir2repo|| for x in $opt; do dir2repo "$x"; done ;;

      # other
      --func-list|func-list)  [ -f $TMPDIR/func_list ] && cat $TMPDIR/func_list || func_list; exit 0;;
      --workdir|workdir)      [ "$2" != "-" ] && set_workdir "$2"; exit $?;;
      --autoclean|autoclean)  [ "$2" = "yes" ] || [ "$2" = "no" ] && set_autoclean "$2" || { echo "$AUTOCLEAN"; exit 1; } ;;

      # usage, help funcs, version info, etc
      --welcome|welcome)          touch $HOME/.pkg/firstrun; first_run; exit 0;;
      --show-config|show-config)  show_config; exit 0;;
      --version|-v|version|v)     echo "$APPNAME $APPVER"; exit 0;;
      --usage|usage)              print_usage "$2"; exit 0;;

      --examples|-ex|examples|ex)
        . /usr/share/pkg/docs/examples.txt;
        echo -e "$EXAMPLES\n"
        exit 0
        ;;
      --help-all|-H|help-all|H)
          . /usr/share/pkg/docs/env_vars.txt
          . /usr/share/pkg/docs/help.txt
          . /usr/share/pkg/docs/examples.txt
          . /usr/share/pkg/docs/help-all.txt
          echo -e "$HELP_ALL\n\n" | less -R
          exit 0
          ;;

      --help|-h|help|h)
          . /usr/share/pkg/docs/env_vars.txt
          . /usr/share/pkg/docs/help.txt
          echo -e "$HELP\n"
          exit 0
          ;;

      # any other options
      -?*|--?*)
          # exit if bad options
          echo "Unknown option '$1'" && exit 1
        ;;

      ?*)
          # all other options .. might be an internal func, if so, execute it with all given options
          [ "`func_list | tr '\t' ' ' | cut -f2 -d' ' | grep -m1 "^${1}"'()'`" != '' ] && "$@" && exit 0
        ;;

      esac

      shift
      I=$(($I + 1))
    done
done


}
#====================  main interface  ======================#
code=$?

# if AUTOCLEAN=true silently delete all pkgs in WORKDIR that are already installed
if [ "$AUTOCLEAN" = 'yes' ] && [ "`HIDE_BUILTINS=true list_installed_pkgs`" != '' ];then
  clean_pkgs &>/dev/null
fi



# remove tmp dir used by pkg_get and get_deps
rm $TMPDIR/PKGSDONE $TMPDIR/DEP_DONE 2>/dev/null

# reset lang options as we found them
LANG=$USER_LANG
LC_ALL=$USER_LC_ALL

# run any relevant plugins
ASK=$PLUGIN_ASK FORCE=$FORCE run_plugins 'exit'

exit $code
